var vueComposable = (function (exports, compositionApi, Vue) {
  'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

  var Vue__default = /*#__PURE__*/_interopDefaultLegacy(Vue);

  function unwrap(o) {
      return compositionApi.isRef(o) ? o.value : o;
      // return unref(o) as T;
  }
  function wrap(o) {
      return compositionApi.isRef(o) ? o : compositionApi.ref(o); // NOTE in v3 this is not necessary
  }
  const isArray = Array.isArray;
  const isFunction = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isBoolean = (val) => typeof val === "boolean";
  const isUndefined = (val) => typeof val === "undefined";
  const isNull = (val) => val === null;
  const isDate = (val) => isObject(val) && isFunction(val.getTime);
  const isNumber = (val) => typeof val === "number";
  const isObject = (val) => val !== null && typeof val === "object";
  const isElement = (val) => isObject(val) && !!val.tagName;
  function isPromise(val) {
      return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  }
  const NO_OP = () => { };
  const FALSE_OP = () => false;
  const PASSIVE_EV = { passive: true };
  function promisedTimeout(timeout) {
      return new Promise((res) => {
          setTimeout(res, timeout);
      });
  }
  // https://v8.dev/blog/react-cliff
  const MAX_ARRAY_SIZE = 2 ** 32 - 2;
  function minMax(val, min, max) {
      if (val < min)
          return min;
      if (val > max)
          return max;
      return val;
  }
  const isClient = typeof window != "undefined";
  function deepClone(result, ...sources) {
      for (let i = 0; i < sources.length; i++) {
          const source = sources[i];
          if (source === undefined || !isObject(source))
              continue;
          const keys = Object.keys(source);
          for (let j = 0; j < keys.length; j++) {
              const k = keys[j];
              const v = unwrap(source[k]);
              const sourceType = typeof v;
              const type = typeof result[k];
              if (result[k] === undefined || sourceType === type) {
                  result[k] = isObject(v)
                      ? deepClone(result[k] || {}, v)
                      : source[k]; // source[k] is assigned because if is ref we want to override to this ref
              }
          }
      }
      return result;
  }
  // compact version: https://stackoverflow.com/a/33146982/1209882
  /**
   * returns a random string
   * @param len length of the string max: 36
   */
  // export function randomString(len: number) {
  //   return (+new Date).toString(36).slice(-len);
  // }

  /* istanbul ignore file */
  const vueDelete = (x, o) => Vue__default.delete(x, o);
  const vueSet = compositionApi.set;
  // FAKE readonly
  function readonly(target) {
      return compositionApi.computed(() => unwrap(target));
  }

  function useEvent(el, name, listener, options) {
      let remove = NO_OP;
      if (el) {
          const element = wrap(el);
          const removeEventListener = (e) => e.removeEventListener(name, listener);
          const addEventListener = (e) => e.addEventListener(name, listener, options);
          const removeWatch = compositionApi.watch(element, (n, _, cleanUp) => {
              if (n) {
                  addEventListener(n);
                  cleanUp(() => removeEventListener(n));
              }
          }, { immediate: true });
          remove = () => {
              removeEventListener(element.value);
              removeWatch();
          };
      }
      return remove;
  }

  /**
   * Create `debounced` function, options object can be changed after creation to update behaviour
   * @param handler - function to be debounced
   * @param wait - debounce ms
   * @param options - debounce options
   */
  function useDebounce(handler, wait, options) {
      return debounce(handler, wait, options);
  }
  function debounce(func, waitMilliseconds = 50, options = {
      isImmediate: false
  }) {
      let timeoutId;
      return function (...args) {
          const context = this;
          const doLater = function () {
              timeoutId = undefined;
              if (!options.isImmediate) {
                  func.apply(context, args);
              }
          };
          const shouldCallNow = options.isImmediate && timeoutId === undefined;
          if (timeoutId !== undefined) {
              clearTimeout(timeoutId);
          }
          timeoutId = setTimeout(doLater, waitMilliseconds);
          if (shouldCallNow) {
              func.apply(context, args);
          }
      };
  }

  function useOnMouseMove(el, options, wait) {
      const mouseX = compositionApi.ref(0);
      const mouseY = compositionApi.ref(0);
      const pageX = compositionApi.ref(0);
      const pageY = compositionApi.ref(0);
      let handler = (ev) => {
          mouseX.value = ev.x;
          mouseY.value = ev.y;
          pageX.value = ev.pageX;
          pageY.value = ev.pageY;
      };
      const [eventOptions, ms] = isNumber(options)
          ? [undefined, options]
          : [options, wait];
      if (ms) {
          handler = useDebounce(handler, wait);
      }
      const remove = useEvent(el, "mousemove", handler, eventOptions);
      return {
          mouseX,
          mouseY,
          pageX,
          pageY,
          remove,
      };
  }

  function useOnResize(el, options, wait) {
      const element = wrap(el);
      const height = compositionApi.ref(element.value && element.value.clientHeight);
      const width = compositionApi.ref(element.value && element.value.clientWidth);
      let handler = () => {
          height.value = element.value.clientHeight;
          width.value = element.value.clientWidth;
      };
      const [eventOptions, ms] = isNumber(options)
          ? [undefined, options]
          : [options, wait];
      if (ms) {
          handler = useDebounce(handler, wait);
      }
      // resize seems only to be fired against the window
      const remove = isClient
          ? useEvent(window, "resize", handler, eventOptions || PASSIVE_EV)
          : /* istanbul ignore next */ NO_OP;
      if (compositionApi.isRef(el) && !el.value) {
          compositionApi.onMounted(handler);
      }
      return {
          height,
          width,
          remove
      };
  }

  const SCROLL_METHODS = ["scrollBy", "scrollTo", "scrollIntoView"];
  function useOnScroll(el, options, wait) {
      const isValidElement = (el) => isNumber(el) || isBoolean(el) || !(isElement(el) || compositionApi.isRef(el)) || !el
          ? false
          : true;
      const element = isValidElement(el)
          ? wrap(el)
          : compositionApi.ref((isClient && window) || undefined);
      const scrollableElement = isValidElement(el)
          ? element
          : compositionApi.ref((isClient && window.document.scrollingElement) || undefined);
      const scrollTop = compositionApi.ref((scrollableElement.value && scrollableElement.value.scrollTop) || 0);
      const scrollLeft = compositionApi.ref((scrollableElement.value && scrollableElement.value.scrollLeft) || 0);
      let handler = () => {
          scrollTop.value = scrollableElement.value.scrollTop;
          scrollLeft.value = scrollableElement.value.scrollLeft;
      };
      const methods = SCROLL_METHODS.reduce((p, c) => {
          //@ts-ignore
          p[c] = (...args) => 
          //@ts-ignore
          scrollableElement.value &&
              //@ts-ignore
              scrollableElement.value[c] &&
              //@ts-ignore
              scrollableElement.value[c].apply(scrollableElement.value, args);
          return p;
      }, {});
      const scrollTopTo = (top) => methods.scrollTo({ top });
      const scrollLeftTo = (left) => methods.scrollTo({ left });
      const [eventOptions, ms] = isNumber(el) || !el
          ? [PASSIVE_EV, el]
          : isNumber(options)
              ? [PASSIVE_EV, options]
              : [options, wait];
      if (ms) {
          handler = useDebounce(handler, wait);
      }
      const eventRemove = useEvent(element, "scroll", handler, eventOptions);
      const watchRemoveTop = compositionApi.watch(scrollTop, scrollTopTo, { immediate: false });
      const watchRemoveLeft = compositionApi.watch(scrollLeft, scrollLeftTo, { immediate: false });
      const remove = () => {
          eventRemove();
          watchRemoveLeft();
          watchRemoveTop();
      };
      return {
          scrollTop,
          scrollLeft,
          remove,
          scrollTopTo,
          scrollLeftTo,
          ...methods,
      };
  }

  const events = ["mousedown", "touchstart"];
  function useOnOutsidePress(el, onOutsidePressCallback) {
      if (!isClient) {
          return () => { };
      }
      const element = wrap(el);
      const handler = (e) => element.value &&
          !element.value.contains(e.target) &&
          onOutsidePressCallback(e);
      const event = events.find(x => `on${x}` in document.documentElement);
      return useEvent(document, event, handler, { passive: true });
  }

  function usePromise(fn, lazyOptions) {
      if (!fn) {
          throw new Error(`[usePromise] argument can't be '${fn}'`);
      }
      if (typeof fn !== "function") {
          throw new Error(`[usePromise] expects function, but received ${typeof fn}`);
      }
      const [lazy, throwException] = isBoolean(lazyOptions)
          ? [lazyOptions, false]
          : isObject(lazyOptions)
              ? [lazyOptions.lazy, lazyOptions.throwException]
              : [false, false];
      const loading = compositionApi.ref(false);
      const error = compositionApi.ref(null);
      const result = compositionApi.ref(null);
      const promise = compositionApi.ref();
      const exec = async (...args) => {
          loading.value = true;
          error.value = null;
          const throwExp = args &&
              fn.length !== args.length &&
              args.length > 0 &&
              isBoolean(args[args.length - 1])
              ? args[args.length - 1]
              : throwException;
          const currentPromise = (promise.value = fn(...args));
          try {
              const r = await currentPromise;
              if (promise.value === currentPromise) {
                  result.value = r;
              }
              return r;
          }
          catch (er) {
              if (compositionApi.toRaw(promise.value) === compositionApi.toRaw(currentPromise)) {
                  error.value = er;
                  result.value = null;
              }
              // if(throwExp){
              //   throw er
              // }
              // return undefined
              return throwExp ? currentPromise : undefined;
          }
          finally {
              if (promise.value === currentPromise) {
                  loading.value = false;
              }
          }
      };
      if (!lazy) {
          /* istanbul ignore else */
          {
              if (fn.length > 0 &&
                  !isBoolean(isObject(lazyOptions) ? lazyOptions.lazy : lazyOptions)) {
                  console.warn("[usePromise] parameters detected on `fn` factory. Executing promise without arguments.");
              }
          }
          // @ts-ignore
          exec();
      }
      return {
          exec,
          result,
          promise,
          loading,
          error,
      };
  }

  function useCancellablePromise(fn, lazyOptions) {
      const cancelled = compositionApi.ref(false);
      let _cancel = undefined;
      const cancel = (result) => {
          if (!_cancel) {
              /* istanbul ignore else */
              {
                  console.warn("[useCancellablePromise] There's no promise to cancel. Please make sure to call `exec`");
              }
              return;
          }
          _cancel(result);
      };
      const promise = (p) => new Promise((res, rej) => {
          cancelled.value = false;
          _cancel = (result) => {
              cancelled.value = true;
              rej(result);
          };
          p.then(res).catch(rej);
      });
      const use = usePromise((...args) => promise(fn(...args)), lazyOptions);
      if (compositionApi.getCurrentInstance() &&
          (!isObject(lazyOptions) || lazyOptions.unmountCancel !== false)) {
          compositionApi.onUnmounted(() => _cancel && _cancel());
      }
      return {
          ...use,
          cancel,
          cancelled,
      };
  }

  const MAX_RETRIES = 9000;
  /* istanbul ignore next */
  const ExecutionId = /*#__PURE__*/ Symbol(("RetryId") );
  /* istanbul ignore next */
  const CancellationToken = /*#__PURE__*/ Symbol(("CancellationToken") );
  const defaultStrategy = async (options, context, factory, args) => {
      const retryId = context[ExecutionId].value;
      let i = -1;
      const maxRetries = options.maxRetries || MAX_RETRIES + 1;
      const delay = options.retryDelay || noDelay;
      context.retryErrors.value = [];
      context.isRetrying.value = false;
      context.nextRetry.value = undefined;
      let nextRetry = undefined;
      do {
          let success = false;
          let result = null;
          try {
              ++i;
              if (args) {
                  result = factory(...args);
              }
              else {
                  result = factory();
              }
              if (isPromise(result)) {
                  result = await result;
              }
              // is cancelled?
              if (context[CancellationToken].value) {
                  return null;
              }
              success = true;
          }
          catch (error) {
              result = null;
              context.retryErrors.value.push(error);
          }
          // is our retry current one?
          if (retryId !== context[ExecutionId].value) {
              return result;
          }
          if (success) {
              context.isRetrying.value = false;
              context.nextRetry.value = undefined;
              return result;
          }
          if (i >= maxRetries) {
              context.isRetrying.value = false;
              context.nextRetry.value = undefined;
              return Promise.reject(new Error(`[useRetry] max retries reached ${maxRetries}`));
          }
          context.isRetrying.value = true;
          const now = Date.now();
          const pDelayBy = delay(i); // wrapped
          const delayBy = isPromise(pDelayBy) ? await pDelayBy : pDelayBy; // unwrap promise
          if (!isPromise(pDelayBy) || !!delayBy) {
              if (isNumber(delayBy)) {
                  nextRetry = delayBy;
              }
              else if (isDate(delayBy)) {
                  nextRetry = delayBy.getTime();
              }
              else {
                  throw new Error(`[useRetry] invalid value received from options.retryDelay '${typeof delayBy}'`);
              }
              // if the retry is in the past, means we need to await that amount
              if (nextRetry < now) {
                  context.nextRetry.value = now + nextRetry;
              }
              else {
                  context.nextRetry.value = nextRetry;
                  nextRetry = nextRetry - now;
              }
              if (nextRetry > 0) {
                  await promisedTimeout(nextRetry);
              }
          }
          // is cancelled?
          if (context[CancellationToken].value) {
              return null;
          }
          // is our retry current one?
          if (retryId !== context[ExecutionId].value) {
              return result;
          }
      } while (i < MAX_RETRIES);
      return null;
  };
  function useRetry(options, factory) {
      const opt = !options || isFunction(options) ? {} : options;
      const fn = isFunction(options) ? options : factory;
      if (!isFunction(options) && !isObject(options)) {
          throw new Error("[useRetry] options needs to be 'object'");
      }
      if (!!fn && !isFunction(fn)) {
          throw new Error("[useRetry] factory needs to be 'function'");
      }
      const isRetrying = compositionApi.ref(false);
      const nextRetry = compositionApi.ref();
      const retryErrors = compositionApi.ref([]);
      const cancellationToken = { value: false };
      const retryId = { value: 0 };
      const retryCount = compositionApi.computed(() => retryErrors.value.length);
      const context = {
          isRetrying,
          retryCount,
          nextRetry,
          retryErrors,
          [ExecutionId]: retryId,
          [CancellationToken]: cancellationToken
      };
      const exec = fn
          ? (...args) => {
              ++context[ExecutionId].value;
              return defaultStrategy(opt, context, fn, args);
          }
          : (f) => {
              ++context[ExecutionId].value;
              return defaultStrategy(opt, context, f, undefined);
          };
      const cancel = () => {
          context.isRetrying.value = false;
          context.retryErrors.value.push(new Error("[useRetry] cancelled"));
          context.nextRetry.value = undefined;
          cancellationToken.value = true;
      };
      return {
          ...context,
          cancel,
          exec
      };
  }
  const exponentialDelay = retryNumber => {
      const delay = Math.pow(2, retryNumber) * 100;
      const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay
      return delay + randomSum;
  };
  const noDelay = () => 0;

  function usePromiseLazy(fn, throwException = false) {
      // @ts-ignore
      return usePromise(fn, {
          lazy: true,
          throwException
      });
  }

  // istanbul ignore next
  const DEVTOOLS_KEY = 
  /*#__PURE__*/ Symbol(("DEVTOOLS_KEY") );
  /**
   * provide devtools api instance to the app
   * @param app
   * @param api
   */
  function setDevtools(app, api) {
      if (!isFunction(app.provide)) {
          console.warn("[vue-composable] devtools is not supported for vue 2");
          return;
      }
      app.provide(DEVTOOLS_KEY, api);
  }
  /**
   * Exposes the internal devtools api instance
   */
  function getDevtools() {
      const empty = {};
      const devtools = compositionApi.inject(DEVTOOLS_KEY, empty);
      if (devtools === empty) {
          console.warn(`[vue-composable] devtools not found, please run app.use(VueComposableDevtools)`);
          return undefined;
      }
      return devtools;
  }

  let apiProxyFactory = undefined;
  async function pushEventsToApi(api, EventQueue, ApiQueue) {
      setTimeout(async () => {
          const priority = [
              "addTimelineLayer",
              "addInspector",
              "sendInspectorTree",
              "sendInspectorState",
              "addTimelineEvent",
          ];
          for (const k of priority) {
              for (const it of ApiQueue.filter((x) => x.type === k)) {
                  // @ts-ignore
                  api[k](...it.args);
              }
              await promisedTimeout(20);
          }
          new Set(ApiQueue.filter((x) => x.type === "notifyComponentUpdate").map((x) => x.args[0])).forEach((x) => api.notifyComponentUpdate(x));
          // @ts-ignore
          EventQueue.forEach((x) => api.on[x.type](...x.args));
          EventQueue.length = 0;
          ApiQueue.length = 0;
      }, 100);
  }
  {
      apiProxyFactory = (promiseApi) => {
          const EventQueue = [];
          const ApiQueue = [];
          let api;
          function queueEvent(type, args) {
              if (api) {
                  //@ts-ignore
                  api[type](...args);
              }
              else {
                  ApiQueue.push({ type, args });
              }
          }
          promiseApi.then((x) => {
              api = x;
              pushEventsToApi(api, EventQueue, ApiQueue);
          });
          const proxyApi = {
              notifyComponentUpdate() {
                  queueEvent("notifyComponentUpdate", arguments);
              },
              addTimelineLayer() {
                  queueEvent("addTimelineLayer", arguments);
              },
              addTimelineEvent() {
                  queueEvent("addTimelineEvent", arguments);
              },
              addInspector() {
                  queueEvent("addInspector", arguments);
              },
              sendInspectorTree() {
                  queueEvent("sendInspectorTree", arguments);
              },
              sendInspectorState() {
                  queueEvent("sendInspectorState", arguments);
              },
              getComponentBounds() {
                  queueEvent("getComponentBounds", arguments);
              },
              getComponentName() {
                  queueEvent("getComponentName", arguments);
              },
              getComponentInstances() {
                  queueEvent("getComponentInstances", arguments);
              },
              highlightElement() {
                  queueEvent("highlightElement", arguments);
              },
              unhighlightElement() {
                  queueEvent("unhighlightElement", arguments);
              },
              selectInspectorNode() {
                  queueEvent("selectInspectorNode", arguments);
              },
              getSettings() {
                  queueEvent("getSettings", arguments);
              },
              setSettings() {
                  queueEvent("setSettings", arguments);
              },
              on: {
                  transformCall(handler) {
                      if (api) {
                          api.on.transformCall(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "transformCall", arg: arguments });
                      }
                  },
                  getAppRecordName(handler) {
                      if (api) {
                          api.on.getAppRecordName(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getAppRecordName", arg: arguments });
                      }
                  },
                  getAppRootInstance(handler) {
                      if (api) {
                          api.on.getAppRootInstance(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getAppRootInstance", arg: arguments });
                      }
                  },
                  registerApplication(handler) {
                      if (api) {
                          api.on.registerApplication(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "registerApplication", arg: arguments });
                      }
                  },
                  walkComponentTree(handler) {
                      if (api) {
                          api.on.walkComponentTree(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "walkComponentTree", arg: arguments });
                      }
                  },
                  visitComponentTree(handler) {
                      if (api) {
                          api.on.visitComponentTree(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "visitComponentTree", arg: arguments });
                      }
                  },
                  walkComponentParents(handler) {
                      if (api) {
                          api.on.walkComponentParents(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "walkComponentParents", arg: arguments });
                      }
                  },
                  inspectComponent(handler) {
                      if (api) {
                          api.on.inspectComponent(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "inspectComponent", arg: arguments });
                      }
                  },
                  getComponentBounds(handler) {
                      if (api) {
                          api.on.getComponentBounds(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getComponentBounds", arg: arguments });
                      }
                  },
                  getComponentName(handler) {
                      if (api) {
                          api.on.getComponentName(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getComponentName", arg: arguments });
                      }
                  },
                  getComponentInstances(handler) {
                      if (api) {
                          api.on.getComponentInstances(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getComponentInstances", arg: arguments });
                      }
                  },
                  getElementComponent(handler) {
                      if (api) {
                          api.on.getElementComponent(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getElementComponent", arg: arguments });
                      }
                  },
                  getComponentRootElements(handler) {
                      if (api) {
                          api.on.getComponentRootElements(handler);
                      }
                      else {
                          EventQueue.push({
                              //@ts-expect-error
                              type: "getComponentRootElements",
                              arg: arguments,
                          });
                      }
                  },
                  editComponentState(handler) {
                      if (api) {
                          api.on.editComponentState(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "editComponentState", arg: arguments });
                      }
                  },
                  getComponentDevtoolsOptions(handler) {
                      if (api) {
                          api.on.getComponentDevtoolsOptions(handler);
                      }
                      else {
                          EventQueue.push({
                              //@ts-expect-error
                              type: "getComponentDevtoolsOptions",
                              arg: arguments,
                          });
                      }
                  },
                  inspectTimelineEvent(handler) {
                      if (api) {
                          api.on.inspectTimelineEvent(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "inspectTimelineEvent", arg: arguments });
                      }
                  },
                  getInspectorTree(handler) {
                      if (api) {
                          api.on.getInspectorTree(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getInspectorTree", arg: arguments });
                      }
                  },
                  getInspectorState(handler) {
                      if (api) {
                          api.on.getInspectorState(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getInspectorState", arg: arguments });
                      }
                  },
                  editInspectorState(handler) {
                      if (api) {
                          api.on.editInspectorState(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "editInspectorState", arg: arguments });
                      }
                  },
                  setPluginSettings(handler) {
                      if (api) {
                          api.on.setPluginSettings(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "setPluginSettings", arg: arguments });
                      }
                  },
                  getComponentRenderCode(handler) {
                      if (api) {
                          api.on.getComponentRenderCode(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "getComponentRenderCode", arg: arguments });
                      }
                  },
                  timelineCleared(handler) {
                      if (api) {
                          api.on.timelineCleared(handler);
                      }
                      else {
                          //@ts-expect-error
                          EventQueue.push({ type: "timelineCleared", arg: arguments });
                      }
                  },
              },
          };
          return proxyApi;
      };
  }
  var ProxyApi = apiProxyFactory;

  let setupDevtoolsPlugin = NO_OP;
  // NOTE maybe change this to other flag
  {
      try {
          setupDevtoolsPlugin = require("@vue/devtools-api").setupDevtoolsPlugin;
      }
      catch { }
  }
  const UseDevtoolsApp = (app, id = "vue-composable", label = "Vue-composable devtools plugin") => {
      const promise = new Promise((res) => {
          setupDevtoolsPlugin({
              id,
              label,
              app,
          }, res);
      });
      setDevtools(app, ProxyApi(promise));
  };

  const VueComposableDevtools = {
      install(app, options = {
          id: "vue-composable",
          label: "Vue-composable devtools plugin"
      }) {
          return UseDevtoolsApp(app, options.id, options.label);
      }
  };

  function useDevtoolsInspector(options, nodeList = []) {
      const api = getDevtools();
      const nodes = compositionApi.ref(nodeList);
      const byId = compositionApi.computed(() => {
          if (!nodes.value)
              return new Map();
          const r = compositionApi.toRaw(nodes.value);
          const m = new Map();
          for (const i of r) {
              m.set(i.id, i);
          }
          return m;
      });
      if (api) {
          const id = options.id;
          api.addInspector(options);
          // api.on.getInspectorState();
          api.on.getInspectorTree((payload) => {
              if (payload.inspectorId != id)
                  return;
              if (!nodes.value)
                  return;
              const filter = payload.filter;
              let m = compositionApi.toRaw(nodes.value);
              if (payload.filter) {
                  if (options.nodeFilter) {
                      m = options.nodeFilter(payload.filter, m);
                  }
                  else {
                      // TODO better filtering, only currently filtering root nodes
                      m = m.filter((x) => x.id.indexOf(filter) >= 0 || x.label.indexOf(filter) >= 0);
                  }
              }
              payload.rootNodes = m;
          });
          api.on.getInspectorState((payload) => {
              if (payload.inspectorId != id)
                  return;
              const node = byId.value.get(payload.nodeId);
              if (node) {
                  const s = compositionApi.reactive(node.state); // unwrap
                  payload.state = options.stateFilter ? options.stateFilter("", s) : s;
              }
          });
          compositionApi.watch(nodes, () => {
              api.sendInspectorTree(id);
              api.sendInspectorState(id);
          }, {
              immediate: true,
              deep: true,
          });
      }
      return {
          nodes,
      };
  }

  function useDevtoolsTimelineLayer(id, label, color) {
      const api = getDevtools();
      let addEvent = NO_OP;
      let pushEvent = NO_OP;
      if (api) {
          api.addTimelineLayer({
              id,
              label,
              color,
          });
          addEvent = (event, all) => api.addTimelineEvent({ layerId: id, event, all });
          pushEvent = (event) => addEvent({ ...event, time: Date.now() });
      }
      return {
          id,
          addEvent,
          pushEvent,
      };
  }

  function getSetupStateExtra(raw) {
      if (!raw)
          return {};
      // NOTE vue3!
      const isRef = !!raw.__v_isRef;
      const isComputed = isRef && !!raw.effect;
      const isReactive = !!raw.__v_reactive;
      const objectType = isComputed
          ? "Computed"
          : isRef
              ? "Ref"
              : isReactive
                  ? "Reactive"
                  : null;
      return {
          ...(objectType ? { objectType } : {}),
          ...(raw.effect ? { raw: raw.effect.raw.toString() } : {}),
      };
  }
  function useDevtoolsComponentState(state, options) {
      const instance = compositionApi.getCurrentInstance();
      const api = getDevtools();
      if (api && instance) {
          api.on.inspectComponent((payload, ctx) => {
              if (payload.componentInstance !== instance)
                  return;
              const [type, multiple] = isObject(options)
                  ? [options.type, options.multiple]
                  : ["setup", false];
              if (isFunction(state)) {
                  state(payload.instanceData, ctx);
                  return;
              }
              let data = isArray(state)
                  ? state
                  : Object.keys(state).map((key) => ({
                      type,
                      key,
                      value: unwrap(state[key]),
                      ...getSetupStateExtra(state[key]),
                  }));
              if (!multiple) {
                  const inserted = new Set(payload.instanceData.state.map((x) => x.key));
                  data = data.filter((x) => !inserted.has(x.key));
              }
              payload.instanceData.state.push(...data);
          });
      }
  }

  function isFetchOptions(v) {
      return (v &&
          (isBoolean(v.isJson) ||
              isBoolean(v.parseImmediate) ||
              isBoolean(v.unmountCancel)));
  }
  function useFetch(options, requestInitOptions) {
      // TODO move to computeAsync
      const json = compositionApi.ref(null);
      const text = compositionApi.ref("");
      const blob = compositionApi.ref();
      const jsonError = compositionApi.ref(null);
      const [isJson, parseImmediate, unmountCancel] = isFetchOptions(options)
          ? [
              options.isJson !== false,
              options.parseImmediate !== false,
              options.unmountCancel !== false,
          ]
          : isFetchOptions(requestInitOptions)
              ? [
                  requestInitOptions.isJson !== false,
                  requestInitOptions.parseImmediate !== false,
                  requestInitOptions.unmountCancel !== false,
              ]
              : [true, true, true];
      const requestInit = options
          ? isString(options)
              ? requestInitOptions
              : isFetchOptions(options)
                  ? options
                  : isString(options.url)
                      ? requestInitOptions
                      : options
          : undefined;
      let addTimelineEvent = undefined;
      let devtoolId = isString(options)
              ? options
              : options && isString(options.url)
                  ? options.url
                  : "useFetch"
          ;
      if (devtoolId) {
          const layer = useDevtoolsTimelineLayer(`useFetch:${devtoolId}`, devtoolId, 0x32a2bf);
          addTimelineEvent = (time, request, extra) => layer.addEvent({
              time,
              data: {
                  ...request,
                  ...extra,
              },
              meta: {},
          });
      }
      const isCancelled = compositionApi.ref(false);
      const cancelledMessage = compositionApi.ref();
      let abortController = undefined;
      const cancel = (message) => {
          if (!abortController) {
              /* istanbul ignore else */
              {
                  if (addTimelineEvent) {
                      addTimelineEvent(Date.now(), { message }, {
                          type: "cancel_error",
                          error: "No request has been made yet",
                      });
                  }
                  throw new Error("Cannot cancel because no request has been made");
              }
          }
          abortController.abort();
          isCancelled.value = true;
          cancelledMessage.value = message;
          if (addTimelineEvent) {
              addTimelineEvent(Date.now(), { message }, {
                  type: "cancel",
              });
          }
      };
      const use = usePromise(async (request, init) => {
          abortController = new AbortController();
          if (addTimelineEvent) {
              addTimelineEvent(Date.now(), isString(request) ? { url: request } : request, { type: "request", init });
          }
          const response = await fetch(request, {
              signal: abortController.signal,
              ...requestInit,
              ...init,
          });
          if (addTimelineEvent) {
              addTimelineEvent(Date.now(), response, {
                  type: "response",
                  init,
                  request,
              });
          }
          if (response) {
              const promises = [
                  // JSON
                  isJson
                      ? response
                          .clone()
                          .json()
                          .then((x) => (json.value = x))
                          .catch((x) => {
                          json.value = null;
                          jsonError.value = x;
                      })
                      : Promise.resolve(),
                  // BLOB
                  response
                      .clone()
                      .blob()
                      .then((x) => {
                      blob.value = x;
                  }),
                  // TEXT
                  response
                      .clone()
                      .text()
                      .then((x) => {
                      text.value = x;
                  }),
              ];
              if (parseImmediate) {
                  await Promise.all(promises);
                  if (addTimelineEvent) {
                      addTimelineEvent(Date.now(), {}, {
                          type: "parsed",
                          json: json.value,
                          blob: blob.value,
                          text: text.value,
                          request,
                      });
                  }
              }
          }
          return response;
      }, true);
      const status = compositionApi.computed(() => (use.result.value && use.result.value.status) || null);
      const statusText = compositionApi.computed(() => (use.result.value && use.result.value.statusText) || null);
      // if not options are provided in the config, execute it straight away
      // NOTE: `false` is passed to the `exec` to prevent the exception to be thrown
      if (options) {
          if (isString(options) || isString(options.url)) {
              use.exec(options, undefined, false);
          }
      }
      if (unmountCancel && compositionApi.getCurrentInstance()) {
          compositionApi.onUnmounted(() => {
              if (abortController) {
                  cancel("unmounted");
              }
          });
      }
      return {
          ...use,
          cancel,
          isCancelled,
          cancelledMessage,
          text,
          blob,
          json,
          jsonError,
          status,
          statusText,
      };
  }

  function useWebSocket(url, protocols) {
      const supported = isClient && "WebSocket" in window;
      let ws = null;
      const messageEvent = compositionApi.ref(null);
      const errorEvent = compositionApi.ref(null);
      const data = compositionApi.ref(null);
      const isOpen = compositionApi.ref(false);
      const isClosed = compositionApi.ref(false);
      const errored = compositionApi.ref(false);
      /* istanbul ignore next  */
      let lastMessage = (Date.now()) || undefined;
      let send = NO_OP;
      let close = NO_OP;
      if (supported) {
          ws = new WebSocket(url, protocols);
          ws.addEventListener("message", x => {
              messageEvent.value = x;
              data.value = x.data;
              // if the messages are to quick, we need to warn
              /* istanbul ignore else  */
              {
                  if (Date.now() - lastMessage < 2) {
                      console.warn('[useWebSocket] message rate is too high, if you are using "data" or "messageEvent"' +
                          " you might not get updated of all the messages." +
                          ' Use "ws.addEventListener("message", handler)" instead');
                  }
                  lastMessage = Date.now();
              }
          });
          ws.addEventListener("error", error => {
              errorEvent.value = error;
              errored.value = true;
          });
          ws.addEventListener("close", () => {
              isOpen.value = false;
              isClosed.value = true;
          });
          ws.addEventListener("open", () => {
              isOpen.value = true;
              isClosed.value = false;
          });
          send = (data) => ws.send(data);
          close = (code, reason) => {
              ws.close(code, reason);
          };
      }
      return {
          supported,
          ws,
          send,
          close,
          messageEvent,
          errorEvent,
          data,
          isOpen,
          isClosed,
          errored
      };
  }

  function useIntersectionObserver(refEl, refOptions) {
      const supported = isClient && "IntersectionObserver" in window;
      const wrappedElement = refEl ? wrap(refEl) : undefined;
      const element = wrappedElement && (isElement(wrappedElement.value) || !wrappedElement.value)
          ? wrappedElement
          : undefined;
      const options = compositionApi.computed(() => refOptions
          ? unwrap(refOptions)
          : !element
              ? unwrap(refEl)
              : undefined);
      const elements = compositionApi.ref([]);
      const isIntersecting = compositionApi.computed(() => elements.value.length > 0 && elements.value.every(x => x.isIntersecting));
      const handling = (entries) => {
          elements.value = entries;
      };
      let observer = compositionApi.ref();
      if (supported) {
          compositionApi.watch(options, options => {
              if (observer.value) {
                  observer.value.disconnect();
              }
              const opts = (options &&
                  options && {
                  root: unwrap(options.root),
                  rootMargin: unwrap(options.rootMargin),
                  threshold: unwrap(options.threshold)
              }) ||
                  undefined;
              observer.value = new IntersectionObserver(handling, opts);
              const targets = elements.value.map(x => x.target);
              targets.forEach(observer.value.observe);
          }, { deep: true, immediate: true });
      }
      const observe = supported
          ? (element) => {
              const e = unwrap(element);
              observer.value.observe(e);
          }
          : NO_OP;
      const unobserve = supported
          ? (element) => {
              const e = unwrap(element);
              observer.value.unobserve(e);
          }
          : NO_OP;
      const disconnect = () => observer.value.disconnect();
      // if the element is passed we should add hooks
      if (element) {
          // if value is defined it is already being observed
          // if (!element.value) {
          compositionApi.onMounted(() => {
              if (element.value) {
                  observe(element);
              }
          });
          // }
          compositionApi.onUnmounted(() => {
              disconnect();
          });
      }
      // // debug is still work in progress, would be nice to provide some
      // // information about the target
      // /* istanbul ignore next */
      // const debug = () => {
      //   if (elements.value.length === 0) {
      //     true && console.warn('[IntersectionObserver] no elements provided, did you mount the component?')
      //     return;
      //   }
      //   // TODO: add border to the elements
      // };
      return {
          supported,
          elements,
          observe,
          unobserve,
          disconnect,
          isIntersecting
      };
  }

  function useNetworkInformation() {
      const connection = isClient
          ? navigator.connection ||
              navigator.mozConnection ||
              navigator.webkitConnection
          : false;
      const supported = !!connection;
      const downlink = compositionApi.ref(0);
      const downlinkMax = compositionApi.ref(0);
      const effectiveType = compositionApi.ref("none");
      const rtt = compositionApi.ref(0);
      const saveData = compositionApi.ref(false);
      const type = compositionApi.ref("none");
      let handler = NO_OP;
      let remove = NO_OP;
      /* istanbul ignore else  */
      if (connection) {
          handler = () => {
              downlink.value = connection.downlink;
              downlinkMax.value = connection.downlinkMax;
              effectiveType.value = connection.effectiveType;
              rtt.value = connection.rtt;
              saveData.value = connection.saveData;
              type.value = connection.type;
          };
          remove = useEvent(connection, "change", handler, PASSIVE_EV);
          handler();
      }
      else {
          /* istanbul ignore else */
          {
              console.warn("[navigator.connection] not found, networkInformation not available.");
          }
      }
      return {
          supported,
          downlink,
          downlinkMax,
          effectiveType,
          rtt,
          saveData,
          type,
          remove
      };
  }

  let online = undefined;
  function useOnline() {
      const supported = isClient && "onLine" in navigator;
      // not sure how to test this :/
      if (!supported) {
          online = compositionApi.ref(false);
      }
      if (!online) {
          online = compositionApi.ref(navigator.onLine);
          window.addEventListener("offline", () => (online.value = false), PASSIVE_EV);
          window.addEventListener("online", () => (online.value = true), PASSIVE_EV);
      }
      return {
          supported,
          online
      };
  }

  let visibility = undefined;
  let hidden = undefined;
  function usePageVisibility() {
      if (!hidden) {
          hidden = compositionApi.ref(isClient && document.hidden);
      }
      if (!visibility) {
          if (isClient) {
              visibility = compositionApi.ref(document.visibilityState);
              document.addEventListener("visibilitychange", () => {
                  visibility.value = document.visibilityState;
                  hidden.value = document.hidden;
              }, PASSIVE_EV);
          }
          else {
              visibility = compositionApi.ref("visible");
          }
      }
      return {
          visibility,
          hidden
      };
  }

  let language = undefined;
  let languages = undefined;
  function useLanguage() {
      if (!language) {
          language = isClient ? compositionApi.ref(navigator.language) : compositionApi.ref("");
      }
      if (!languages) {
          if (isClient) {
              languages = compositionApi.ref(navigator.languages);
              const change = () => {
                  language.value = navigator.language;
                  languages.value = navigator.languages;
              };
              window.addEventListener("languagechange", change, PASSIVE_EV);
          }
          else {
              languages = compositionApi.ref([]);
          }
      }
      return {
          language,
          languages
      };
  }

  function useBroadcastChannel(name, onBeforeClose) {
      const supported = isClient && "BroadcastChannel" in self;
      const data = compositionApi.ref(null);
      const messageEvent = compositionApi.ref(null);
      const errorEvent = compositionApi.ref(null);
      const errored = compositionApi.ref(false);
      const isClosed = compositionApi.ref(false);
      let send = NO_OP;
      let close = NO_OP;
      let addListener = NO_OP;
      /* istanbul ignore else  */
      if (supported) {
          const bc = new BroadcastChannel(name);
          bc.addEventListener("messageerror", e => {
              errorEvent.value = e;
              errored.value = true;
          }, PASSIVE_EV);
          bc.addEventListener("message", ev => {
              messageEvent.value = ev;
              data.value = ev.data;
          }, PASSIVE_EV);
          send = d => bc.postMessage(d);
          close = () => {
              bc.close();
              isClosed.value = true;
          };
          addListener = (cb, o) => {
              bc.addEventListener("message", cb, o);
              compositionApi.onUnmounted(() => bc.removeEventListener("message", cb));
          };
          compositionApi.onUnmounted(() => {
              onBeforeClose && onBeforeClose();
              close();
          });
      }
      else {
          {
              console.warn("[BroadcastChannel] is not supported");
          }
      }
      return {
          supported,
          data,
          messageEvent,
          errorEvent,
          errored,
          isClosed,
          send,
          close,
          addListener
      };
  }

  function useGeolocation(options) {
      const supported = isClient && !!navigator.geolocation;
      // used to check if the execution is lazy
      const lazy = compositionApi.ref(options ? options.immediate === false : undefined);
      const error = compositionApi.ref(null);
      const timestamp = compositionApi.ref(null);
      const coords = compositionApi.ref(null);
      const highAccuracy = compositionApi.ref((options && options.enableHighAccuracy) || null);
      // allow manual control on when the geolocation is requested
      let refresh = NO_OP;
      if (supported) {
          const setPosition = (pos) => {
              timestamp.value = pos.timestamp;
              coords.value = pos.coords;
              error.value = null;
          };
          const setError = (err) => {
              timestamp.value = Date.now();
              coords.value = null;
              error.value = err;
          };
          const clearWatch = () => lazy.value !== true &&
              watchId &&
              navigator.geolocation.clearWatch(watchId);
          let _currentPositionRefresh = () => navigator.geolocation.getCurrentPosition(setPosition, setError, options);
          if (lazy.value) {
              refresh = () => {
                  if (lazy.value) {
                      lazy.value = false;
                  }
                  else {
                      _currentPositionRefresh();
                  }
              };
          }
          else {
              // NOTE probably useless??
              refresh = _currentPositionRefresh;
          }
          let watchId = 0;
          compositionApi.onMounted(() => compositionApi.watch([highAccuracy, lazy], (a) => {
              clearWatch();
              const enableHighAccuracy = isBoolean(a[0])
                  ? a[0]
                  : options
                      ? options.enableHighAccuracy
                      : undefined;
              watchId = navigator.geolocation.watchPosition(setPosition, setError, options
                  ? { ...options, enableHighAccuracy }
                  : { enableHighAccuracy });
          }, {
              immediate: !lazy.value,
          }));
          compositionApi.onUnmounted(clearWatch);
      }
      return {
          supported,
          refresh,
          error,
          timestamp,
          coords,
          highAccuracy,
      };
  }

  /**
   * Gets the current value of the given CSS variable name for the given element.
   *
   * @param element The element to get the variable for.
   * @param name The CSS variable name.
   */
  function getCssVariableFor(element, name) {
      const result = getComputedStyle(element).getPropertyValue(name);
      return result ? result.trim() : null;
  }
  /**
   * Sets the value of the given CSS variable for the given element.
   *
   * @param element The element to set the variable for.
   * @param name The CSS variable name without dashes.
   * @param value The CSS variable value.
   */
  function setCssVariableFor(element, name, value) {
      element.style.setProperty(name, value);
  }
  const defaultOptions = {
      attributes: true,
      childList: true,
      subtree: true
  };
  const sanitizeCssVarName = (name) => {
      if (name.length <= 2 || name[0] !== "-" || name[1] !== "-") {
          return `--${name}`;
      }
      return name;
  };
  function useCssVariables(variables, elementOrOptions, optionsConfig) {
      const supported = isClient && "MutationObserver" in self;
      const [element, options] = compositionApi.isRef(elementOrOptions) || isElement(elementOrOptions)
          ? [elementOrOptions, optionsConfig || defaultOptions]
          : [
              (supported && document.documentElement) || {},
              elementOrOptions || defaultOptions
          ];
      // Reactive property to tell if the observer is listening
      const observing = compositionApi.ref(true);
      // Stores the results by reference.
      const result = {};
      // If the element is ref, we should only update the variable on mount
      const updateValues = [];
      // extract name
      const defEntries = Object.entries(variables).map((x) => {
          const [name, value] = isString(x[1]) ? [x[1]] : [x[1].name, x[1].value];
          if (value) {
              updateValues.push(() => setCssVariableFor(unwrap(element), name, unwrap(value)));
              // if is ref, use provided ref instead
              result[x[0]] = wrap(value);
          }
          return [x[0], sanitizeCssVarName(name)];
      });
      for (let i = 0; i < defEntries.length; i++) {
          const [key, name] = defEntries[i];
          if (!result[key]) {
              // if is ref set null, onMount we will update
              result[key] = compositionApi.ref((compositionApi.isRef(element) && !element.value) || !supported
                  ? null
                  : getCssVariableFor(unwrap(element), name));
          }
          if (supported) {
              // keep track of changes
              compositionApi.watch([result[key], wrap(element)], (val) => {
                  if (!observing)
                      return;
                  // don't force if the current value is the same as the given one
                  // or if the given one is empty
                  if (val[1] && val[0] !== getCssVariableFor(val[1], name)) {
                      setCssVariableFor(val[1], name, val[0]);
                  }
              }, { immediate: !compositionApi.isRef(element) });
          }
      }
      if (!supported) {
          return {
              ...result,
              stop: NO_OP,
              resume: NO_OP,
              supported,
              observing
          };
      }
      const update = () => {
          // Each time an observation has been made,
          // we look up for each CSS variable and update their values.
          for (let i = 0; i < defEntries.length; i++) {
              const [key, value] = defEntries[i];
              result[key].value = getCssVariableFor(unwrap(element), value);
          }
      };
      // Sets up the observer.
      const observer = new MutationObserver(update);
      // Sets the `stop` method.
      const stop = () => {
          observer.disconnect();
          observing.value = false;
      };
      // Sets the `start` method.
      const resume = () => {
          // if it was stopped we will update the variables to the current value
          if (!observing.value) {
              update();
          }
          observer.observe(unwrap(element), options);
          observing.value = true;
      };
      // Stops on destroy
      compositionApi.onUnmounted(stop);
      if (compositionApi.isRef(element)) {
          compositionApi.onMounted(() => {
              updateValues.forEach(x => x());
              compositionApi.watch(element, (n, o) => {
                  if (o) {
                      stop();
                  }
                  if (n) {
                      resume();
                  }
              });
          });
      }
      else if (isClient || element) {
          updateValues.forEach(x => x());
          // Starts observe
          resume();
      }
      return {
          ...result,
          supported,
          resume,
          stop,
          observing
      };
  }

  // from https://github.com/dai-shi/react-hooks-worker/blob/1e842ad15c558fc04dd7339a62aaa43f46d1c7cd/src/exposeWorker.js
  // export function exposeWorker(func: (...args: any[]) => any): void;
  function exposeWorker(func) {
      this.onmessage = async (e) => {
          const r = func(e.data);
          if (r === undefined) {
              // istanbul ignore else
              {
                  console.warn(`[exposeWorker] returned \`${r}\`, this might cause unexpected behaviour`);
              }
              this.postMessage(r);
          }
          else if (r === null) {
              this.postMessage(r);
          }
          else if (isArray(r)) {
              this.postMessage(r);
          }
          else if (r[Symbol.asyncIterator]) {
              for await (const i of r)
                  this.postMessage(i);
          }
          else if (r[Symbol.iterator]) {
              for (const i of r)
                  this.postMessage(i);
          }
          else {
              this.postMessage(await r);
          }
      };
  }
  function useWorker(stringUrl, args, options) {
      const supported = isClient && "Worker" in self;
      const errorEvent = compositionApi.ref();
      const data = compositionApi.ref();
      const terminated = compositionApi.ref(!supported);
      const errored = compositionApi.ref(!supported);
      if (!supported) {
          terminated.value = true;
          return {
              worker: undefined,
              data,
              postMessage: NO_OP,
              terminate: NO_OP,
              errorEvent,
              errored,
              terminated
          };
      }
      const worker = new Worker(stringUrl, options);
      /* istanbul ignore next  */
      let lastMessage = (Date.now() - 20) || undefined;
      const postMessage = data => worker.postMessage(data);
      function terminate() {
          worker.terminate();
          terminated.value = true;
      }
      worker.addEventListener("message", x => {
          data.value = x.data;
          // if the messages are to quick, we need to warn
          /* istanbul ignore else  */
          {
              if (Date.now() - lastMessage < 2) {
                  console.warn("[useWorker] message rate is too high, you might not get updated of all the messages.");
              }
              lastMessage = Date.now();
          }
      }, PASSIVE_EV);
      worker.addEventListener("error", error => {
          errorEvent.value = error;
          errored.value = true;
      }, PASSIVE_EV);
      compositionApi.onUnmounted(terminate);
      if (args) {
          postMessage(args);
      }
      return {
          worker,
          data,
          postMessage,
          terminate,
          errorEvent,
          errored,
          terminated
      };
  }

  /**
   * Invokes the native sharing mechanism of the device
   * [compatibility](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share)
   * @param data - if provided it will automatically try to share it
   */
  function useShare(data) {
      const supported = isClient && "share" in navigator;
      let share = () => Promise.resolve(false);
      let canShare = FALSE_OP;
      let shared = compositionApi.ref(false);
      let cancelled = compositionApi.ref(false);
      if (supported) {
          share = data => {
              shared.value = false;
              cancelled.value = false;
              return navigator
                  .share(data)
                  .then(x => {
                  shared.value = true;
                  return x;
              })
                  .catch(e => {
                  shared.value = false;
                  cancelled.value = true;
                  return false;
              });
          };
          canShare = data => navigator.canShare(data);
          if (data) {
              if (canShare(data)) {
                  share(data);
              }
          }
      }
      return {
          supported,
          share,
          canShare,
          shared,
          cancelled
      };
  }

  function useClipboard() {
      const supported = isClient && "clipboard" in navigator;
      const text = compositionApi.ref();
      const data = compositionApi.ref();
      const writeText = (data) => {
          text.value = data;
          if (!supported)
              return Promise.resolve();
          // TOOD check for permissions
          return navigator.clipboard.writeText(data);
      };
      const write = (data) => {
          if (!supported)
              return Promise.resolve();
          // TOOD check for permissions
          // @ts-ignore
          return navigator.clipboard.write(data);
      };
      let readText = () => Promise.resolve(undefined);
      // @ts-ignore
      let read = readText;
      if (supported) {
          let updating = false;
          const update = () => readText().then((x) => (text.value = x));
          ["copy", "cut", "focus"].map((event) => useEvent(window, event, () => update()));
          readText = () => navigator.clipboard.readText().then((x) => {
              try {
                  updating = true;
                  return (text.value = x);
              }
              finally {
                  // case of a sync watch it might throw
                  updating = false;
              }
          });
          // @ts-ignore this should work
          read = () => navigator.clipboard.read().then((x) => (data.value = x));
          compositionApi.watch(text, debounce((s) => {
              if (updating || !isString(s))
                  return;
              writeText(s);
          }, 100));
      }
      return {
          supported,
          text,
          data,
          writeText,
          readText,
          write,
          read,
      };
  }

  /**
   * @param fn setTimeout callback
   * @param delay If this parameter is omitted, a value of 0 is used
   * (https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)
   */
  function useTimeout(fn, delay = 0) {
      let ready = compositionApi.ref(false);
      const timeoutId = setTimeout(() => {
          ready.value = true;
          fn();
      }, delay);
      const cancel = () => {
          ready.value = null;
          clearTimeout(timeoutId);
      };
      compositionApi.onUnmounted(cancel);
      return {
          ready,
          cancel,
      };
  }

  const inlineWorkExecution = (f) => function (e) {
      const args = e.data || [];
      return new Promise((res) => {
          try {
              Promise.resolve(f.apply(f, args))
                  // @ts-ignore
                  .then((x) => res(postMessage([true, x])))
                  // @ts-ignore
                  .catch((x) => res(postMessage([false, x])));
          }
          catch (e) {
              // @ts-ignore
              res(postMessage([false, e]));
          }
      });
  };
  function createBlobUrl(fn, dependencies) {
      const scripts = dependencies.length > 0
          ? `importScripts("${dependencies.join('","')}");`
          : "";
      const blobScript = [
          scripts,
          "onmessage=",
          `(${inlineWorkExecution.toString()})(${fn.toString()})`,
      ];
      const blob = new Blob(blobScript, { type: "text/javascript" });
      return URL.createObjectURL(blob);
  }
  function useWorkerFunction(fn, options) {
      const supported = isClient && "Worker" in self;
      // reactive
      const dependencies = compositionApi.computed(() => (options && unwrap(options.dependencies)) || []);
      const timeoutRef = compositionApi.computed(() => options && unwrap(options.timeout));
      if (!supported) {
          return useCancellablePromise(fn, { lazy: true, throwException: true });
      }
      const promise = useCancellablePromise((...args) => new Promise((res, rej) => {
          const blobUrl = createBlobUrl(fn, dependencies.value);
          const worker = new Worker(blobUrl);
          let timeoutId = -1;
          const timeout = timeoutRef.value;
          const terminate = () => {
              worker.terminate();
              URL.revokeObjectURL(blobUrl);
              clearTimeout(timeoutId);
              removeWatch();
          };
          // if the last argument is ref(false) we should also track it
          const watchCancel = args.length === fn.length + 1 &&
              compositionApi.isRef(args[args.length - 1]) &&
              args[args.length - 1].value === false
              ? compositionApi.computed(() => promise.cancelled.value || args[args.length - 1].value)
              : promise.cancelled;
          const removeWatch = watchCancel
              ? compositionApi.watch(watchCancel, () => {
                  terminate();
                  res(undefined);
              }, { immediate: false })
              : NO_OP;
          worker.addEventListener("message", (e) => {
              if (e.data[0]) {
                  res(e.data[1]);
              }
              else {
                  rej(e.data[1]);
              }
              terminate();
          }, PASSIVE_EV);
          worker.addEventListener("error", (e) => {
              terminate();
              rej(e);
          }, PASSIVE_EV);
          worker.postMessage([...args]);
          if (timeout) {
              timeoutId = setTimeout(() => {
                  promise.cancel(`[WebWorker] timeout after ${timeout}ms`);
              }, timeout);
          }
      }), {
          lazy: true,
          throwException: true,
      });
      return promise;
  }

  function useMatchMedia(query) {
      const supported = isClient ? "matchMedia" in window : false;
      let mediaQueryList = undefined;
      let matches = undefined;
      let remove = NO_OP;
      if (supported) {
          mediaQueryList = compositionApi.ref(matchMedia(query));
          matches = compositionApi.ref(mediaQueryList.value.matches);
          const process = (e) => {
              matches.value = e.matches;
          };
          mediaQueryList.value.addEventListener("change", process, PASSIVE_EV);
          const remove = () => mediaQueryList.value.removeEventListener("change", process);
          compositionApi.onUnmounted(remove);
      }
      else {
          /* istanbul ignore else */
          {
              console.warn("[matchMedia] not supported");
          }
          mediaQueryList = compositionApi.ref({});
          matches = compositionApi.ref(false);
      }
      return {
          supported,
          mediaQueryList,
          matches,
          remove
      };
  }

  function useSharedRef(name, defaultValue) {
      const { addListener, send, close, supported } = useBroadcastChannel(name, () => disconnect());
      const id = Date.now();
      const master = compositionApi.ref(false);
      const mind = compositionApi.ref(0 /* HIVE */);
      const editable = compositionApi.computed(() => mind.value === 1 /* MASTER */ ? master.value : true);
      // who's listening to this broadcast
      const targets = compositionApi.ref([]);
      const data = compositionApi.ref(defaultValue);
      // if the state was updated by an event it sets to true
      let updateState = false;
      let masterId = undefined;
      send({ type: 0 /* INIT */ });
      const ping = () => send({ type: 5 /* PING */, id });
      const disconnect = () => {
          if (targets.value.length === 0)
              return;
          if (master.value) {
              send({
                  type: 3 /* SET_MIND */,
                  mind: 1 /* MASTER */,
                  id: Math.min(...targets.value),
              });
          }
          send({
              type: 4 /* LEAVE */,
              id,
          });
      };
      const setMind = (t) => {
          switch (t) {
              case 1 /* MASTER */: {
                  master.value = true;
                  break;
              }
              case 0 /* HIVE */: {
                  master.value = false;
                  break;
              }
          }
          mind.value = t;
          send({
              type: 3 /* SET_MIND */,
              id: id,
              mind: mind.value,
          });
      };
      addListener((e) => {
          switch (e.data.type) {
              case 0 /* INIT */: {
                  send({
                      type: 2 /* UPDATE */,
                      value: data.value,
                      mind: mind.value,
                  });
                  break;
              }
              case 4 /* LEAVE */: {
                  const index = targets.value.indexOf(e.data.id);
                  if (index >= 0) {
                      targets.value.splice(index, 1);
                  }
                  // if master disconnects
                  if (masterId === e.data.id && targets.value.length > 0) {
                      send({
                          type: 3 /* SET_MIND */,
                          mind: 1 /* MASTER */,
                          id: Math.min(id, ...targets.value),
                      });
                  }
                  break;
              }
              case 2 /* UPDATE */: {
                  updateState = true;
                  data.value = e.data.value;
                  mind.value = e.data.mind;
                  break;
              }
              case 3 /* SET_MIND */: {
                  mind.value = e.data.mind;
                  masterId =
                      (e.data.mind === 1 /* MASTER */ && e.data.id) || undefined;
                  master.value = masterId === id;
                  if (master.value) {
                      targets.value = [];
                      ping();
                  }
                  break;
              }
              case 5 /* PING */: {
                  targets.value = [e.data.id];
                  send({
                      type: 6 /* PONG */,
                      id,
                  });
                  break;
              }
              case 6 /* PONG */: {
                  targets.value.push(e.data.id);
                  break;
              }
          }
      }, PASSIVE_EV);
      ping();
      compositionApi.watch(data, (v, o) => {
          if (updateState) {
              updateState = false;
              return;
          }
          // mind is set to MASTER and we are not master, we shouldn't update!
          if (mind.value === 1 /* MASTER */ && master.value === false) {
              updateState = true;
              data.value = o;
              return;
          }
          send({
              type: 2 /* UPDATE */,
              mind: mind.value,
              value: isObject(v) ? { ...v } : v,
          });
          updateState = false;
      }, { deep: true, immediate: false });
      if (isClient) {
          window.addEventListener("unload", disconnect, PASSIVE_EV);
      }
      compositionApi.onUnmounted(() => {
          disconnect();
          close();
      });
      return {
          supported,
          id,
          data,
          master,
          mind,
          editable,
          targets,
          ping,
          setMind,
          addListener: addListener,
      };
  }
  let shared = undefined;
  function refShared(defaultValue, id) {
      const vm = compositionApi.getCurrentInstance();
      const name = id
          ? id
          : vm.$vnode && vm.$vnode.tag
              ; // TODO test this :/ NOTE @vue/runtime-core might be different
      if (!name) {
          {
              console.warn("[refShared] please assign an id, returning `ref`");
          }
          return compositionApi.ref(defaultValue);
      }
      /* istanbul ignore else  */
      {
          if (!shared) {
              shared = new Set();
          }
          if (shared.has(name)) {
              console.warn("[refShared] You can only have one refShared per component, if you need more please assign pass an id refShared(defaultValue, id)");
          }
          shared.add(name);
      }
      const { data, supported } = useSharedRef(name, defaultValue);
      /* istanbul ignore next  */
      {
          if (!supported) {
              console.warn("[refShared] is dependent of BroadcastChannel");
          }
      }
      return data;
  }

  const SCROLL_LOCK_CLASS = "no-scroll";
  function useLockScroll(selectorElements, classOptions) {
      const elements = (isString(selectorElements)
          ? compositionApi.ref([]) // it will be resolved when mounted
          : isArray(compositionApi.unref(selectorElements))
              ? wrap(selectorElements)
              : wrap([selectorElements]));
      const options = isString(classOptions)
          ? { lockedClass: classOptions, auto: true }
          : classOptions || { auto: true };
      if (!options.lockedClass) {
          options.lockedClass = SCROLL_LOCK_CLASS;
      }
      const locked = compositionApi.ref(false);
      // NOTE issues on Vue3 because of the `watch.deep`, we wrap all elements
      const tracked = compositionApi.computed(() => elements.value.map(x => compositionApi.ref(x)));
      const remove = compositionApi.watch([locked, tracked], ([l, els], [oldLocked, oldElements]) => {
          for (const refEl of els) {
              const el = unwrap(refEl);
              // istanbul ignore else
              if (options.lockedClass) {
                  // istanbul ignore else
                  if (!el) {
                      // istanbul ignore else
                      {
                          console.warn("[useLockScroll] element is undefined");
                      }
                      return;
                  }
                  el.classList.toggle(options.lockedClass, l);
              }
              if (options.onChange) {
                  if (oldLocked !== l || !oldElements.find(x => unwrap(x) === el))
                      options.onChange(el, l);
              }
          }
      }, { flush: "sync", deep: false });
      const lock = () => (locked.value = true);
      const unlock = () => (locked.value = false);
      if (isString(selectorElements)) {
          compositionApi.onMounted(() => (elements.value = Array.from(document.querySelectorAll(selectorElements))));
      }
      if (options.auto !== false) {
          compositionApi.onMounted(lock);
          compositionApi.onActivated(lock);
          compositionApi.onDeactivated(unlock);
          compositionApi.onBeforeUnmount(unlock);
      }
      return {
          locked,
          lock,
          unlock,
          remove
      };
  }

  function useVModel(props, name) {
      /* istanbul ignore if */
      {
          console.warn("[useVModel] is not supported on @vue/composition-api.");
          return undefined;
      }
  }

  function injectFactory(key, defaultValueFactory) {
      return compositionApi.inject(key, defaultValueFactory, true);
  }

  function useInterval(callback, ms, ...args) {
      let intervalId = undefined;
      const start = (_ms, ..._args) => {
          remove();
          if (!_ms && !ms) {
              return;
          }
          const m = (_ms || ms);
          return (intervalId = setInterval(callback, m, ...(_args && _args.length ? _args : args)));
      };
      const remove = () => {
          if (!intervalId)
              return;
          clearInterval(intervalId);
          intervalId = undefined;
      };
      if (isNumber(ms)) {
          start();
      }
      compositionApi.onUnmounted(remove);
      return { remove, start };
  }
  // TODO move this:  type checkings
  // useInterval((x: number) => {}).start();
  // useInterval((x: number) => {}, 100, 1).start();
  // useInterval(() => {}).start();

  function refDebounced(value, delay) {
      let [v, d] = arguments.length === 1 && isNumber(value) && typeof delay === "undefined"
          ? [compositionApi.ref(), value]
          : [compositionApi.ref(value), delay];
      return compositionApi.customRef((track, trigger) => ({
          get() {
              track();
              return v.value;
          },
          set: debounce(val => {
              v.value = val;
              trigger();
          }, d)
      }));
  }

  function intlDateFormatExtractArguments(localesOptions, opts) {
      const wrappedOpts = wrap(opts);
      const wrappedLocalesOptions = wrap(localesOptions);
      return isObject(wrappedOpts.value) || compositionApi.isRef(opts)
          ? [
              wrappedLocalesOptions.value !== undefined
                  ? wrappedLocalesOptions
                  : undefined,
              wrappedOpts,
          ]
          : isObject(wrappedLocalesOptions.value) &&
              !isArray(wrappedLocalesOptions.value) &&
              !isString(wrappedLocalesOptions.value)
              ? [undefined, wrappedLocalesOptions]
              : [
                  wrappedLocalesOptions.value
                      ? wrappedLocalesOptions
                      : undefined,
                  undefined,
              ];
  }

  function useIntlDateTimeFormat(localesOptions, opts) {
      const [locales, options] = intlDateFormatExtractArguments(localesOptions, opts);
      const formatter = compositionApi.computed(() => new Intl.DateTimeFormat(unwrap(locales), unwrap(options)));
      const formatString = (value, overrideOpts, overrideLocale) => {
          const f = overrideOpts || overrideLocale
              ? new Intl.DateTimeFormat(unwrap(overrideLocale) ||
                  unwrap(locales), { ...unwrap(options), ...unwrap(overrideOpts) })
              : formatter.value;
          const v = unwrap(value);
          return f.format(isString(v) ? new Date(v) : v);
      };
      const format = (value, overrideOpts, overrideLocale) => compositionApi.computed(() => formatString(value, overrideOpts, overrideLocale));
      return {
          format,
          formatString,
          formatter,
      };
  }

  function useIntlNumberFormat(localesOptions, opts) {
      const [locales, options] = intlDateFormatExtractArguments(localesOptions, opts);
      const formatter = compositionApi.computed(() => new Intl.NumberFormat(unwrap(locales), unwrap(options)));
      const formatString = (value, overrideOpts, overrideLocale) => {
          const f = overrideOpts || overrideLocale
              ? new Intl.NumberFormat(unwrap(overrideLocale) ||
                  unwrap(locales), { ...unwrap(options), ...unwrap(overrideOpts) })
              : formatter.value;
          return f.format(unwrap(value));
      };
      const format = (value, overrideOpts, overrideLocale) => compositionApi.computed(() => formatString(value, overrideOpts, overrideLocale));
      return {
          format,
          formatString,
          formatter
      };
  }

  function useCurrencyFormat(currencyCodeOptions, localesOptions, opts) {
      const unwrapCodeOptions = unwrap(currencyCodeOptions);
      const hasCurrency = !isObject(unwrapCodeOptions);
      const currencyCode = hasCurrency
          ? currencyCodeOptions
          : compositionApi.computed(() => {
              const o = unwrap(currencyCodeOptions);
              return o.currency;
          });
      const [locales, argOptions] = intlDateFormatExtractArguments(localesOptions, hasCurrency
          ? opts
          : currencyCodeOptions);
      const options = compositionApi.computed(() => {
          const opts = unwrap(argOptions) || {};
          const currency = unwrap(currencyCode) || opts.currency;
          return {
              style: "currency",
              ...opts,
              currency
          };
      });
      const numberFormat = useIntlNumberFormat(locales);
      const formatString = (amount, currency, display, opts, overrideLocale) => {
          const o = { ...options.value, ...unwrap(opts) };
          const c = unwrap(currency) || o.currency;
          const d = unwrap(display) || o.currencyDisplay;
          // istanbul ignore else
          {
              if (!c) {
                  console.error("[useCurrencyFormat] No currency provided.");
                  return "";
              }
              if (o.style !== "currency") {
                  console.warn("[useCurrencyFormat] invalid style passed in options, please leave it undefined.");
              }
          }
          return numberFormat.formatString(amount, {
              ...o,
              currency: c,
              currencyDisplay: d
          }, overrideLocale);
      };
      const format = (amount, currency, display, opts, overrideLocale) => {
          return compositionApi.computed(() => formatString(amount, currency, display, opts, overrideLocale));
      };
      return {
          format,
          formatString
      };
  }

  function getBreakpointWidth(bp) {
      if (!bp)
          return undefined;
      if (isNumber(bp))
          return bp;
      return isValidWidthBreakpoint(bp);
  }
  const isValidWidthBreakpoint = (bp) => {
      const m = bp.match(/^(\d+)px$/);
      if (m) {
          return +m[1];
      }
      return undefined;
  };
  function useBreakpoint(breakpoints) {
      const result = {};
      const map = new Map();
      const current = compositionApi.ref();
      let sorted = [];
      const removeMedia = [];
      for (const key in breakpoints) {
          const bp = breakpoints[key];
          const width = getBreakpointWidth(bp);
          if (width !== undefined) {
              const r = compositionApi.ref(false);
              result[key] = r;
              map.set(width, {
                  name: key,
                  valid: r,
              });
              sorted.push(width);
          }
          else {
              const { matches, remove } = useMatchMedia(bp);
              result[key] = matches;
              removeMedia.push(remove);
          }
      }
      sorted = sorted.sort((a, b) => b - a);
      const resize = isClient
          ? () => {
              const width = window.innerWidth;
              let c = undefined;
              for (let i = 0; i < sorted.length; i++) {
                  const bp = sorted[i];
                  const r = map.get(bp);
                  r.valid.value = width >= bp;
                  if (width >= bp && c === undefined) {
                      c = r.name;
                  }
              }
              current.value = c;
          }
          : NO_OP;
      const processResize = useDebounce(resize, 10);
      const remove = isClient
          ? () => window.removeEventListener("resize", processResize)
          : NO_OP;
      if (isClient) {
          compositionApi.onMounted(() => {
              resize();
              window.addEventListener("resize", processResize, PASSIVE_EV);
          });
          compositionApi.onUnmounted(() => {
              remove();
              removeMedia.forEach((x) => x());
          });
      }
      return {
          ...result,
          remove,
          current,
      };
  }

  function useBreakpointChrome() {
      return useBreakpoint({
          mobileS: 320,
          mobileM: 375,
          mobileL: 425,
          tablet: 768,
          laptop: 1024,
          laptopL: 1440,
          desktop4K: 2560
      });
  }

  // istanbul ignore next
  const BREAKPOINT_TAILWIND_KEY = Symbol(("TAILWIND_BREAKPOINTS") );
  const defaultTailwindBreakpoint = {
      sm: 640,
      md: 768,
      lg: 1024,
      xl: 1280,
  };
  function isTailwind(t) {
      return isObject(t) && isObject(t.theme) && isObject(t.theme.screens);
  }
  function isRawScreen(t) {
      return isObject(t) && isString(t.raw);
  }
  function isRangeScreen(t) {
      if (!isObject(t))
          return false;
      return (isString(t.min) || isString(t.max) || isNumber(t.min) || isNumber(t.max));
  }
  /**
   * Sanitize width value, if number is passed it will append `px`
   * @param s width value
   */
  function sanitizeWidth(s) {
      return isNumber(s) ? s + "px" : s;
  }
  function screenRangeToBreakpoint(s) {
      if (!isRangeScreen(s)) {
          // istanbul ignore else
          {
              console.warn("[useBreakpointTailwind] screen range provided is not valid");
          }
          return "";
      }
      const condition = [
          s.max && `max-width: ${sanitizeWidth(s.max)}`,
          s.min && `min-width: ${sanitizeWidth(s.min)}`,
      ]
          .filter(Boolean)
          .join(" and ");
      return `(${condition})`;
  }
  function screenToBreakpoint(s) {
      const conditions = [];
      if (isArray(s)) {
          const bks = s.map(screenToBreakpoint);
          for (let i = 0; i < bks.length; i++) {
              const b = bks[i];
              conditions.push(...b);
          }
      }
      else if (isRawScreen(s)) {
          conditions.push(s.raw);
      }
      else if (isRangeScreen(s)) {
          conditions.push(screenRangeToBreakpoint(s));
      }
      else if (isString(s) || isNumber(s)) {
          conditions.push(`(min-width: ${sanitizeWidth(s)})`);
      }
      else {
          // istanbul ignore else
          {
              console.warn("[useBreakpointTailwind] unknown type used for the breakpoint`");
          }
      }
      return conditions;
  }
  function setBreakpointTailwindCSS(breakpoints) {
      const bk = isTailwind(breakpoints) ? breakpoints.theme.screens : breakpoints;
      if (isTailwind(breakpoints)) {
          for (const k in bk) {
              // istanbul ignore else
              if (bk.hasOwnProperty(k)) {
                  const v = bk[k];
                  if (isObject(v)) {
                      bk[k] = screenToBreakpoint(bk[k]).join(" or ");
                  }
                  else if (isString(v)) {
                      if (!v.endsWith("px")) {
                          bk[k] = screenToBreakpoint(bk[k]).join(" or ");
                      }
                  }
              }
          }
      }
      const bp = useBreakpoint(bk);
      compositionApi.provide(BREAKPOINT_TAILWIND_KEY, bp);
      return bp;
  }
  function useBreakpointTailwindCSS(config) {
      return injectFactory(BREAKPOINT_TAILWIND_KEY, () => setBreakpointTailwindCSS(config || defaultTailwindBreakpoint));
  }

  const STORAGE_TEST_KEY = "__storage_test__" ;
  /* istanbul ignore next */
  function isQuotaExceededError(e, storage) {
      return (e instanceof DOMException &&
          // everything except Firefox
          (e.code === 22 ||
              // Firefox
              e.code === 1014 ||
              // test name field too, because code might not be present
              // everything except Firefox
              e.name === "QuotaExceededError" ||
              // Firefox
              e.name === "NS_ERROR_DOM_QUOTA_REACHED") &&
          // acknowledge QuotaExceededError only if there's something already stored
          ((storage && storage.length !== 0) || false));
  }
  // based on https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
  function storageAvailable(storage) {
      try {
          if (!storage) {
              return false;
          }
          const x = STORAGE_TEST_KEY;
          storage.setItem(x, x);
          storage.removeItem(x);
          return true;
      }
      catch (e) {
          return isQuotaExceededError(e, storage);
      }
  }
  function safeParse(serializer, value) {
      try {
          return serializer.parse(value);
      }
      catch {
          return value;
      }
  }
  let storageMap = undefined;
  function useWebStorage(type, serializer = JSON, ms = 10) {
      const storage = isClient ? window[type] : undefined;
      const supported = storageAvailable(storage);
      const remove = () => storageMap.delete(type);
      if (!storageMap) {
          storageMap = new Map();
          if (isClient) {
              window.addEventListener("storage", (e) => {
                  if (e.newValue === e.oldValue) {
                      return;
                  }
                  let webStore = storageMap.get("localStorage");
                  if (e.storageArea === window.localStorage) {
                      webStore = storageMap.get("localStorage");
                  }
                  else {
                      webStore = storageMap.get("sessionStorage");
                  }
                  if (webStore && Object.keys(webStore.$syncKeys).length > 0) {
                      if (e.key === null) {
                          webStore.clear();
                      }
                      else if (webStore.$syncKeys[e.key]) {
                          if (e.newValue === null) {
                              webStore.removeItem(e.key);
                          }
                          else {
                              webStore.updateItem(e.key, e.newValue);
                          }
                      }
                  }
              });
          }
      }
      let store = storageMap.get(type);
      let quotaError;
      if (supported && storage) {
          if (!store) {
              quotaError = compositionApi.ref(false);
              store = {
                  $refMap: new Map(),
                  $watchHandlers: new Map(),
                  $syncKeys: {},
                  $quotaError: quotaError,
                  key: storage.key,
                  length: storage.length,
                  setSync(key, sync) {
                      if (sync) {
                          this.$syncKeys[key] = true;
                      }
                      else {
                          delete this.$syncKeys[key];
                      }
                  },
                  save(key, value) {
                      try {
                          const oldValue = storage.getItem(key);
                          const data = isString(value) ? value : serializer.stringify(value);
                          storage.setItem(key, data);
                          if (oldValue !== data && isClient && store.$syncKeys[key]) {
                              window.dispatchEvent(new StorageEvent(key, {
                                  newValue: data,
                                  oldValue,
                                  storageArea: storage,
                              }));
                          }
                      }
                      catch (e) {
                          quotaError.value = isQuotaExceededError(e, storage);
                      }
                  },
                  clear() {
                      this.$refMap.forEach((_, k) => this.removeItem(k));
                  },
                  removeItem(k) {
                      const item = this.$refMap.get(k);
                      // remove the object value if item deleted
                      if (item) {
                          item.value = undefined;
                      }
                      // clear the watch
                      const stop = this.$watchHandlers.get(k);
                      if (stop) {
                          stop();
                      }
                      delete this.$syncKeys[k];
                      this.$refMap.delete(k);
                      storage.removeItem(k);
                  },
                  getItem(k) {
                      /**
                       * NOTE seems if the element who created the `ref` gets destroyed all the watchers assigned will be also disposed
                       * making returning of the cached `ref` invalid
                       */
                      const data = storage.getItem(k);
                      if (!data) {
                          return null;
                      }
                      return this.setItem(k, safeParse(serializer, data));
                  },
                  getRef(k) {
                      const item = compositionApi.ref();
                      let keyWatch = compositionApi.watch(wrap(k), (k) => {
                          const data = storage.getItem(k);
                          if (!data) {
                              return (item.value = null);
                          }
                          item.value = safeParse(serializer, data);
                      }, {
                          immediate: true,
                          flush: "sync",
                      });
                      let valueWatch = compositionApi.watch(item, debounce((i) => {
                          this.save(unwrap(k), i);
                      }, ms), { deep: true, flush: "sync" });
                      // used to reference to this ref, since `k` change change we need to generate one
                      const fakeKey = Math.random().toString();
                      this.$watchHandlers.set(fakeKey, () => {
                          keyWatch();
                          valueWatch();
                      });
                      this.$refMap.set(fakeKey, item);
                      return item;
                  },
                  setItem(k, v) {
                      const reference = wrap(v);
                      this.$refMap.set(k, reference);
                      this.save(k, v);
                      // @ts-ignore
                      const stop = compositionApi.watch(reference, debounce((r) => {
                          this.save(k, r);
                      }, ms), {
                          immediate: false,
                          deep: true,
                      });
                      this.$watchHandlers.set(k, stop);
                      return reference;
                  },
                  updateItem(k, data) {
                      let r = this.$refMap.get(k);
                      if (r) {
                          r.value = safeParse(serializer, data);
                      }
                  },
              };
              storageMap.set(type, store);
          }
          else {
              quotaError = store.$quotaError;
          }
      }
      else {
          quotaError = compositionApi.ref(false);
          store = {};
      }
      return {
          supported,
          quotaError,
          store,
          remove,
      };
  }

  function useLocalStorage(key, defaultValue, sync) {
      const { supported, store } = useWebStorage("localStorage");
      let remove = NO_OP;
      let clear = NO_OP;
      let setSync = NO_OP;
      let storage = undefined;
      if (supported && store) {
          setSync = (s) => store.setSync(unwrap(key), s);
          remove = () => store.removeItem(unwrap(key));
          clear = () => store.clear();
          storage = store.getRef(key);
          if (storage.value == null) {
              store.save(unwrap(key), defaultValue);
              storage.value = defaultValue;
          }
          compositionApi.watchEffect(() => {
              if (sync !== false) {
                  setSync(true);
              }
          });
      }
      else {
          /* istanbul ignore else */
          {
              console.warn("[localStorage] is not available");
          }
          storage = compositionApi.ref(defaultValue);
      }
      return {
          supported,
          storage,
          clear,
          remove,
          setSync,
      };
  }

  function useSessionStorage(key, defaultValue, sync) {
      const { supported, store } = useWebStorage("sessionStorage");
      let remove = NO_OP;
      let clear = NO_OP;
      let setSync = FALSE_OP;
      let storage = undefined;
      if (supported && store) {
          /* istanbul ignore else */
          {
              setSync = () => console.warn("sync is not supported, please `useLocalStorage` instead");
              if (sync) {
                  setSync(sync);
              }
          }
          remove = () => store.removeItem(unwrap(key));
          clear = () => store.clear();
          storage = store.getRef(key);
          if (storage.value == null) {
              store.save(unwrap(key), defaultValue);
              storage.value = defaultValue;
          }
      }
      else {
          /* istanbul ignore else */
          {
              console.warn("[sessionStorage] is not available");
          }
          storage = compositionApi.ref(defaultValue);
      }
      return {
          supported,
          storage,
          clear,
          remove,
          setSync,
      };
  }

  let canUseLocalStorage = undefined;
  function useStorage(key, defaultValue, sync) {
      if (canUseLocalStorage === undefined) {
          canUseLocalStorage = useWebStorage("localStorage").supported;
      }
      return canUseLocalStorage
          ? useLocalStorage(key, defaultValue, sync)
          : useSessionStorage(key, defaultValue, sync);
  }

  /**
   * Create a pagination controller based on the arguments
   * @param options -
   */
  function usePagination(options) {
      const _currentPage = wrap(options.currentPage);
      const _pageSize = wrap(options.pageSize);
      const _offset = compositionApi.ref(0);
      const total = wrap(options.total);
      const offset = compositionApi.computed({
          get() {
              return _offset.value;
          },
          set(v) {
              if (!isNumber(v)) {
                  /* istanbul ignore else */
                  {
                      console.warn(`[offset] expected number but got: '${typeof v}' value: '${v}'`);
                  }
                  return;
              }
              _offset.value = Math.min(v, total.value);
          }
      });
      const currentPage = compositionApi.computed({
          get() {
              return _currentPage.value;
          },
          set(v) {
              if (!isNumber(v)) {
                  /* istanbul ignore else  */
                  {
                      console.warn(`[currentPage] expected number but got: '${typeof v}' value: '${v}'`);
                  }
                  return;
              }
              _currentPage.value = minMax(v, 1, lastPage.value);
              // set the offset
              offset.value = (_currentPage.value - 1) * pageSize.value;
          }
      });
      const pageSize = compositionApi.computed({
          get() {
              return _pageSize.value;
          },
          set(v) {
              if (!isNumber(v)) {
                  /* istanbul ignore else */
                  {
                      console.warn(`[pageSize] expected number but got: '${typeof v}' value: '${v}'`);
                  }
                  return;
              }
              _pageSize.value = v;
          }
      });
      const lastPage = compositionApi.computed(() => Math.ceil(total.value / pageSize.value));
      // make sure the current page is the correct value
      currentPage.value = _currentPage.value;
      const prev = () => --currentPage.value;
      const next = () => ++currentPage.value;
      const first = () => (currentPage.value = 1);
      const last = () => (currentPage.value = lastPage.value);
      compositionApi.watch([total, pageSize], _ => {
          if (currentPage.value > lastPage.value) {
              currentPage.value = lastPage.value;
          }
      }, { immediate: false } // no need to run on first render
      );
      return {
          // Mutable state
          pageSize,
          total,
          currentPage,
          offset,
          // Computed
          lastPage,
          // Functions
          next,
          prev,
          first,
          last
      };
  }

  function useArrayPagination(array, options) {
      const arrayRef = wrap(array);
      const pagination = usePagination({
          ...{
              currentPage: 1,
              pageSize: 10
          },
          ...options,
          total: compositionApi.computed(() => arrayRef.value.length)
      });
      const result = compositionApi.computed(() => {
          const array = arrayRef.value;
          if (!Array.isArray(array))
              return [];
          return array.slice(pagination.offset.value, pagination.offset.value + pagination.pageSize.value);
      });
      return {
          ...pagination,
          result
      };
  }

  /**
   * Reactive custom timer with specified refresh rate
   * @param options - Configuration
   */
  function useNow(options) {
      const SYNC_MS = 1000;
      const ms = (options && options.refreshMs) || SYNC_MS;
      const sync = options && isBoolean(options.sync) ? options.sync : true;
      const fn = (options && isFunction(options.timeFn) && options.timeFn) || Date.now;
      /* istanbul ignore else */
      {
          if (options && options.timeFn && isFunction(options.timeFn) === false) {
              console.warn("[useNow] timeFn param must be Function");
          }
      }
      let handler = undefined;
      let timeoutHandler = undefined;
      const now = compositionApi.ref(fn());
      const remove = () => {
          clearInterval(handler);
          clearTimeout(timeoutHandler);
      };
      /* istanbul ignore next */
      const start = isClient
          ? () => (handler = setInterval(() => (now.value = fn()), ms))
          : NO_OP;
      if (sync) {
          const offset = SYNC_MS - (now.value - Math.floor(now.value / SYNC_MS) * SYNC_MS);
          timeoutHandler = setTimeout(start, offset);
      }
      else {
          start();
      }
      compositionApi.onUnmounted(remove);
      return {
          now,
          remove
      };
  }

  /**
   * Reactive `Date.now()` with specified refresh rate
   * @param options - Configuration
   */
  function useDateNow(options) {
      const refreshMs = (options && options.refreshMs) || 1000;
      const sync = options && isBoolean(options.sync) ? options.sync : true;
      return useNow({
          refreshMs,
          sync,
          timeFn: Date.now
      });
  }

  /**
   * Reactive `performance.now()` with specified refresh rate
   * @param options - Configuration
   */
  function usePerformanceNow(options) {
      const refreshMs = (options && options.refreshMs) || 1000;
      const sync = options && isBoolean(options.sync) ? options.sync : true;
      return useNow({
          refreshMs,
          sync,
          timeFn: () => performance.now()
      });
  }

  function useFormat(format, args) {
      return compositionApi.computed(() => {
          const f = unwrap(format);
          if (!args) {
              return f;
          }
          const r = compositionApi.isRef(args) ? compositionApi.reactive(args.value) : compositionApi.reactive(args);
          const regEx = /({?{[\w\s]*}?})/g;
          return f.replace(regEx, s => {
              const k = s
                  .replace("{", "")
                  .replace("}", "")
                  .trim();
              // ignore if {{ }}
              if (s[0] === s[1] && s[0] === "{") {
                  return `${k}`;
              }
              const v = isArray(r) ? r[+k] : r[k];
              return v === undefined ? s : `${unwrap(v)}`;
          });
      });
  }

  /**
   * Retrieve object value based on string path
   * @param source - Source object to retrieve path
   * @param path - string path to value
   * @param separator - path separator, default '.'
   * @param notFoundReturn - not found handler
   */
  function usePath(source, path, separator = ".", notFoundReturn = NO_OP) {
      return compositionApi.computed(() => {
          const s = unwrap(source);
          const p = unwrap(path);
          if (s === undefined)
              return notFoundReturn(p, s, p, s);
          if (!p) {
              return s;
          }
          const fragments = p.split(separator);
          let c = s;
          for (let i = 0; i < fragments.length; i++) {
              let fragmentPath = fragments[i];
              if (fragmentPath[fragmentPath.length - 1] === "]") {
                  const r = /\[[`'"]?([^`'"\]]*)[`'"]?\]/g;
                  let path = fragmentPath;
                  let m = r.exec(path);
                  if (m) {
                      let lastLen = m[0].length;
                      let lastIndex = m.index - lastLen;
                      let mi = 1;
                      do {
                          if (lastIndex + lastLen !== m.index) {
                              // istanbul ignore else
                              {
                                  console.warn(`[usePath] invalid path "${fragments[i]}"`);
                              }
                          }
                          lastIndex = m.index;
                          lastLen = m[0].length;
                          fragmentPath = fragmentPath.slice(0, -m[0].length);
                          fragments.splice(i + mi, 0, m[1]);
                          ++mi;
                      } while ((m = r.exec(path)));
                      // if the fragmentPath is empty, eg: [1][1]
                      // we should continue until the next path
                      if (!fragmentPath && path[0] === "[" && path.length > 2) {
                          continue;
                      }
                  }
                  else {
                      fragmentPath = "";
                      console.warn(`[usePath] invalid path provided "${path}"`);
                  }
              }
              if (isObject(c)) {
                  if (!fragmentPath) {
                      // istanbul ignore else
                      {
                          console.warn(`Path "${fragments
                            .slice(0, i + 1)
                            .join(separator)}" doesn't exist on:`, source);
                      }
                      return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);
                  }
                  c = c[fragmentPath];
              }
              else {
                  // istanbul ignore else
                  {
                      console.warn(`Path "${fragments
                        .slice(0, i + 1)
                        .join(separator)}" doesn't exist on:`, source);
                  }
                  return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);
              }
              if (!c) {
                  // istanbul ignore else
                  {
                      console.warn(`Path "${fragments
                        .slice(0, i + 1)
                        .join(separator)}" doesn't exist on:`, source);
                  }
                  return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);
              }
          }
          return c;
      });
  }

  /* /Output */
  function isValidation(v) {
      return typeof v.$value !== "undefined";
  }
  function isValidatorObject(v) {
      return isObject(v);
  }
  const buildValidationFunction = (r, f, m, handlers) => {
      const $promise = compositionApi.ref(null);
      const $pending = compositionApi.ref(false);
      const $error = compositionApi.ref();
      const $invalid = compositionApi.ref(false);
      let context = undefined;
      const onChange = (r) => {
          const p = async () => {
              try {
                  $pending.value = true;
                  const result = f(r, context);
                  if (isPromise(result)) {
                      $invalid.value = !(await result);
                  }
                  else {
                      $invalid.value = !result;
                  }
                  // @ts-ignore
                  $error.value = $invalid.value ? m.value || true : undefined;
              }
              catch (e) {
                  $invalid.value = true;
                  throw e;
              }
              finally {
                  $pending.value = false;
              }
          };
          $promise.value = p().catch((x) => {
              $error.value = unwrap(x);
              $invalid.value = true;
              return x;
          });
      };
      handlers.push((ctx) => {
          context = ctx;
          compositionApi.watch(() => {
              try {
                  // keep track on the external dependencies
                  f(r.value, context);
              }
              catch (e) {
                  // ignore error
              }
              return r.value;
          }, onChange, { deep: true, immediate: true });
      });
      function $touch() {
          onChange(r.value);
      }
      return {
          $promise,
          $pending,
          $invalid,
          $error,
          $touch,
      };
  };
  const buildValidationValue = (r, v, handlers) => {
      const { $message, $validator, ...$rest } = isValidatorObject(v)
          ? v
          : { $validator: v, $message: undefined };
      const { $pending, $promise, $invalid, $error, $touch, } = buildValidationFunction(r, $validator, compositionApi.ref($message), handlers);
      return {
          $pending,
          $error,
          $promise,
          $invalid,
          $message,
          $touch,
          ...$rest,
      };
  };
  const buildValidation = (o, handlers) => {
      const r = {};
      const $value = isValidation(o) ? wrap(o.$value) : undefined;
      for (const k of Object.keys(o)) {
          if (k[0] === "$") {
              if (k === "$value") {
                  r[k] = $value;
                  const $dirty = compositionApi.ref(false);
                  let dirtyWatch = NO_OP;
                  const createDirtyWatcher = () => {
                      dirtyWatch();
                      dirtyWatch = compositionApi.watch($value, () => {
                          $dirty.value = true;
                          dirtyWatch();
                      }, { immediate: false, deep: true });
                  };
                  createDirtyWatcher();
                  r["$dirty"] = $dirty;
                  r["$reset"] = () => {
                      $dirty.value = false;
                      createDirtyWatcher();
                  };
                  r["$touch"] = () => ($dirty.value = true);
                  // @ts-ignore
                  r.toObject = () => unwrap($value);
                  continue;
              }
              else {
                  r[k] = o[k];
                  continue;
              }
          }
          if ($value) {
              const validation = buildValidationValue($value, o[k], handlers);
              // @ts-expect-error no valid type
              r[k] = validation;
          }
          else {
              const validation = buildValidation(o[k], handlers);
              let $anyDirty = undefined;
              let $errors;
              let $anyInvalid;
              let toObject = NO_OP;
              if (isValidation(validation)) {
                  const validations = Object.keys(validation)
                      .filter((x) => x[0] !== "$")
                      .map((x) => validation[x]);
                  $errors = compositionApi.computed(() => validations
                      .map((x) => x.$error)
                      .map((x) => unwrap(x))
                      .filter((x) => x !== undefined));
                  // $anyDirty = computed(() => validations.some(x => !!x));
                  $anyInvalid = compositionApi.computed(() => validations.some((x) => {
                      return !!unwrap(x.$invalid);
                  }));
                  toObject = () => {
                      return Object.keys(validation)
                          .filter((x) => x[0] !== "$")
                          .reduce((p, c) => {
                          //@ts-ignore
                          p[c] = validation[c].toObject();
                          return p;
                      }, {});
                  };
              }
              else {
                  const validations = Object.keys(validation).map((x) => validation[x]);
                  $errors = compositionApi.computed(() => {
                      return validations
                          .map((x) => unwrap(x.$errors))
                          .filter((x) => x !== undefined)
                          .filter((x) => {
                          return x.some(Boolean);
                      });
                  });
                  $anyDirty = compositionApi.computed(() => {
                      return validations.some((x) => {
                          return (unwrap(x.$anyDirty) ||
                              (isBoolean(unwrap(x.$dirty)) &&
                                  unwrap(x.$dirty)));
                      });
                  });
                  $anyInvalid = compositionApi.computed(() => validations.some((x) => {
                      return !!unwrap(x.$anyInvalid);
                  }));
                  toObject = () => {
                      return Object.keys(validation)
                          .filter((x) => x[0] !== "$")
                          .reduce((p, c) => {
                          //@ts-ignore
                          p[c] = validation[c].toObject();
                          return p;
                      }, {});
                  };
              }
              r[k] = {
                  toObject,
                  ...validation,
                  $errors,
                  $anyInvalid,
              };
              if ($anyDirty) {
                  r[k].$anyDirty = $anyDirty;
                  const keys = Object.keys(r[k]).filter((x) => x[0] !== "$" && isObject(r[k][x]));
                  r[k].$touch = () => {
                      // r[k].
                      keys.forEach((m) => {
                          const touch = r[k][m].$touch;
                          if (touch) {
                              touch();
                          }
                      });
                  };
                  r[k].$reset = () => {
                      keys.forEach((m) => {
                          const reset = r[k][m].$reset;
                          if (reset) {
                              reset();
                          }
                      });
                  };
              }
          }
      }
      return r;
  };
  function useValidation(input) {
      const handlers = [];
      const validation = buildValidation({ input }, handlers);
      // convert to reactive, this will make it annoying to deconstruct, but
      // allows to use it directly on the render template without `.value`
      // https://github.com/vuejs/vue-next/pull/738
      // @ts-expect-error TODO check this error
      const validationInput = compositionApi.reactive(validation.input);
      // set the context, this will allow to use this object as the second
      // argument when calling validators
      handlers.forEach((x) => x(validationInput));
      return validationInput;
  }

  // istanbul ignore next
  // Symbol used to inject/provide the i18n values
  const I18n_ACCESS_SYMBOL = Symbol(("I18n") );
  function useI18n(definition) {
      if (definition) {
          return setI18n(definition);
      }
      else
          return compositionApi.inject(I18n_ACCESS_SYMBOL);
  }
  /**
   * Builds i18n object based on the definition
   * @param definition - i18n definition
   */
  function buildI18n(definition) {
      const locales = compositionApi.ref(Object.keys(definition.messages));
      const localeMessages = compositionApi.ref(definition.messages);
      const locale = compositionApi.ref(definition.locale);
      const i18n = compositionApi.ref({});
      let fallback = compositionApi.ref();
      const cache = {};
      const retrieveLocaleValue = (x) => {
          return ("__esModule" in x || x[Symbol.toStringTag] === "Module") &&
              "default" in x
              ? x.default
              : x;
      };
      const loadLocale = (locale, messages) => {
          if (cache[locale]) {
              return cache[locale];
          }
          const l = messages.value[locale];
          if (!l) {
              return compositionApi.ref({});
          }
          let m = isFunction(l) ? l() : l;
          if (isPromise(m)) {
              return m.then((x) => {
                  return (cache[locale] = wrap(retrieveLocaleValue(x)));
              });
          }
          // if it was function we don't keep track on that
          if (isFunction(l)) {
              // return wrap(m)
              return wrap(retrieveLocaleValue(m));
          }
          return (cache[locale] = compositionApi.computed(() => retrieveLocaleValue(messages.value[locale])));
      };
      const shouldFallback = definition.fallback
          ? isBoolean(definition.notFoundFallback)
              ? definition.notFoundFallback
              : true
          : false;
      let fallbackIsPromise = false;
      if (shouldFallback) {
          const fallbackI18n = loadLocale(definition.fallback, localeMessages);
          if (isPromise(fallbackI18n)) {
              fallbackI18n.then((x) => {
                  fallback.value = x.value;
              });
              fallbackIsPromise = true;
          }
          else {
              fallback.value = fallbackI18n.value;
          }
      }
      else {
          fallback.value = {};
      }
      const localeChangesCount = compositionApi.ref(0);
      compositionApi.watch(localeMessages, () => localeChangesCount.value++, {
          deep: true,
          immediate: false,
      });
      compositionApi.watch([locale, fallback, localeChangesCount], ([l, fb, _]) => {
          if (l === definition.fallback && shouldFallback) {
              i18n.value = fb;
          }
          else {
              const setI18n = (v) => (i18n.value = deepClone({}, fb, unwrap(v)));
              // const localeMessage = await loadLocale(l as string, localeMessages);
              // i18n.value = deepClone<any>({}, fb, localeMessage.value);
              const r = loadLocale(l, localeMessages);
              if (isPromise(r)) {
                  r.then(setI18n);
              }
              else {
                  setI18n(r);
              }
          }
      }, {
          immediate: !fallbackIsPromise,
      });
      const $t = (path, args) => {
          if (definition.resolve) {
              return wrap(definition.resolve(i18n.value, path, args));
          }
          return useFormat(usePath(i18n, path, ".", (_, _1, p, _2) => p), args);
      };
      const $ts = (path, args) => {
          return $t(path, args).value;
      };
      const addLocale = (l, m) => {
          if (locales.value.indexOf(l) >= 0) {
              /* istanbul ignore else */
              {
                  console.warn(`[useI18n] Locale "${l}" already exists, overriding it...`);
              }
          }
          else {
              locales.value.push(l);
          }
          delete cache[l];
          // istanbul ignore if
          {
              vueSet(localeMessages.value, l, m);
          }
      };
      const removeLocale = (l) => {
          const index = locales.value.indexOf(l);
          if (index >= 0) {
              const nextLocale = [
                  locale.value,
                  fallback.value && definition.fallback,
                  ...locales.value,
              ].find((x) => x && x !== l);
              if (nextLocale) {
                  if (l === definition.fallback) {
                      /* istanbul ignore else */
                      {
                          console.warn(`[useI18n] removing default fallback locale "${l}"`);
                      }
                      fallback.value = undefined;
                  }
                  if (l === locale.value) {
                      /* istanbul ignore else */
                      {
                          console.warn(`[useI18n] removing current locale "${l}", setting current locale to "${nextLocale}"`);
                      }
                      locale.value = nextLocale;
                  }
              }
              else {
                  /* istanbul ignore else */
                  {
                      console.error("[useI18n] No locales available to use");
                  }
              }
              locales.value.splice(index, 1);
          }
          else {
              /* istanbul ignore else */
              {
                  console.warn(`[useI18n] Locale "${l}" doesn't exist`);
              }
          }
          // istanbul ignore else
          {
              vueDelete(localeMessages.value, l);
          }
          delete cache[l];
      };
      return {
          locale,
          locales,
          i18n,
          $t,
          $ts,
          addLocale,
          removeLocale,
      };
  }
  /**
   * Build and provide i18n definition
   * @param definition - I18N definition
   */
  function setI18n(definition) {
      const r = buildI18n(definition);
      compositionApi.provide(I18n_ACCESS_SYMBOL, r);
      return r;
  }

  // istanbul ignore next
  const SSR_TITLE_KEY = Symbol(("SSR_TITLE_KEY") );
  function provideSSRTitle(app, title) {
      const r = wrap(title === undefined ? "" : title);
      app.provide(SSR_TITLE_KEY, r);
      return r;
  }
  function useSSRTitle(defaultTitle) {
      const s = Symbol();
      const title = compositionApi.inject(SSR_TITLE_KEY, s);
      // @ts-ignore check if it exists
      if (title === s) {
          /* istanbul ignore else */
          {
              console.warn("[useSSRTitle] can't find SSRTitle have you forgotten calling `provideSSRTitle`?");
          }
          // istanbul ignore next
          return compositionApi.ref(isString(defaultTitle) ? defaultTitle : "");
      }
      if (title === undefined) {
          // probably not in `setup()`
          // istanbul ignore next
          return compositionApi.ref(isString(defaultTitle) ? defaultTitle : "");
      }
      if (isString(defaultTitle)) {
          title.value = defaultTitle;
      }
      return title;
  }
  function useTitle(overrideTitle = null) {
      const title = compositionApi.ref(isString(overrideTitle) ? overrideTitle : document.title);
      const observer = new MutationObserver(m => {
          title.value = m[0].target.textContent;
      });
      compositionApi.watch(title, (t, o) => {
          if (isString(t) && t !== o) {
              document.title = t;
          }
      }, {
          immediate: true,
          flush: "sync"
      });
      const titleElement = document.querySelector("title");
      observer.observe(titleElement, { childList: true });
      compositionApi.onUnmounted(() => observer.disconnect());
      return title;
  }

  // istanbul ignore next
  const HYDRATION_KEY = Symbol(("VUE_COMPOSABLE_HYDRATION_KEY") );
  const hydrationPlugin = {
      // @ts-ignore
      install(app) {
          const hydrating = compositionApi.ref(true);
          readonly(hydrating);
          {
              // TODO add mixin?
              {
                  console.warn("[hydrationPlugin] HydrationPlugin is not supported in vue2");
                  hydrating.value = false;
              }
          }
      }
  };
  function useHydration() {
      {
          const s = Symbol();
          const r = compositionApi.inject(HYDRATION_KEY, s);
          if (r === s) {
              console.warn("[useHydration] no hydration found, did you forget to `app.use(HydrationPlugin)`?");
          }
      }
      return compositionApi.inject(HYDRATION_KEY, compositionApi.computed(() => false));
  }

  function useValueSync(main, args) {
      const master = wrap(main);
      const list = arguments.length === 2
          ? compositionApi.isRef(arguments[1]) && isArray(arguments[1].value)
              ? arguments[1]
              : compositionApi.ref([wrap(arguments[1])])
          : compositionApi.ref(Array.from(arguments)
              .slice(1)
              .map(x => wrap(x)));
      list.value.forEach(x => {
          x.value = master.value;
      });
      let lastLen = list.value.length;
      compositionApi.watch([master, list], ([m, list]) => {
          // value added set master
          if (lastLen < list.length) {
              list.forEach(x => {
                  if (x.value !== m) {
                      x.value = m;
                  }
              });
              return;
          }
          lastLen = list.length;
          for (const v of list) {
              if (v.value !== m) {
                  master.value = v.value;
                  return;
              }
          }
      }, {
          deep: true
      });
      compositionApi.watch(master, m => {
          list.value.forEach(x => (x.value = m));
      }, {
          deep: true,
          flush: "sync"
      });
      return list;
  }

  function useTimeline(value, options) {
      const timeline = compositionApi.ref([]);
      const clone = options && options.clone ? options.clone : (x) => x;
      const maxLength = (options && options.maxLength) || MAX_ARRAY_SIZE;
      compositionApi.watch(value, (_, o) => {
          timeline.value.unshift({
              item: clone(o),
              date: new Date()
          });
          if (timeline.value.length > maxLength) {
              timeline.value.pop();
          }
      }, {
          immediate: false,
          flush: "sync",
          // allow options to override defaults
          ...options
      });
      return readonly(timeline);
  }

  function useUndo(defaultValue, options) {
      const current = wrap(defaultValue);
      const timeline = compositionApi.ref([]);
      const position = compositionApi.ref(0);
      const maxLen = (options && options.maxLength) || MAX_ARRAY_SIZE;
      const clone = (options && options.clone) || ((t) => t);
      const prev = compositionApi.computed(() => {
          // hide current
          const p = position.value === 0 ? 1 : position.value;
          return timeline.value.slice(p);
      });
      const next = compositionApi.computed(() => {
          // hide current
          const p = position.value === 0 ? 1 : 0;
          return timeline.value.slice(p, position.value);
      });
      let addTimelineEvent = undefined;
      if (options && options.devtoolId) {
          const layer = useDevtoolsTimelineLayer(`useUndo:${options.devtoolId}`, options.devtoolId, 0x32a2bf // TODO devtools fix color
          );
          addTimelineEvent = (time, data) => layer.addEvent({
              time,
              data: {
                  value: data,
                  prev: [...prev.value],
                  next: [...next.value],
              },
              meta: {
                  prev: [...prev.value],
                  next: [...next.value],
              },
          });
      }
      compositionApi.watch(current, (c) => {
          if (timeline.value[position.value] === c) {
              //ignore because is the same value
              return;
          }
          // new value added
          if (position.value > 0) {
              const pos = position.value;
              timeline.value.splice(0, pos);
              // reset position
              position.value = 0;
          }
          if (timeline.value.length > maxLen) {
              timeline.value.pop();
          }
          const v = clone(c);
          timeline.value.unshift(v);
          if (addTimelineEvent) {
              addTimelineEvent(Date.now(), c);
          }
      }, {
          ...options,
          immediate: true,
          flush: "sync",
      });
      const undo = (step = 1) => jump(step);
      const redo = (step = 1) => jump(-step);
      const jump = (delta) => {
          const s = Math.sign(delta) <= 0
              ? Math.max(delta, -next.value.length)
              : Math.min(delta, prev.value.length);
          position.value += s;
          current.value = timeline.value[position.value];
          if (addTimelineEvent) {
              addTimelineEvent(Date.now(), clone(current.value));
          }
      };
      return {
          value: current,
          undo,
          redo,
          jump,
          prev,
          next,
      };
  }

  function useMouseDistanceFromElement(el, options, wait) {
      let distance = undefined;
      let remove = NO_OP;
      if (isClient) {
          // @ts-ignore
          const { pageX, pageY, remove: removeMouseEvent } = useOnMouseMove(window, options, wait);
          distance = compositionApi.computed(() => {
              const elem = unwrap(el);
              if (!elem)
                  return 0;
              return Math.floor(Math.sqrt(Math.pow(pageX.value - (elem.offsetLeft + elem.clientWidth / 2), 2) +
                  Math.pow(pageY.value - (elem.offsetTop + elem.clientHeight / 2), 2)));
          });
          remove = removeMouseEvent;
      }
      else {
          distance = compositionApi.computed(() => -1);
      }
      return {
          distance,
          remove,
      };
  }

  const VERSION = "1.0.0-beta.24";
  // istanbul ignore next
  const VUE_VERSION = "2" ;
  const COMMIT = "cca1e18";

  exports.COMMIT = COMMIT;
  exports.FALSE_OP = FALSE_OP;
  exports.MAX_ARRAY_SIZE = MAX_ARRAY_SIZE;
  exports.NO_OP = NO_OP;
  exports.PASSIVE_EV = PASSIVE_EV;
  exports.SCROLL_LOCK_CLASS = SCROLL_LOCK_CLASS;
  exports.UseDevtoolsApp = UseDevtoolsApp;
  exports.VERSION = VERSION;
  exports.VUE_VERSION = VUE_VERSION;
  exports.VueComposableDevtools = VueComposableDevtools;
  exports.buildI18n = buildI18n;
  exports.debounce = debounce;
  exports.deepClone = deepClone;
  exports.exponentialDelay = exponentialDelay;
  exports.exposeWorker = exposeWorker;
  exports.getCssVariableFor = getCssVariableFor;
  exports.getDevtools = getDevtools;
  exports.hydrationPlugin = hydrationPlugin;
  exports.injectFactory = injectFactory;
  exports.isArray = isArray;
  exports.isBoolean = isBoolean;
  exports.isClient = isClient;
  exports.isDate = isDate;
  exports.isElement = isElement;
  exports.isFunction = isFunction;
  exports.isNull = isNull;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isPromise = isPromise;
  exports.isString = isString;
  exports.isSymbol = isSymbol;
  exports.isUndefined = isUndefined;
  exports.minMax = minMax;
  exports.noDelay = noDelay;
  exports.promisedTimeout = promisedTimeout;
  exports.provideSSRTitle = provideSSRTitle;
  exports.refDebounced = refDebounced;
  exports.refShared = refShared;
  exports.setBreakpointTailwindCSS = setBreakpointTailwindCSS;
  exports.setCssVariableFor = setCssVariableFor;
  exports.setDevtools = setDevtools;
  exports.setI18n = setI18n;
  exports.storageAvailable = storageAvailable;
  exports.unwrap = unwrap;
  exports.useArrayPagination = useArrayPagination;
  exports.useBreakpoint = useBreakpoint;
  exports.useBreakpointChrome = useBreakpointChrome;
  exports.useBreakpointTailwindCSS = useBreakpointTailwindCSS;
  exports.useBroadcastChannel = useBroadcastChannel;
  exports.useCancellablePromise = useCancellablePromise;
  exports.useClipboard = useClipboard;
  exports.useCssVariables = useCssVariables;
  exports.useCurrencyFormat = useCurrencyFormat;
  exports.useDateNow = useDateNow;
  exports.useDebounce = useDebounce;
  exports.useDevtoolsComponentState = useDevtoolsComponentState;
  exports.useDevtoolsInspector = useDevtoolsInspector;
  exports.useDevtoolsTimelineLayer = useDevtoolsTimelineLayer;
  exports.useEvent = useEvent;
  exports.useFetch = useFetch;
  exports.useFormat = useFormat;
  exports.useGeolocation = useGeolocation;
  exports.useHydration = useHydration;
  exports.useI18n = useI18n;
  exports.useIntersectionObserver = useIntersectionObserver;
  exports.useInterval = useInterval;
  exports.useIntlDateTimeFormat = useIntlDateTimeFormat;
  exports.useIntlNumberFormat = useIntlNumberFormat;
  exports.useLanguage = useLanguage;
  exports.useLocalStorage = useLocalStorage;
  exports.useLockScroll = useLockScroll;
  exports.useMatchMedia = useMatchMedia;
  exports.useMouseDistanceFromElement = useMouseDistanceFromElement;
  exports.useNetworkInformation = useNetworkInformation;
  exports.useNow = useNow;
  exports.useOnMouseMove = useOnMouseMove;
  exports.useOnOutsidePress = useOnOutsidePress;
  exports.useOnResize = useOnResize;
  exports.useOnScroll = useOnScroll;
  exports.useOnline = useOnline;
  exports.usePageVisibility = usePageVisibility;
  exports.usePagination = usePagination;
  exports.usePath = usePath;
  exports.usePerformanceNow = usePerformanceNow;
  exports.usePromise = usePromise;
  exports.usePromiseLazy = usePromiseLazy;
  exports.useRetry = useRetry;
  exports.useSSRTitle = useSSRTitle;
  exports.useSessionStorage = useSessionStorage;
  exports.useShare = useShare;
  exports.useSharedRef = useSharedRef;
  exports.useStorage = useStorage;
  exports.useTimeline = useTimeline;
  exports.useTimeout = useTimeout;
  exports.useTitle = useTitle;
  exports.useUndo = useUndo;
  exports.useVModel = useVModel;
  exports.useValidation = useValidation;
  exports.useValueSync = useValueSync;
  exports.useWebSocket = useWebSocket;
  exports.useWebStorage = useWebStorage;
  exports.useWorker = useWorker;
  exports.useWorkerFunction = useWorkerFunction;
  exports.wrap = wrap;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}, vueCompositionApi, Vue);
