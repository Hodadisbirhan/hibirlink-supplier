/// <reference types="node" />

import { App } from '@vue/runtime-core';
import type { ComponentState } from '@vue/devtools-api';
import { ComputedRef } from '@vue/runtime-core';
import { Context } from 'vm';
import type { CustomInspectorNode } from '@vue/devtools-api';
import type { CustomInspectorOptions } from '@vue/devtools-api';
import type { CustomInspectorState } from '@vue/devtools-api';
import { DeepReadonly } from '@vue/runtime-core';
import { DevtoolsPluginApi } from '@vue/devtools-api';
import { InjectionKey } from '@vue/runtime-core';
import type { InspectedComponentData } from '@vue/devtools-api';
import { Plugin as Plugin_2 } from '@vue/runtime-core';
import { provide } from '@vue/runtime-core';
import { Ref } from '@vue/runtime-core';
import { TimelineEvent } from '@vue/devtools-api';
import { UnwrapRef } from '@vue/runtime-core';

export declare interface ArrayPaginationResult<T extends Array<any>> extends PaginationResult {
    result: ComputedRef<T>;
}

export declare type BreakpointObject = Record<string, string | number>;

export declare type BreakpointReturn<T> = Record<keyof T, Ref<boolean>> & BreakpointReturnObject<T>;

export declare interface BreakpointReturnObject<T> {
    remove: RemoveEventFunction;
    current: Ref<keyof T | undefined>;
}

export declare interface BroadCastChannelReturn<T> {
    supported: boolean;
    data: Ref<T | null>;
    messageEvent: Ref<MessageEvent | null>;
    errorEvent: Ref<MessageEvent | null>;
    errored: Ref<boolean>;
    isClosed: Ref<boolean>;
    send: (data: T) => void;
    close: Function;
    addListener: (cb: (ev: BroadcastMessageEvent<T>) => void, options?: boolean | AddEventListenerOptions) => void;
}

export declare interface BroadcastMessageEvent<T> extends MessageEvent {
    readonly data: T;
}

/**
 * Builds i18n object based on the definition
 * @param definition - i18n definition
 */
export declare function buildI18n<T extends i18nDefinition<TMessage>, TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>>(definition: T): i18nResult<keyof T["messages"], I18nExtractLocale<T["messages"][T["locale"]]>>;

export declare interface CancellablePromiseOptions extends PromiseOptions {
    /**
     * @description cancel the promise on component unmount
     * @default true
     */
    unmountCancel?: boolean;
}

export declare interface CancellablePromiseResult<TCancel = any> {
    cancel: (result?: TCancel) => void;
    cancelled: Ref<boolean>;
}

declare const CancellationToken: unique symbol;

declare type ChromeBreakpoint = {
    mobileS: 320;
    mobileM: 375;
    mobileL: 425;
    tablet: 768;
    laptop: 1024;
    laptopL: 1440;
    desktop4K: 2560;
};

declare interface ClipboardItem_2 {
    new (input: {
        [contentType: string]: Blob;
    }): ClipboardItem_2;
}
export { ClipboardItem_2 as ClipboardItem }

export declare const COMMIT: string;

/**
 * Possible configuration
 */
export declare type CssVarDef = CssVarDefinition | string;

/**
 * API to assign a value to the css variable
 */
export declare interface CssVarDefinition {
    name: string;
    value: RefTyped<string>;
}

/**
 * The values a CSS variable can contain.
 */
export declare type CssVariable = string | null;

/**
 * A CSS Variable configuration object. Each value must be a CSS variable without the leading dashes.
 */
export declare type CssVariableConfigurationObject = Record<string, CssVarDef>;

/**
 * The CSS variable return object. Each value is a `Ref` of a CSS variable's contents.
 */
export declare type CssVariableObject<T> = Record<keyof T, Ref<CssVariable>>;

/**
 * Additional methods.
 */
export declare interface CssVariablesMethods {
    /**
     * Stops the observation.
     */
    stop: () => void;
    /**
     * Resumes the observation.
     */
    resume: () => void;
    /**
     * current observing state
     */
    observing: Ref<boolean>;
    supported: boolean;
}

export declare type CurrencyCodes = "AFA" | "ALL" | "DZD" | "AOR" | "ARS" | "AMD" | "AWG" | "AUD" | "AZN" | "BSD" | "BHD" | "BDT" | "BBD" | "BYN" | "BZD" | "BMD" | "BTN" | "BOB" | "BWP" | "BRL" | "GBP" | "BND" | "BGN" | "BIF" | "KHR" | "CAD" | "CVE" | "KYD" | "XOF" | "XAF" | "XPF" | "CLP" | "CNY" | "COP" | "KMF" | "CDF" | "CRC" | "HRK" | "CUP" | "CZK" | "DKK" | "DJF" | "DOP" | "XCD" | "EGP" | "SVC" | "ERN" | "EEK" | "ETB" | "EUR" | "FKP" | "FJD" | "GMD" | "GEL" | "GHS" | "GIP" | "XAU" | "XFO" | "GTQ" | "GNF" | "GYD" | "HTG" | "HNL" | "HKD" | "HUF" | "ISK" | "XDR" | "INR" | "IDR" | "IRR" | "IQD" | "ILS" | "JMD" | "JPY" | "JOD" | "KZT" | "KES" | "KWD" | "KGS" | "LAK" | "LVL" | "LBP" | "LSL" | "LRD" | "LYD" | "LTL" | "MOP" | "MKD" | "MGA" | "MWK" | "MYR" | "MVR" | "MRO" | "MUR" | "MXN" | "MDL" | "MNT" | "MAD" | "MZN" | "MMK" | "NAD" | "NPR" | "ANG" | "NZD" | "NIO" | "NGN" | "KPW" | "NOK" | "OMR" | "PKR" | "XPD" | "PAB" | "PGK" | "PYG" | "PEN" | "PHP" | "XPT" | "PLN" | "QAR" | "RON" | "RUB" | "RWF" | "SHP" | "WST" | "STD" | "SAR" | "RSD" | "SCR" | "SLL" | "XAG" | "SGD" | "SBD" | "SOS" | "ZAR" | "KRW" | "LKR" | "SDG" | "SRD" | "SZL" | "SEK" | "CHF" | "SYP" | "TWD" | "TJS" | "TZS" | "THB" | "TOP" | "TTD" | "TND" | "TRY" | "TMT" | "AED" | "UGX" | "XFU" | "UAH" | "UYU" | "USD" | "UZS" | "VUV" | "VEF" | "VND" | "YER" | "ZMK" | "ZWL";

export declare type CurrencyDisplay = "none" | "symbol" | "code";

export declare interface CurrencyFormatReturn {
    format: (amount: RefTyped<number>, currency?: Readonly<RefTyped<Readonly<CurrencyCodes>>>, display?: RefTyped<CurrencyDisplay>, overrideOptions?: RefTyped<IntlNumberFormatOptions>, overrideLocale?: RefTyped<IntlNumberFormatLocales>) => Ref<Readonly<string>>;
    formatString: (amount: RefTyped<number>, currency?: Readonly<RefTyped<Readonly<CurrencyCodes>>>, display?: RefTyped<CurrencyDisplay>, overrideOptions?: RefTyped<IntlNumberFormatOptions>, overrideLocale?: RefTyped<IntlNumberFormatLocales>) => string;
}

export declare type DateTimeFormatLocales = RefTyped<string> | RefTyped<string[]> | undefined;

export declare interface DateTimeFormatReturn {
    formatter: Ref<Readonly<Intl.DateTimeFormat>>;
    format: DateTimeFormatterFormat<Ref<Readonly<string>>>;
    formatString: DateTimeFormatterFormat<string>;
}

export declare type DateTimeFormatterFormat<T> = (value: Readonly<RefTyped<Readonly<number | Date | string>>>, overrideOpts?: RefTyped<Intl.DateTimeFormatOptions | IntlDateTimeFormatOptions>, overrideLocale?: RefTyped<DateTimeFormatLocales>) => T;

export declare function debounce<F extends Procedure>(func: F, waitMilliseconds?: number, options?: Options): F;

export declare function deepClone<T extends object = object>(result: T, ...sources: T[]): T;

declare interface DefaultTailwindBreakpoints {
    sm: 640;
    md: 768;
    lg: 1024;
    xl: 1280;
}

export declare interface DevtoolInspectorNode extends CustomInspectorNode {
    children: DevtoolInspectorNode[];
    state: CustomInspectorState;
}

export declare interface DevtoolInspectorNodeState {
    [key: string]: RefTyped<DevtoolInspectorNodeStateValue>[];
    props: RefTyped<DevtoolInspectorNodeStateValue>[];
    undefined: RefTyped<DevtoolInspectorNodeStateValue>[];
    computed: RefTyped<DevtoolInspectorNodeStateValue>[];
    "register module": RefTyped<DevtoolInspectorNodeStateValue>[];
    "unregister module": RefTyped<DevtoolInspectorNodeStateValue>[];
    setup: RefTyped<DevtoolInspectorNodeStateValue>[];
    state: RefTyped<DevtoolInspectorNodeStateValue>[];
    getters: RefTyped<DevtoolInspectorNodeStateValue>[];
    mutation: RefTyped<DevtoolInspectorNodeStateValue>[];
    "vuex bindings": RefTyped<DevtoolInspectorNodeStateValue>[];
    $refs: RefTyped<DevtoolInspectorNodeStateValue>[];
    $attrs: RefTyped<DevtoolInspectorNodeStateValue>[];
}

export declare interface DevtoolInspectorNodeStateValue {
    editable: boolean;
    objectType: string;
    type: string;
    value: any;
}

export declare interface DevtoolsComponentStateOptions {
    /**
     * devtools grouping it can be `setup`, `firebase bindings`, `observables`, or a custom string
     * @default setup
     */
    type: string;
    /**
     * if the key already in the state it will add it again
     * @default false
     */
    multiple: boolean;
}

export declare type DevtoolsInspectorNodeFilter = (search: string, nodes: DevtoolInspectorNode[]) => DevtoolInspectorNode[];

export declare type DevtoolsInspectorStateFilter = (search: string, state: CustomInspectorState) => CustomInspectorState;

declare const ExecutionId: unique symbol;

export declare const exponentialDelay: RetryDelayFactory;

export declare function exposeWorker(this: Worker, func: (...args: any[]) => any): void;

declare type ExtractArguments<T = any> = T extends (...args: infer TArgs) => void ? TArgs : never;

declare type ExtractTailwindScreens<T extends TailwindConfigEmpty> = keyof T["theme"]["screens"] extends never ? DefaultTailwindBreakpoints : T["theme"]["screens"];

declare type Factory<T, TArgs extends Array<any>, TReturn = T> = (...args: TArgs) => TReturn;

export declare const FALSE_OP: () => boolean;

declare interface FetchReturn<T> extends PromiseResultFactory<Promise<Response>, ExtractArguments<(request: RequestInfo, init?: RequestInit) => void>> {
    cancel(message?: string): void;
    isCancelled: Ref<Readonly<boolean>>;
    cancelledMessage: Ref<Readonly<string | undefined>>;
    text: Ref<Readonly<string>>;
    blob: Ref<Readonly<Blob | undefined>>;
    json: Ref<T | null>;
    jsonError: Ref<string>;
    status: Ref<number | null>;
    statusText: Ref<string | null>;
}

export declare interface FormatObject {
    [id: string]: FormatValue;
}

export declare type FormatValue = RefTyped<object> | RefTyped<string> | RefTyped<number>;

export declare interface GeolocationOptions {
    /**
     * @description Executes request location immediately
     * @default true
     */
    immediate?: boolean;
}

/**
 * Gets the current value of the given CSS variable name for the given element.
 *
 * @param element The element to get the variable for.
 * @param name The CSS variable name.
 */
export declare function getCssVariableFor(element: HTMLElement, name: string): CssVariable;

/**
 * Exposes the internal devtools api instance
 */
export declare function getDevtools(): DevtoolsPluginApi<unknown> | undefined;

export declare const hydrationPlugin: Plugin_2;

/**
 * i18n interface
 * * check [typescript documentation](https://pikax.me/vue-composable/composable/i18n/i18n.html#global-definition)
 * * @example
 * ```ts
 * // types.d.ts
 * declare module "@vue-composable/core" {
 *   interface i18n {
 *     hello: string;
 *   }
 * }
 * ```
 */
export declare interface i18n extends Record<string, i18nMessageValue> {
}

/**
 * i18n definition
 */
export declare interface i18nDefinition<TMessage> {
    /**
     * Default and current locale
     * If locale and fallback are different, you may need to wait until next tick to
     * get the correct i18n values
     */
    locale: keyof TMessage;
    /**
     * Fallback locale, it will be used if the current locale doesn't
     * have value for the key.
     * Only used if `notFoundFallback !== false`
     */
    fallback?: keyof TMessage;
    /**
     * Object containing locale and messages for locale
     */
    messages: {
        [K in keyof TMessage]: i18n | (() => Promise<i18n>) | (() => i18n) | Promise<i18n>;
    };
    /**
     * Resolves the translation for i18n
     * @param i18n - i18n messages
     * @param path - desired path
     * @param args - arguments
     */
    resolve?: i18nResolver;
    /**
     * falls back to the fallback locale if key not found
     * @default true
     */
    notFoundFallback?: boolean;
}

declare type I18nExtractLocale<T> = T extends (...args: any[]) => any ? PromiseResult_2<ReturnType<T>> : PromiseResult_2<T>;

/**
 * Locale based key/value dictionary
 */
export declare type i18nLocale<T> = {
    [K in keyof T]: i18nMessage<T[K]>;
};

/**
 * Extracts i18n configuration type to the correct output
 */
export declare type i18nMessage<T> = T extends Ref<string> ? string : T extends () => Promise<infer P> ? i18nLocale<P> : T extends (...args: infer TArgs) => RefTyped<string> ? (...args: TArgs) => string : T extends object ? i18nLocale<T> : T extends Ref<infer V> ? V : T;

/**
 * i18n key and message value
 */
export declare type i18nMessageValue = i18nLocale<any> | RefTyped<string>;

/**
 * i18n Message value resolver */
export declare type i18nResolver = (i18n: i18n, path: Readonly<RefTyped<string>>, args: RefTyped<FormatObject> | Array<FormatValue> | undefined) => RefTyped<string>;

/**
 * i18n Object
 */
export declare interface i18nResult<TLocales, TMessages extends any = i18n> {
    /**
     * Current locale
     * You can assign a new locale
     */
    locale: Ref<TLocales>;
    /**
     * @readonly List of available locales
     */
    locales: Readonly<Ref<Readonly<Array<TLocales>>>>;
    /**
     * @readonly Object based locale messages
     */
    i18n: Readonly<Ref<Readonly<TMessages>>>;
    /**
     * Function based message locale with support to format and arguments
     * Inspired by [vue-i18n](https://github.com/kazupon/vue-i18n)
     * @param path - Current message path
     * @param args - Argument passed to format value
     */
    $t(path: string, args?: object | Array<object>): Readonly<Ref<string>>;
    /**
     * Function based message locale with support to format and arguments
     * Inspired by [vue-i18n](https://github.com/kazupon/vue-i18n)
     * @param path - Current message path
     * @param args - Argument passed to format value
     */
    $ts(path: string, args?: object | Array<object>): string;
    addLocale(locale: string, messages: TMessages): void;
    /**
     * Removes locale from the locale list
     * @param locale - Locale key
     */
    removeLocale(locale: TLocales): void;
}

export declare function injectFactory<T, K extends Symbol | string>(key: K extends InjectionKey<any> ? never : K, defaultValueFactory: () => Promise<K extends InjectionKey<infer IK> ? IK : T>): Promise<K extends InjectionKey<infer IK> ? IK : T>;

export declare function injectFactory<T, K extends Symbol | string>(key: K, defaultValueFactory: () => K extends InjectionKey<infer IK> ? IK : T): K extends InjectionKey<infer IK> ? IK : T;

export declare function injectFactory<T>(key: InjectionKey<T> | Symbol | string, defaultValueFactory: () => T): T;

export declare function injectFactory<T>(key: InjectionKey<T> | Symbol | string, defaultValueFactory: () => Promise<T>): Promise<T>;

export declare interface IntersectionObserverOptions {
    root?: RefTyped<Element> | null;
    rootMargin?: RefTyped<string> | string;
    threshold?: RefTyped<number | number[]> | number | number[];
}

export declare interface IntersectionObserverResult {
    supported: boolean;
    elements: Ref<IntersectionObserverEntry[]>;
    observe: (el: RefTyped<Element>) => void;
    unobserve: (el: RefTyped<Element>) => void;
    disconnect: () => void;
    readonly isIntersecting: Ref<boolean>;
}

export declare type IntlDateTimeCalendarType = "buddhist" | "chinese" | "coptic" | "ethiopia" | "ethiopic" | "gregory" | "hebrew" | "indian" | "islamic" | "iso8601" | "japanese" | "persian" | "roc";

export declare type IntlDateTimeFormatOptions = Intl.DateTimeFormatOptions & {
    dateStyle: "full" | "long" | "medium" | "short";
    timeStyle: "full" | "long" | "medium" | "short";
    calendar: IntlDateTimeCalendarType;
    dayPeriod: "narrow" | "short" | "long";
    numberingSystem: IntlDateTimeNumberingSystem;
    weekday: "narrow" | "short" | "long";
    era: "narrow" | "short" | "long";
    year: "numeric" | "2-digit";
    month: "numeric" | "2-digit" | "narrow" | "short" | "long";
    day: "numeric" | "2-digit";
    hour: "numeric" | "2-digit";
    minute: "numeric" | "2-digit";
    second: "numeric" | "2-digit";
    timeZoneName: "short" | "long";
    hour12: true | false;
    hourCycle: "h11" | "h12" | "h23" | "h24";
    formatMatcher: "basic" | "best fit";
};

export declare type IntlDateTimeNumberingSystem = "arab" | "arabext" | "bali" | "beng" | "deva" | "fullwide" | "gujr" | "guru" | "hanidec" | "khmr" | "knda" | "laoo" | "latn" | "limb" | "mlym" | "mong" | "mymr" | "orya" | "tamldec" | "telu" | "thai" | "tibt";

export declare type IntlNumberFormatLocales = RefTyped<string> | RefTyped<string[]> | undefined;

export declare type IntlNumberFormatOptions = Intl.NumberFormatOptions & {
    style?: IntNumberFormatOptionStyle & string;
    currency?: CurrencyCodes & string;
    currencyDisplay?: CurrencyDisplay & string;
};

export declare type IntNumberFormatOptionStyle = 
/**
* A decimal style format
*/
"decimal"
/**
* A percent style format.
*/
| "percent"
/**
* A currency style format that uses the currency symbol defined by the number formatter locale.
*/
| "currency"
/**
* A unit format
*/
| "unit";

export declare type IntNumberFormatterFormat<T> = (value: Readonly<RefTyped<Readonly<number>>>, overrideOpts?: RefTyped<Intl.NumberFormatOptions>, overrideLocale?: RefTyped<IntlNumberFormatLocales>) => T;

export declare const isArray: (arg: any) => arg is any[];

export declare const isBoolean: (val: unknown) => val is Boolean;

export declare const isClient: boolean;

export declare const isDate: (val: unknown) => val is Date;

export declare const isElement: (val: unknown) => val is Element;

export declare const isFunction: (val: unknown) => val is Function;

export declare const isNull: (val: unknown) => val is null;

export declare const isNumber: (val: unknown) => val is number;

export declare const isObject: (val: unknown) => val is Record<any, any>;

export declare function isPromise<T = any>(val: unknown): val is Promise<T>;

export declare const isString: (val: unknown) => val is string;

export declare const isSymbol: (val: unknown) => val is symbol;

export declare const isUndefined: (val: unknown) => val is undefined;

export declare interface LocalStorageReturn<T> {
    supported: boolean;
    storage: Ref<T>;
    /**
     * @description Removes current item from the store
     */
    remove: () => void;
    /**
     * @description Clears all tracked localStorage items
     */
    clear: () => void;
    /**
     * @description Enable cross tab syncing
     */
    setSync: (sync: boolean) => void;
}

export declare interface LockScrollOptions {
    lockedClass?: string;
    auto?: boolean;
    onChange?(el: Element, lock: boolean): void;
}

export declare interface LockScrollReturn {
    locked: Ref<boolean>;
    lock(): void;
    unlock(): void;
    remove: () => void;
}

export declare const MAX_ARRAY_SIZE: number;

export declare function minMax(val: number, min: number, max: number): number;

export declare interface MouseDistanceReturn {
    distance: ComputedRef<number>;
    remove: RemoveEventFunction;
}

export declare interface MouseMoveResult {
    mouseX: Ref<number>;
    mouseY: Ref<number>;
    pageX: Ref<number>;
    pageY: Ref<number>;
    remove: RemoveEventFunction;
}

declare interface NavigatorShareData {
    url: string;
    text: string;
    title: string;
}

declare interface NavigatorShareDefinition {
    share: (data: Partial<NavigatorShareData>) => Promise<any>;
    canShare: (data: Partial<NavigatorShareData>) => boolean;
}

declare interface NetworkInformation_2 {
    readonly downlink: number;
    readonly downlinkMax: number;
    readonly effectiveType: NetworkInformationEffectiveType;
    readonly rtt: number;
    readonly saveData: Boolean;
    readonly type: NetworkInformationType;
    onchange: (this: NetworkInformation_2, ev: Event) => void;
    addEventListener<K extends keyof NetworkInformationEventMap>(type: K, listener: (this: NetworkInformation_2, ev: NetworkInformationEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof NetworkInformationEventMap>(type: K, listener: (this: NetworkInformation_2, ev: NetworkInformationEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
}
export { NetworkInformation_2 as NetworkInformation }

declare type NetworkInformationEffectiveType = "slow-2g" | "2g" | "3g" | "4g" | "none";

declare interface NetworkInformationEventMap {
    change: Event;
}

declare interface NetworkInformationReturn {
    readonly supported: boolean;
    /**
     * @description Returns the effective bandwidth estimate in megabits per second, rounded to the nearest multiple of 25 kilobits per seconds
     */
    readonly downlink: Ref<number>;
    /**
     * @description Returns the maximum downlink speed, in megabits per second (Mbps), for the underlying connection technology.
     */
    readonly downlinkMax: Ref<number>;
    /**
     * @description Returns the effective type of the connection meaning one of 'slow-2g', '2g', '3g', or '4g'. This value is determined using a combination of recently observed round-trip time and downlink values.
     */
    readonly effectiveType: Ref<NetworkInformationEffectiveType>;
    /**
     * @description Returns the estimated effective round-trip time of the current connection, rounded to the nearest multiple of 25 milliseconds.
     */
    readonly rtt: Ref<number>;
    /**
     * @description Returns true if the user has set a reduced data usage option on the user agent.
     */
    readonly saveData: Ref<Boolean>;
    /**
     * @description Returns the type of connection a device is using to communicate with the network. It will be one of the following values:
     * @enum { NetworkInformationType}
     */
    readonly type: Ref<NetworkInformationType>;
    remove: RemoveEventFunction;
}

declare type NetworkInformationType = "bluetooth" | "cellular" | "ethernet" | "mixed" | "none" | "other" | "unknown" | "wifi" | "wimax";

export declare const NO_OP: () => void;

export declare const noDelay: RetryDelayFactory;

declare type NonDollarSign<T> = T extends `$${infer _}` ? never : T;

export declare interface NowOptions {
    /**
     * Refresh rate in milliseconds that the now gets updated
     * @default 1000
     */
    refreshMs?: number;
    /**
     * Sync with the clock by the second
     * @default true
     */
    sync?: boolean;
}

export declare interface NowReturn {
    /**
     * Now
     */
    now: Ref<number>;
    /**
     * Stop updating now
     */
    remove: () => void;
}

export declare interface NumberFormatReturn {
    formatter: Ref<Readonly<Intl.NumberFormat>>;
    format: IntNumberFormatterFormat<Ref<Readonly<string>>>;
    formatString: IntNumberFormatterFormat<string>;
}

export declare type Options = {
    /**
     * calls debounce immediately
     */
    isImmediate: boolean;
};

/**
 * Pagination control
 */
export declare type PaginationControl = () => void;

/**
 * Pagination Options
 */
export declare interface PaginationOptions {
    /**
     * @reactive
     * Page size
     */
    pageSize: RefTyped<number>;
    /**
     * @reactive
     * Total number of pages
     */
    total: RefTyped<number>;
    /**
     * @reactive
     * Starting page
     */
    currentPage: RefTyped<number>;
}

/**
 * Pagination result object
 */
export declare interface PaginationResult {
    /**
     * @reactive
     * Current page size
     */
    pageSize: Ref<number>;
    /**
     * Total number of items
     */
    total: Ref<number>;
    /**
     * @reactive
     * Current page
     */
    currentPage: Ref<number>;
    /**
     * @reactive
     * Current offset
     */
    offset: Ref<number>;
    /**
     * @readonly
     * Last page number
     */
    lastPage: Readonly<Ref<number>>;
    /**
     * go next page
     */
    next: PaginationControl;
    /**
     * go prev page
     */
    prev: PaginationControl;
    /**
     * go first page
     */
    first: PaginationControl;
    /**
     * go last page
     */
    last: PaginationControl;
}

export declare const PASSIVE_EV: AddEventListenerOptions;

/**
 * A function that emits a side effect and does not return anything.
 * https://github.com/chodorowicz/ts-debounce/blob/master/src/index.ts
 */
export declare type Procedure = (...args: any[]) => void;

export declare function promisedTimeout(timeout: number): Promise<void>;

export declare interface PromiseOptions {
    /**
     * @description if `true` allows to catch exception when `exec()`
     * @default false
     */
    throwException?: boolean;
    /**
     * @description Only executes on `exec`
     * @default false
     */
    lazy?: boolean;
}

declare interface PromiseResult<T extends Promise<any>, TR = PromiseType<T>, TError = any> {
    promise: Ref<T | undefined>;
    result: Ref<TR | null>;
    loading: Ref<boolean>;
    error: Ref<TError>;
}

declare type PromiseResult_2<T> = T extends Promise<infer R> ? R : T;

export declare interface PromiseResultFactory<T extends Promise<any>, TArgs extends Array<any> = Array<any>> extends PromiseResult<T> {
    exec: (...args: TArgs) => Promise<PromiseType<T> | undefined>;
}

declare type PromiseType<T extends Promise<any>> = T extends Promise<infer R> ? R : never;

export declare function provideSSRTitle(app: {
    provide: typeof provide;
}, title?: RefTyped<string>): Ref<string>;

export declare function refDebounced<T>(value: RefTyped<T>, delay: number): Ref<T>;

export declare function refDebounced<T>(delay: number): Ref<T | undefined>;

export declare type RefElement = Element | Ref<Element | undefined>;

export declare function refShared<T = any>(defaultValue?: RefTyped<T>, id?: string): Ref<RefTyped<T>>;

export declare type RefSharedMessage<T = any> = RefSharedMessageInit | RefSharedMessageSync<T> | RefSharedMessageLeave | RefSharedMessageUpdate<T> | RefSharedMessageSetMind | RefSharedMessagePing | RefSharedMessagePong;

export declare type RefSharedMessageInit = {
    type: RefSharedMessageType.INIT;
};

export declare type RefSharedMessageLeave = {
    type: RefSharedMessageType.LEAVE;
    id: number;
};

export declare type RefSharedMessagePing = {
    type: RefSharedMessageType.PING;
    id: number;
};

export declare type RefSharedMessagePong = {
    type: RefSharedMessageType.PONG;
    id: number;
};

export declare type RefSharedMessageSetMind = {
    type: RefSharedMessageType.SET_MIND;
    mind: SharedRefMind;
    id: number;
};

export declare type RefSharedMessageSync<T> = {
    type: RefSharedMessageType.SYNC;
    value: T;
    mind: SharedRefMind;
};

export declare const enum RefSharedMessageType {
    INIT = 0,
    SYNC = 1,
    UPDATE = 2,
    SET_MIND = 3,
    LEAVE = 4,
    PING = 5,
    PONG = 6
}

export declare type RefSharedMessageUpdate<T> = {
    type: RefSharedMessageType.UPDATE;
    value: T;
    mind: SharedRefMind;
};

export declare type RefTyped<T> = T | Ref<T>;

export declare type RemoveEventFunction = () => void;

export declare interface ResizeResult {
    height: Ref<number>;
    width: Ref<number>;
    remove: RemoveEventFunction;
}

declare interface RetryContext {
    /**
     * @description Current attempt number
     */
    retryCount: Ref<number>;
    /**
     * @description When it should retry
     * @example new Date(nextRetry.value)
     */
    nextRetry: Ref<number | undefined>;
    /**
     * @description Get the current state, set to true after the first failure
     */
    isRetrying: Ref<boolean>;
    /**
     * @description List of all the errors occurred in since the last `exec` call
     */
    retryErrors: Ref<object[]>;
    /**
     * @description **INTERNAL** incremented every time `exec` is called
     */
    [ExecutionId]: {
        value: number;
    };
    /**
     * @description **INTERNAL** Used to cancel last retry
     */
    [CancellationToken]: {
        value: boolean;
    };
}

/**
 * @description How long should it delay or what time it should execute, it also supports Promises
 * @param {number} retry - Current retry number
 * @returns {number | Date | Promise<void> | Promise<number> | Promise<Date>} - Should wait until `Date`, wait until `Promise` finish or wait `number` ms
 */
declare type RetryDelayFactory = (retry: number) => number | Date | Promise<void> | Promise<number> | Promise<Date>;

declare interface RetryOptions {
    /**
     * @description Maximum of times it should retry
     */
    maxRetries?: number;
    /**
     * @description How long should it delay or what time it should execute, it also supports Promises
     */
    retryDelay?: RetryDelayFactory;
}

declare interface RetryReturn extends RetryContext {
    /**
     * @description Cancels last retry
     */
    cancel: () => void;
}

export declare interface RetryReturnFactory<T, TArgs extends Array<any>> extends RetryReturn {
    /**
     * Executes factory with the arguments passed
     * @param args - Arguments for the execution of the factory function passed at `useRetry`
     */
    exec(...args: TArgs): T;
}

export declare interface RetryReturnNoFactory extends RetryReturn {
    /**
     * Executes factory until success
     * @param fn - Factory function
     */
    exec<T>(fn: () => T): T;
}

export declare const SCROLL_LOCK_CLASS = "no-scroll";

export declare interface ScrollResult {
    scrollTop: Ref<number>;
    scrollLeft: Ref<number>;
    remove: RemoveEventFunction;
    scrollTopTo: (y: number) => void;
    scrollLeftTo: (x: number) => void;
    scrollTo: Element["scrollTo"];
    scrollBy: Element["scrollBy"];
    scrollIntoView: Element["scrollIntoView"];
}

export declare function setBreakpointTailwindCSS<T extends TailwindConfigEmpty>(tailwindConfig: T): BreakpointReturn<ExtractTailwindScreens<T>>;

export declare function setBreakpointTailwindCSS<T extends BreakpointObject>(breakpoints: T): BreakpointReturn<T>;

/**
 * Sets the value of the given CSS variable for the given element.
 *
 * @param element The element to set the variable for.
 * @param name The CSS variable name without dashes.
 * @param value The CSS variable value.
 */
export declare function setCssVariableFor(element: HTMLElement, name: string, value: CssVariable): void;

/**
 * provide devtools api instance to the app
 * @param app
 * @param api
 */
export declare function setDevtools(app: App, api: DevtoolsPluginApi<unknown>): void;

/**
 * Build and provide i18n definition
 * @param definition - I18N definition
 */
export declare function setI18n<T extends i18nDefinition<TMessage>, TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>>(definition: T): i18nResult<keyof T["messages"], I18nExtractLocale<T["messages"][T["locale"]]>>;

export declare const enum SharedRefMind {
    HIVE = 0,
    MASTER = 1
}

export declare interface SharedRefReturn<T = any> {
    supported: boolean;
    id: number;
    data: Ref<T>;
    master: Ref<false> | Ref<true>;
    mind: Ref<SharedRefMind.HIVE> | Ref<SharedRefMind.MASTER>;
    editable: ComputedRef<boolean>;
    targets: Ref<number[]>;
    ping: () => void;
    setMind: (t: SharedRefMind) => void;
    addListener: (cb: (ev: BroadcastMessageEvent<RefSharedMessage<T>>) => void, options?: boolean | AddEventListenerOptions | undefined) => void;
}

declare interface ShareReturn {
    /**
     * If current device supports [Web Share API](https://w3c.github.io/web-share)
     * - [compatibility table](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share)
     */
    supported: boolean;
    /**
     * Set to true if the content was shared
     */
    shared: Ref<boolean>;
    /**
     * Set to true if the user didn't share
     */
    cancelled: Ref<boolean>;
    /**
     * Share information with user
     */
    share: NavigatorShareDefinition["share"];
    /**
     * Check if you can share with user
     */
    canShare: NavigatorShareDefinition["canShare"];
}

export declare function storageAvailable(storage?: Storage): boolean;

export declare interface StorageSerializer<T = any> {
    stringify(item: T): string;
    parse(data: string): T;
}

declare interface TailwindConfigEmpty {
    theme: {
        screens: Record<string, TailwindScreen | Array<TailwindScreen> | undefined | null>;
    };
}

declare type TailwindScreen = TailwindScreenBreakpointRaw | TailwindScreenBreakpointRange | number | string | Array<TailwindScreenBreakpointRange>;

declare interface TailwindScreenBreakpointRange {
    min?: string | number;
    max?: string | number;
}

declare interface TailwindScreenBreakpointRaw {
    raw: string;
}

export declare interface TimelineEntry<T> {
    item: T;
    date: Date;
}

export declare interface TimelineOptions<T> {
    deep: boolean;
    maxLength: number;
    clone: (entry: T) => T;
}

declare type ToObjectOutput<T extends Record<string, any>> = T extends {
    $value: infer V;
} ? UnwrapRef<V> : {
    [K in NonDollarSign<keyof T>]: ToObjectOutput<T[K]>;
};

export declare interface UndoOperation {
    /**
     * Move state
     * @param step - Positive position
     */
    (step: number): void;
    /**
     * Move 1 step in history
     */
    (): void;
}

export declare interface UndoOptions<T> {
    /**
     * Watch `deep` option for changes
     */
    deep: boolean;
    /**
     * Max history change
     * @default MAX_ARRAY_SIZE
     *
     */
    maxLength: number;
    /**
     * Clone strategy
     * @default (x)=>x
     */
    clone: (entry: T) => T;
    /**
     * Adds it to the devtools timeline
     * @default undefined
     */
    devtoolId?: string;
}

export declare interface UndoReturn<T> {
    /**
     * Current value
     */
    value: Ref<T>;
    /**
     * Undo state to the previous
     */
    undo(): void;
    /**
     * Undo state
     * @param step - Positive position
     */
    undo(step: number): void;
    /**
     * Redo state to the previous
     */
    redo(): void;
    /**
     * Redo state
     * @param step - Positive position
     */
    redo(step: number): void;
    /**
     * Moves the cursor to delta
     * @param delta - If positive it will `undo` the state, if negative it will `redo`
     */
    jump(delta: number): void;
    /**
     * List of previous states
     */
    prev: ComputedRef<T[]>;
    /**
     * List of next states
     * This is only populated if you `undo` or `jump`
     */
    next: ComputedRef<T[]>;
}

export declare function unwrap<T>(o: RefTyped<T>): T;

export declare function useArrayPagination<T extends Array<TR>, TR>(array: RefTyped<T>, options?: Partial<Omit<PaginationOptions, "total">>): ArrayPaginationResult<T>;

export declare function useBreakpoint<T extends BreakpointObject>(breakpoints: T): BreakpointReturn<T>;

export declare function useBreakpointChrome(): BreakpointReturn<ChromeBreakpoint>;

export declare function useBreakpointTailwindCSS<T extends TailwindConfigEmpty>(tailwindConfig: T): BreakpointReturn<ExtractTailwindScreens<T>>;

export declare function useBreakpointTailwindCSS<T extends TailwindConfigEmpty>(): BreakpointReturn<ExtractTailwindScreens<T>>;

export declare function useBreakpointTailwindCSS(): BreakpointReturn<DefaultTailwindBreakpoints>;

export declare function useBreakpointTailwindCSS<T extends BreakpointObject>(): BreakpointReturn<T>;

export declare function useBroadcastChannel<T = any>(name: string, onBeforeClose?: Function): BroadCastChannelReturn<T>;

export declare function useCancellablePromise<T extends any, TArgs extends Array<any>>(fn: (...args: TArgs) => Promise<T>): PromiseResultFactory<Promise<T>, TArgs> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends any, TArgs extends Array<any>>(fn: (...args: TArgs) => Promise<T>, lazy: boolean): PromiseResultFactory<Promise<T>, TArgs> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends any, TArgs extends Array<any>>(fn: (...args: TArgs) => Promise<T>, options: CancellablePromiseOptions): PromiseResultFactory<Promise<T>, TArgs> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends any>(fn: () => T): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends any>(fn: () => T, lazy: boolean): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends any>(fn: () => T, options: CancellablePromiseOptions): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends Promise<TR>, TR, TArgs extends Array<any>>(fn: (...args: TArgs) => T): PromiseResultFactory<T, TArgs> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends Promise<TR>, TR, TArgs extends Array<any>>(fn: (...args: TArgs) => T, lazy: boolean): PromiseResultFactory<T, TArgs> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends Promise<TR>, TR, TArgs extends Array<any>>(fn: (...args: TArgs) => T, options: CancellablePromiseOptions): PromiseResultFactory<T, TArgs> & CancellablePromiseResult;

export declare function useCancellablePromise<T = any>(fn: () => T): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

export declare function useCancellablePromise<T = any>(fn: () => T, lazy: boolean): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

export declare function useCancellablePromise<T = any>(fn: () => T, options: CancellablePromiseOptions): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

export declare function useCancellablePromise<T extends Promise<TR>, TR>(fn: () => T): PromiseResultFactory<T> & CancellablePromiseResult;

export declare interface UseClipboard {
    supported: boolean;
    text: Ref<string | undefined>;
    data: Ref<DataTransfer | undefined>;
    writeText(text: string): Promise<void>;
    readText(): Promise<string | undefined>;
    read(): Promise<DataTransfer | undefined>;
    write(items: ClipboardItem_2[]): Promise<void>;
}

export declare function useClipboard(): UseClipboard;

/**
 * Returns object. Consists of multiple pairs of key/CSS variable value references and the additional methods.
 */
export declare type UseCssVariables<T> = CssVariableObject<T> & CssVariablesMethods;

/**
 *
 * @param variables
 * @param element
 */
export declare function useCssVariables<T extends CssVariableConfigurationObject>(variables: T): UseCssVariables<T>;

export declare function useCssVariables<T extends CssVariableConfigurationObject>(variables: T, options?: MutationObserverInit): UseCssVariables<T>;

export declare function useCssVariables<T extends CssVariableConfigurationObject>(variables: T, element: RefTyped<HTMLElement>, options?: MutationObserverInit): UseCssVariables<T>;

export declare function useCurrencyFormat(): CurrencyFormatReturn;

export declare function useCurrencyFormat(options: RefTyped<IntlNumberFormatOptions>, locales?: IntlNumberFormatLocales): CurrencyFormatReturn;

export declare function useCurrencyFormat(currencyCode: Readonly<RefTyped<Readonly<CurrencyCodes>>>): CurrencyFormatReturn;

export declare function useCurrencyFormat(currencyCode: Ref<string> | string): CurrencyFormatReturn;

export declare function useCurrencyFormat(currencyCode: Readonly<RefTyped<Readonly<CurrencyCodes>>>, locales: IntlNumberFormatLocales, options?: RefTyped<IntlNumberFormatOptions>): CurrencyFormatReturn;

export declare function useCurrencyFormat(currencyCode: Ref<string> | string, locales: IntlNumberFormatLocales, options?: RefTyped<IntlNumberFormatOptions>): CurrencyFormatReturn;

export declare function useCurrencyFormat(currencyCode: Readonly<RefTyped<Readonly<CurrencyCodes>>>, options: RefTyped<IntlNumberFormatOptions>): CurrencyFormatReturn;

export declare function useCurrencyFormat(currencyCode: Ref<string> | string, options: RefTyped<IntlNumberFormatOptions>): CurrencyFormatReturn;

/**
 * Reactive `Date.now()` with specified refresh rate
 * @param options - Configuration
 */
export declare function useDateNow(options?: NowOptions): NowReturn;

/**
 * Create `debounced` function, options object can be changed after creation to update behaviour
 * @param handler - function to be debounced
 * @param wait - debounce ms
 * @param options - debounce options
 */
export declare function useDebounce<T extends Procedure>(handler: T, wait?: number, options?: Options): T;

export declare const UseDevtoolsApp: (app: App, id?: string, label?: string) => void;

export declare function useDevtoolsComponentState(getState: (instanceData: InspectedComponentData, ctx: Context) => ComponentState[]): void;

export declare function useDevtoolsComponentState(state: ComponentState[], options?: Omit<DevtoolsComponentStateOptions, "type">): void;

export declare function useDevtoolsComponentState(state: Record<string, object | ComponentState>, options?: DevtoolsComponentStateOptions): void;

export declare function useDevtoolsInspector(options: CustomInspectorOptions & {
    nodeFilter?: DevtoolsInspectorNodeFilter;
    stateFilter?: DevtoolsInspectorStateFilter;
}, nodeList?: DevtoolInspectorNode[]): {
    nodes: Ref<DevtoolInspectorNode[]>;
};

export declare function useDevtoolsTimelineLayer(id: string, label: string, color: number): {
    id: string;
    addEvent: (event: TimelineEvent, all?: boolean | undefined) => any;
    pushEvent: (event: Omit<TimelineEvent, "time">) => any;
};

export declare function useEvent<K extends keyof DocumentEventMap>(el: RefTyped<Document>, name: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): RemoveEventFunction;

export declare function useEvent<T extends {
    addEventListener: (name: string, listener: EventListenerOrEventListenerObject) => any;
    removeEventListener: Function;
}, M, K extends keyof M>(el: T | Ref<T | undefined>, name: K, listener: (this: T, ev: M[K]) => any): RemoveEventFunction;

export declare function useEvent<T extends {
    addEventListener: (name: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions) => any;
    removeEventListener: Function;
}, M, K extends keyof M>(el: T | Ref<T | undefined>, name: K, listener: (this: T, ev: M[K]) => any, options?: boolean | AddEventListenerOptions): RemoveEventFunction;

export declare function useEvent<K extends keyof WindowEventMap>(el: RefTyped<Window>, name: K, listener: (this: Document, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): RemoveEventFunction;

export declare function useEvent(el: Window, name: string, listener: (this: Document, ev: Event) => any, options?: boolean | AddEventListenerOptions): RemoveEventFunction;

export declare function useEvent<K extends keyof DocumentEventMap>(el: Element | Ref<Element | undefined>, name: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): RemoveEventFunction;

export declare function useFetch<T = any>(request?: Partial<RequestInfo>, init?: RequestInit & UseFetchOptions): FetchReturn<T>;

export declare function useFetch<T = any>(init?: RequestInit & UseFetchOptions): FetchReturn<T>;

export declare interface UseFetchOptions {
    /**
     * @description if the value is `true` it will parse the response automatically `json`
     * @default true
     */
    isJson?: boolean;
    /**
     * @description if the value is `true` it will parse the `json` before resolving the promise
     * @default true
     */
    parseImmediate?: boolean;
    /**
     * @description cancels the request on component unmount
     * @default true
     */
    unmountCancel?: boolean;
    /**
     * @description devtools timeline, if string sets the id otherwise
     * will set the request url
     * @default true
     */
    devtoolId?: boolean | string;
}

/**
 * format string based on object: [format](https://pikax.me/vue-composable/composable/format/format)
 *  * @example
 * ```ts
 * useFormat('Today is {{ day }}', { day: new Date().getDay() })
 * ```
 * @param format - string format
 * @param obj - object to get values from
 */
export declare function useFormat(format: RefTyped<Readonly<string>>, obj?: RefTyped<FormatObject>): Readonly<Ref<string>>;

export declare function useFormat(format: Readonly<RefTyped<string>>, obj?: RefTyped<FormatObject>): Readonly<Ref<string>>;

/**
 * format string based on object: [format](https://pikax.me/vue-composable/composable/format/format)
 * * @example
 * ```ts
 * useFormat('Today is {{ 0 }}', new Date().getDay())
 * ```
 * @param format - string format
 * @param args - array based format
 *
 */
export declare function useFormat(format: Readonly<RefTyped<string>>, ...args: Array<FormatValue>): Readonly<Ref<string>>;

export declare function useFormat(format: Readonly<RefTyped<string>>, obj?: RefTyped<FormatObject> | Array<FormatValue>): Readonly<Ref<string>>;

export declare function useFormat(format: RefTyped<string>, args: any): Readonly<Ref<string>>;

export declare function useGeolocation(options?: PositionOptions & GeolocationOptions): {
    supported: boolean;
    refresh: () => void;
    error: Ref<{
        readonly code: number;
        readonly message: string;
        readonly PERMISSION_DENIED: number;
        readonly POSITION_UNAVAILABLE: number;
        readonly TIMEOUT: number;
    } | null>;
    timestamp: Ref<number | null>;
    coords: Ref<{
        readonly accuracy: number;
        readonly altitude: number | null;
        readonly altitudeAccuracy: number | null;
        readonly heading: number | null;
        readonly latitude: number;
        readonly longitude: number;
        readonly speed: number | null;
    } | null>;
    highAccuracy: Ref<boolean | null>;
};

export declare function useHydration(): Ref<Boolean>;

/**
 * Calls setI18n
 * @param definition - Locale definition
 */
export declare function useI18n<T extends i18nDefinition<TMessage>, TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>>(definition: T): i18nResult<keyof T["messages"], I18nExtractLocale<T["messages"][T["locale"]]>>;

/**
 * Inject i18n
 */
export declare function useI18n<T = i18n>(): i18nResult<string[], T>;

export declare function useIntersectionObserver(el: RefElement, options?: RefTyped<IntersectionObserverOptions>): IntersectionObserverResult;

export declare function useIntersectionObserver(options: RefTyped<IntersectionObserverOptions>): IntersectionObserverResult;

export declare function useInterval<TArgs extends Array<any>>(callback: (...args: TArgs) => void, ms?: false, ...args: TArgs): UseIntervalReturn<TArgs>;

export declare function useInterval<TArgs extends Array<any>>(callback: (...args: TArgs) => void, ms?: false): UseIntervalReturn<TArgs>;

export declare function useInterval<TArgs extends Array<any>>(callback: (...args: TArgs) => void, ms: number, ...args: TArgs): UseIntervalReturn<TArgs> & UseIntervalReturnMs & UseIntervalReturnArgs<TArgs>;

export declare interface UseIntervalReturn<TArgs extends Array<any> = []> {
    start(ms: number, ...args: TArgs): number;
    remove(): void;
}

export declare interface UseIntervalReturnArgs<TArgs extends Array<any>> {
    start(_: undefined, ...args: TArgs): number;
}

export declare interface UseIntervalReturnMs {
    start(): number;
}

export declare function useIntlDateTimeFormat(): DateTimeFormatReturn;

export declare function useIntlDateTimeFormat(locales: DateTimeFormatLocales): DateTimeFormatReturn;

export declare function useIntlDateTimeFormat(options: RefTyped<IntlDateTimeFormatOptions>): DateTimeFormatReturn;

export declare function useIntlDateTimeFormat(options: RefTyped<Intl.DateTimeFormatOptions>): DateTimeFormatReturn;

export declare function useIntlDateTimeFormat(locales: DateTimeFormatLocales, options?: RefTyped<IntlDateTimeFormatOptions | undefined>): DateTimeFormatReturn;

export declare function useIntlDateTimeFormat(locales: DateTimeFormatLocales, options: RefTyped<Intl.DateTimeFormatOptions | undefined>): DateTimeFormatReturn;

export declare function useIntlNumberFormat(): NumberFormatReturn;

export declare function useIntlNumberFormat(locales: IntlNumberFormatLocales): NumberFormatReturn;

export declare function useIntlNumberFormat(options: RefTyped<IntlNumberFormatOptions>): NumberFormatReturn;

export declare function useIntlNumberFormat(options: RefTyped<Intl.NumberFormatOptions>): NumberFormatReturn;

export declare function useIntlNumberFormat(locales: IntlNumberFormatLocales, options?: RefTyped<IntlNumberFormatOptions | undefined>): NumberFormatReturn;

export declare function useIntlNumberFormat(locales: IntlNumberFormatLocales, options: RefTyped<Intl.NumberFormatOptions | undefined>): NumberFormatReturn;

export declare function useLanguage(): {
    language: Ref<string>;
    languages: Ref<readonly string[]>;
};

export declare function useLocalStorage(key: RefTyped<string>, defaultValue?: RefTyped<string>, sync?: boolean): LocalStorageReturn<string>;

export declare function useLocalStorage<T>(key: RefTyped<string>, defaultValue?: RefTyped<T>, sync?: boolean): LocalStorageReturn<T>;

export declare function useLockScroll(elements: RefTyped<(Ref<Element | undefined | null> | Element)[]>, options?: LockScrollOptions): LockScrollReturn;

export declare function useLockScroll(elements: RefTyped<(Ref<Element | undefined | null> | Element)[]>, lockedClass: string): LockScrollReturn;

export declare function useLockScroll(elements: RefTyped<(Ref<Element | undefined> | Element)[] | undefined>, options?: LockScrollOptions): LockScrollReturn;

export declare function useLockScroll(elements: RefTyped<(Ref<Element | undefined> | Element)[] | undefined>, lockedClass: string): LockScrollReturn;

export declare function useLockScroll(element: RefTyped<Element | undefined>, options?: LockScrollOptions): LockScrollReturn;

export declare function useLockScroll(element: RefTyped<Element | undefined>, lockedClass: string): LockScrollReturn;

export declare function useLockScroll(selector: string, options?: LockScrollOptions): LockScrollReturn;

export declare function useLockScroll(selector: string, lockedClass: string): LockScrollReturn;

export declare function useMatchMedia(query: string): {
    supported: boolean;
    mediaQueryList: Ref<MediaQueryList>;
    matches: Ref<boolean>;
    remove: () => void;
};

export declare function useMouseDistanceFromElement(el: RefTyped<HTMLElement>, wait: number): MouseDistanceReturn;

export declare function useMouseDistanceFromElement<T extends HTMLElement>(el: Ref<T> | Ref<T | null>, options?: boolean | AddEventListenerOptions, wait?: number): MouseDistanceReturn;

export declare function useMouseDistanceFromElement<T extends HTMLElement>(el: Ref<T | null>, wait: number): MouseDistanceReturn;

export declare function useMouseDistanceFromElement(el: RefTyped<HTMLElement>, options?: boolean | AddEventListenerOptions, wait?: number): MouseDistanceReturn;

export declare function useNetworkInformation(): NetworkInformationReturn;

/**
 * Reactive custom timer with specified refresh rate
 * @param options - Configuration
 */
export declare function useNow(options?: NowOptions & UseNowOptions): {
    now: Ref<number>;
    remove: () => void;
};

export declare interface UseNowOptions {
    /**
     * Function called when refresh the date
     *  * @example
     * ```ts
     *  () => Date.now()
     * // or
     * () => performance.now()
     * ```
     */
    timeFn?: () => number;
}

export declare function useOnline(): {
    supported: boolean;
    online: Ref<boolean>;
};

export declare function useOnMouseMove(el: RefTyped<Window>, wait: number): MouseMoveResult;

export declare function useOnMouseMove(el: RefTyped<Window>, options?: boolean | AddEventListenerOptions, wait?: number): MouseMoveResult;

export declare function useOnMouseMove(el: RefElement, wait: number): MouseMoveResult;

export declare function useOnMouseMove<T extends Element>(el: Ref<T> | Ref<T | null>, options?: boolean | AddEventListenerOptions, wait?: number): MouseMoveResult;

export declare function useOnMouseMove<T extends Element>(el: Ref<T | null>, wait: number): MouseMoveResult;

export declare function useOnMouseMove(el: RefElement, options?: boolean | AddEventListenerOptions, wait?: number): MouseMoveResult;

export declare function useOnOutsidePress(el: RefTyped<Window>, onOutsidePressCallback: (ev: MouseEvent) => void): RemoveEventFunction;

export declare function useOnOutsidePress(el: RefElement, onOutsidePressCallback: (ev: MouseEvent) => void): RemoveEventFunction;

export declare function useOnOutsidePress<T extends Element>(el: Ref<T> | Ref<T | null>, onOutsidePressCallback: (ev: MouseEvent) => void): RemoveEventFunction;

export declare function useOnOutsidePress<T extends Element>(el: Ref<T | null>, onOutsidePressCallback: (ev: MouseEvent) => void): RemoveEventFunction;

export declare function useOnOutsidePress(el: RefElement, onOutsidePressCallback: (ev: MouseEvent) => void): RemoveEventFunction;

export declare function useOnResize(el: RefTyped<Window>, wait: number): ResizeResult;

export declare function useOnResize(el: RefTyped<Window>, options?: boolean | AddEventListenerOptions, wait?: number): ResizeResult;

export declare function useOnResize(el: RefElement, wait: number): ResizeResult;

export declare function useOnResize(el: RefElement, options?: boolean | AddEventListenerOptions, wait?: number): ResizeResult;

export declare function useOnResize<T extends Element>(el: Ref<T> | Ref<T | null>, options?: boolean | AddEventListenerOptions, wait?: number): ResizeResult;

export declare function useOnResize<T extends Element>(el: Ref<T | null>, wait: number): ResizeResult;

export declare function useOnScroll(): ScrollResult;

export declare function useOnScroll(wait: number): ScrollResult;

export declare function useOnScroll(options: boolean | AddEventListenerOptions, wait?: number): ScrollResult;

export declare function useOnScroll(el: RefTyped<Window>, wait: number): ScrollResult;

export declare function useOnScroll(el: RefTyped<Window>, options?: boolean | AddEventListenerOptions, wait?: number): ScrollResult;

export declare function useOnScroll(el: RefElement, wait: number): ScrollResult;

export declare function useOnScroll(el: RefElement, options?: boolean | AddEventListenerOptions, wait?: number): ScrollResult;

export declare function useOnScroll<T extends Element>(el: Ref<T> | Ref<T | null>, options?: boolean | AddEventListenerOptions, wait?: number): ScrollResult;

export declare function useOnScroll<T extends Element>(el: Ref<T | null>, wait: number): ScrollResult;

export declare function usePageVisibility(): {
    visibility: Ref<VisibilityState>;
    hidden: Ref<boolean>;
};

/**
 * Create a pagination controller based on the arguments
 * @param options -
 */
export declare function usePagination(options: PaginationOptions): PaginationResult;

/**
 * Retrieve object value based on string path
 * @param source - Source object to retrieve path
 * @param path - string path to value
 * @param separator - path separator, default '.'
 * @param notFoundReturn - not found handler
 */
export declare function usePath<T = any, TSource = any>(source: RefTyped<TSource>, path: RefTyped<string>, separator?: string, notFoundReturn?: UsePathNotFoundReturn<TSource>): Ref<Readonly<T>>;

export declare type UsePathNotFoundReturn<TSource> = (
/**
 * Current path
 */
path: string, 
/**
 * last source found
 */
source: any, 
/**
 * Full path requested
 */
fullPath: string, 
/**
 * Original source
 */
originalSource: TSource) => any;

/**
 * Reactive `performance.now()` with specified refresh rate
 * @param options - Configuration
 */
export declare function usePerformanceNow(options?: NowOptions): NowReturn;

/**
 *
 * @param fn - factory function
 * @param lazy - Delays execution until `exec` is called
 */
export declare function usePromise<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => Promise<T>, lazy?: boolean): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromise<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => Promise<T>, options: PromiseOptions): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromise<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => Promise<T>): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromise<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => T, lazy: boolean): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromise<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => T, options: PromiseOptions): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromise<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => T): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromise<T = any>(fn: () => Promise<T>, lazy: boolean): PromiseResultFactory<Promise<T>>;

export declare function usePromise<T = any>(fn: () => Promise<T>, options: PromiseOptions): PromiseResultFactory<Promise<T>>;

export declare function usePromise<T = any>(fn: () => Promise<T>): PromiseResultFactory<Promise<T>>;

export declare function usePromise<T = any>(fn: () => T, lazy: boolean): PromiseResultFactory<Promise<T>>;

export declare function usePromise<T = any>(fn: () => T, options: PromiseOptions): PromiseResultFactory<Promise<T>>;

export declare function usePromise<T = any>(fn: () => T): PromiseResultFactory<Promise<T>>;

/**
 * Promise only created on `exec()`
 * @param fn - factory function
 * @param throwException - if `true` allows to catch exception when `exec()`
 */
export declare function usePromiseLazy<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => Promise<T>, throwException?: boolean): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromiseLazy<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => Promise<T>): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromiseLazy<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => T, throwException: boolean): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromiseLazy<T = any, TArgs extends Array<any> = Array<any>>(fn: (...args: TArgs) => T): PromiseResultFactory<Promise<T>, TArgs>;

export declare function usePromiseLazy<T = any>(fn: () => Promise<T>, throwException: boolean): PromiseResultFactory<Promise<T>>;

export declare function usePromiseLazy<T = any>(fn: () => Promise<T>): PromiseResultFactory<Promise<T>>;

export declare function usePromiseLazy<T = any>(fn: () => T, throwException: boolean): PromiseResultFactory<Promise<T>>;

export declare function usePromiseLazy<T = any>(fn: () => T): PromiseResultFactory<Promise<T>>;

export declare function useRetry(options?: RetryOptions): RetryReturnNoFactory;

export declare function useRetry<T, TArgs extends Array<any>>(factory: Factory<T, TArgs>): RetryReturnFactory<T, TArgs>;

export declare function useRetry<T, TArgs extends Array<any>>(options: RetryOptions, factory: Factory<T, TArgs>): RetryReturnFactory<T, TArgs>;

export declare function useSessionStorage(key: RefTyped<string>, defaultValue?: RefTyped<string>, sync?: boolean): LocalStorageReturn<string>;

export declare function useSessionStorage<T>(key: RefTyped<string>, defaultValue?: RefTyped<T>, sync?: boolean): LocalStorageReturn<T>;

/**
 * Invokes the native sharing mechanism of the device
 * [compatibility](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share)
 * @param data - if provided it will automatically try to share it
 */
export declare function useShare(data?: Partial<NavigatorShareData>): ShareReturn;

export declare function useSharedRef<T = any>(name: string, defaultValue?: T): SharedRefReturn<T>;

export declare function useSSRTitle(defaultTitle?: string | null): Ref<string | null>;

export declare function useStorage(key: string, defaultValue?: RefTyped<string>, sync?: boolean): LocalStorageReturn<string>;

export declare function useStorage<T>(key: string, defaultValue?: RefTyped<T>, sync?: boolean): LocalStorageReturn<T>;

export declare function useTimeline<T>(value: Ref<T>, options?: Partial<TimelineOptions<T>>): DeepReadonly<Ref<TimelineEntry<T>[]>>;

/**
 * @param fn setTimeout callback
 * @param delay If this parameter is omitted, a value of 0 is used
 * (https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)
 */
export declare function useTimeout(fn: () => void, delay?: number): UseTimeoutReturn;

declare interface UseTimeoutReturn {
    /**
     * current timeout state:
     *     false - pending
     *     true - called
     *     null - canceled
     */
    ready: Ref<boolean | null>;
    /**
     * cancel the timeout
     */
    cancel: () => void;
}

export declare function useTitle(overrideTitle?: string | null): Ref<string | null>;

export declare function useUndo<T = any>(): UndoReturn<T | undefined>;

export declare function useUndo<T>(defaultValue: RefTyped<T>, options?: Partial<UndoOptions<T>>): UndoReturn<T>;

declare type UseValidation<T> = {
    [K in keyof T]: ValidationInput<T[K]>;
};

export declare function useValidation<T extends UseValidation<E>, E = any>(input: E): Validation<E> & ValidationGroupResult & {
    toObject(): ToObjectOutput<E>;
};

export declare function useValueSync<T>(main: RefTyped<T>, ...args: RefTyped<T>[]): Ref<Ref<T>[]>;

export declare function useValueSync<T>(main: RefTyped<T>, list: Ref<Ref<T>[]>): Ref<Ref<T>[]>;

export declare function useVModel<TProps, PropName extends keyof TProps>(props: TProps, name: PropName): Ref<TProps[PropName]>;

export declare function useWebSocket(url: string, protocols?: string | string[]): WebSocketReturn;

export declare function useWebStorage(type: WebStorageType, serializer?: StorageSerializer, ms?: number): {
    supported: boolean;
    quotaError: Ref<boolean>;
    store: WebStorage;
    remove: () => boolean;
};

export declare function useWorker<TData = any, TArgs = any | any[]>(stringUrl: string | URL, args?: TArgs, options?: WorkerOptions): WorkerReturn<TData, TArgs>;

export declare function useWorkerFunction<T, TArgs extends Array<any>>(fn: (...args: TArgs) => T, options?: WebWorkerFunctionOptions): PromiseResultFactory<Promise<T | undefined>, TArgs> & CancellablePromiseResult;

declare type Validation<T extends Record<string, any>> = T extends {
    $value: infer TV;
} ? {
    [K in keyof Omit<T, "$value">]: K extends `$${infer _}` ? UnwrapRef<T[K]> : ValidatorOutput<T[K], TV>;
} & {
    $value: UnwrapRef<TV>;
} & {
    toObject(): UnwrapRef<TV>;
} & ValidationValue<TV> & {
    b: 1;
} : {
    [K in keyof T]: K extends `$${infer _}` ? UnwrapRef<T[K]> : Validation<T[K]>;
} & (NonDollarSign<keyof T> extends string ? ValidationGroupResult & {
    toObject(): ToObjectOutput<T>;
} : {});

declare interface ValidationGroupResult {
    $anyDirty: boolean;
    $errors: Array<any>;
    $anyInvalid: boolean;
    $touch(): void;
    $reset(): void;
}

declare type ValidationInput<T> = T extends {
    $value: infer TValue;
} ? ValidationInputType<T, TValue> : {
    [K in keyof T]: ValidationInput<T[K]>;
};

declare type ValidationInputType<T, TValue> = Record<Exclude<keyof T, "$value">, Validator<UnwrapRef<TValue>>> & {
    $value: TValue;
};

declare interface ValidationValue<T> {
    $value: UnwrapRef<T>;
    $dirty: boolean;
    $errors: Array<any>;
    $anyInvalid: boolean;
    $touch(): void;
    $reset(): void;
}

declare type Validator<T> = ValidatorFunc<T> | ValidatorObject<ValidatorFunc<T>>;

declare type ValidatorFunc<T, TContext = any> = (model: T, ctx: TContext) => boolean | Promise<boolean>;

declare type ValidatorObject<TValidator extends ValidatorFunc<any>> = {
    $validator: TValidator;
    $message: RefTyped<string>;
};

declare type ValidatorOutput<T, TValue> = T extends (value?: TValue, ctx?: any) => boolean ? ReturnType<T> extends Promise<boolean> ? ValidatorResultPromise & ValidatorResult : ValidatorResult : T extends {
    $validator: Function;
} ? ValidatorOutput<T["$validator"], TValue> & (T extends {
    $message: infer TM;
} ? {
    $message: TM;
} : {}) : T extends (...args: any) => infer TReturn ? TReturn extends Promise<any> ? ValidatorResultPromise & ValidatorResult : ValidatorResult : never;

declare interface ValidatorResult {
    $error: any;
    $invalid: boolean;
}

declare interface ValidatorResultPromise {
    $pending: boolean;
    $promise: Promise<boolean> | null;
}

export declare const VERSION: string;

export declare const VUE_VERSION: "2" | "3";

export declare const VueComposableDevtools: {
    install(app: App, options?: {
        id: string;
        label: string;
    }): void;
};

export declare interface WebSocketReturn {
    supported: boolean;
    data: Ref<any | null>;
    messageEvent: Ref<MessageEvent | null>;
    errorEvent: Ref<Event | null>;
    errored: Ref<boolean>;
    isClosed: Ref<boolean>;
    isOpen: Ref<boolean>;
    send: (data: string | ArrayBufferLike | Blob | ArrayBufferView) => void;
    close: Function;
    ws: WebSocket | null;
}

export declare interface WebStorage {
    $refMap: Map<string, Ref<any>>;
    $watchHandlers: Map<string, Function>;
    $syncKeys: Record<string, boolean>;
    $quotaError: Ref<boolean>;
    updateItem(key: string, value: string): void;
    setSync(key: string, sync: boolean): void;
    save(key: string, value: any): void;
    /**
     * Returns the number of key/value pairs currently present in the list associated with the object.
     */
    readonly length: number;
    /**
     * Empties the list associated with the object of all key/value pairs, if there are any.
     */
    clear(): void;
    /**
     * Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.
     */
    getItem<T = any>(key: string): Ref<T> | null;
    /**
     * Returns the current associated value with the given key, similar to `getItem` but if the key changes it will update accordingly
     */
    getRef<T = any>(key: RefTyped<string>): Ref<T>;
    /**
     * Returns the name of the nth key in the list, or null if n is greater than or equal to the number of key/value pairs in the object.
     */
    key(index: number): string | null;
    /**
     * Removes the key/value pair with the given key from the list associated with the object, if a key/value pair with the given key exists.
     */
    removeItem(key: string): void;
    /**
     * Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
     *
     * Throws a "QuotaExceededError" DOMException exception if the new value couldn't be set. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)
     */
    setItem<T>(key: string, value: T): Ref<T>;
}

declare type WebStorageType = "localStorage" | "sessionStorage";

export declare interface WebWorkerFunctionOptions {
    dependencies?: RefTyped<string[]>;
    timeout?: RefTyped<number>;
}

export declare interface WorkerReturn<TData = any, TArgs = any | any[]> {
    worker: Worker | undefined;
    data: Ref<TData | undefined>;
    postMessage: (data: TArgs) => void;
    terminate: () => void;
    errorEvent: Ref<Event | undefined>;
    errored: Ref<boolean>;
    terminated: Ref<boolean>;
}

export declare function wrap(o: RefElement): Ref<Element>;

export declare function wrap<T>(o: RefTyped<T>): Ref<T>;

export declare type WrapRef<T> = T extends Ref<any> ? T : Ref<T>;

export { }
