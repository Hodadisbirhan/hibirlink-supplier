'use strict';

function isThenable(src) {
    return src && typeof src === "object" && typeof src.then === "function";
}

/**
 * Creates a wrapped function based on the passed function.
 *
 * The returned function takes either a `T` or `Promise<T>`. If `T` the result
 * will be synchronous or if `Promise<T>` the result will be asynchronous.
 *
 * In practice this means that if you pass a synchronous object into it you will
 * maintain synchronous code but if you pass an asynchronous object you must
 * await the result.
 *
 * @internal
 */
function diverge(fn) {
    function diverged(actual, ...args) {
        if (isThenable(actual)) {
            return actual.then((resolved) => fn.call(this, resolved, ...args));
        }
        else {
            return fn.call(this, actual, ...args);
        }
    }
    return diverged;
}

/**
 * Takes all messages from all files and flattens to a single array.
 */
function flattenMessages(report) {
    return report.results.reduce((aggregated, result) => {
        return aggregated.concat(result.messages);
    }, []);
}

exports.diverge = diverge;
exports.flattenMessages = flattenMessages;
exports.isThenable = isThenable;
//# sourceMappingURL=matcher-utils.js.map
