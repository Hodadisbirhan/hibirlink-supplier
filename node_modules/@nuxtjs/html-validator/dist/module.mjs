import { fileURLToPath, pathToFileURL } from 'node:url';
import chalk from 'chalk';
import { normalize } from 'pathe';
import { isWindows } from 'std-env';
import { defineNuxtModule, logger, createResolver, isNuxt2, resolvePath } from '@nuxt/kit';

const defaultHtmlValidateConfig = {
  extends: [
    "html-validate:document",
    "html-validate:recommended",
    "html-validate:standard"
  ],
  rules: {
    //
    "svg-focusable": "off",
    "no-unknown-elements": "error",
    // Conflicts or not needed as we use prettier formatting
    "void-style": "off",
    "no-trailing-whitespace": "off",
    // Conflict with Nuxt defaults
    "require-sri": "off",
    "attribute-boolean-style": "off",
    "doctype-style": "off",
    // Unreasonable rule
    "no-inline-style": "off"
  }
};
const DEFAULTS = {
  usePrettier: false,
  failOnError: false,
  options: defaultHtmlValidateConfig,
  hookable: false
};

const module = defineNuxtModule({
  meta: {
    name: "@nuxtjs/html-validator",
    configKey: "htmlValidator",
    compatibility: {
      nuxt: "^2.0.0 || ^3.0.0-rc.7"
    }
  },
  defaults: (nuxt) => ({
    ...DEFAULTS,
    logLevel: nuxt.options.dev ? "verbose" : "warning"
  }),
  async setup(moduleOptions, nuxt) {
    logger.info(`Using ${chalk.bold("html-validate")} to validate server-rendered HTML`);
    const { usePrettier, failOnError, options, logLevel } = moduleOptions;
    if (nuxt.options.htmlValidator?.options?.extends) {
      options.extends = nuxt.options.htmlValidator.options.extends;
    }
    const { resolve } = createResolver(import.meta.url);
    if (nuxt.options.dev) {
      nuxt.hook("nitro:config", (config) => {
        config.externals = config.externals || {};
        config.externals.inline = config.externals.inline || [];
        config.externals.inline.push("@nuxtjs/html-validator");
        config.plugins = config.plugins || [];
        config.plugins.push(normalize(fileURLToPath(new URL("./runtime/nitro", import.meta.url))));
        config.virtual = config.virtual || {};
        config.virtual["#html-validator-config"] = `export default ${JSON.stringify(moduleOptions)}`;
      });
      nuxt.hook("prepare:types", ({ references }) => {
        const types = resolve("./runtime/types.d.ts");
        references.push({ path: types });
      });
    }
    if (!nuxt.options.dev || isNuxt2()) {
      const validatorPath = await resolvePath(fileURLToPath(new URL("./runtime/validator", import.meta.url)));
      const { useChecker, getValidator } = await (isWindows ? import(pathToFileURL(validatorPath).href) : import(validatorPath));
      const validator = getValidator(options);
      const { checkHTML, invalidPages } = useChecker(validator, usePrettier, logLevel);
      if (failOnError) {
        const errorIfNeeded = () => {
          if (invalidPages.length) {
            throw new Error("html-validator found errors");
          }
        };
        nuxt.hook("generate:done", errorIfNeeded);
        nuxt.hook("close", errorIfNeeded);
      }
      nuxt.hook("nitro:init", (nitro) => {
        nitro.hooks.hook("prerender:generate", (route) => {
          if (!route.contents || !route.fileName?.endsWith(".html")) {
            return;
          }
          checkHTML(route.route, route.contents);
        });
      });
      if (isNuxt2()) {
        nuxt.hook("render:route", (url, result) => checkHTML(url, result.html));
        nuxt.hook("generate:page", ({ path, html }) => checkHTML(path, html));
      }
    }
  }
});

export { module as default };
