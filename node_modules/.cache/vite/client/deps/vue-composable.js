import {
  esm_exports,
  init_esm
} from "./chunk-FTXTMDWT.js";
import {
  computed,
  getCurrentInstance,
  inject,
  onActivated,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  provide,
  watch,
  watchEffect
} from "./chunk-AB6H6ZF5.js";
import {
  customRef,
  isRef,
  reactive,
  readonly,
  ref,
  toRaw,
  unref
} from "./chunk-ZYLETUYT.js";
import {
  __toCommonJS
} from "./chunk-2E63JINA.js";

// node_modules/vue-composable/dist/vue-composable.esm-bundler.js
function unwrap(o) {
  return isRef(o) ? o.value : o;
}
function wrap(o) {
  return isRef(o) ? o : ref(o);
}
var isArray = Array.isArray;
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isBoolean = (val) => typeof val === "boolean";
var isUndefined = (val) => typeof val === "undefined";
var isNull = (val) => val === null;
var isDate = (val) => isObject(val) && isFunction(val.getTime);
var isNumber = (val) => typeof val === "number";
var isObject = (val) => val !== null && typeof val === "object";
var isElement = (val) => isObject(val) && !!val.tagName;
function isPromise(val) {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
}
var NO_OP = () => {
};
var FALSE_OP = () => false;
var PASSIVE_EV = { passive: true };
function promisedTimeout(timeout) {
  return new Promise((res) => {
    setTimeout(res, timeout);
  });
}
var MAX_ARRAY_SIZE = 2 ** 32 - 2;
function minMax(val, min, max) {
  if (val < min)
    return min;
  if (val > max)
    return max;
  return val;
}
var isClient = typeof window != "undefined";
function deepClone(result, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    if (source === void 0 || !isObject(source))
      continue;
    const keys = Object.keys(source);
    for (let j = 0; j < keys.length; j++) {
      const k = keys[j];
      const v = unwrap(source[k]);
      const sourceType = typeof v;
      const type = typeof result[k];
      if (result[k] === void 0 || sourceType === type) {
        result[k] = isObject(v) ? deepClone(result[k] || {}, v) : source[k];
      }
    }
  }
  return result;
}
function useEvent(el, name, listener, options) {
  let remove = NO_OP;
  if (el) {
    const element = wrap(el);
    const removeEventListener = (e) => e.removeEventListener(name, listener);
    const addEventListener = (e) => e.addEventListener(name, listener, options);
    const removeWatch = watch(element, (n, _, cleanUp) => {
      if (n) {
        addEventListener(n);
        cleanUp(() => removeEventListener(n));
      }
    }, { immediate: true });
    remove = () => {
      removeEventListener(element.value);
      removeWatch();
    };
  }
  return remove;
}
function useDebounce(handler, wait, options) {
  return debounce(handler, wait, options);
}
function debounce(func, waitMilliseconds = 50, options = {
  isImmediate: false
}) {
  let timeoutId;
  return function(...args) {
    const context = this;
    const doLater = function() {
      timeoutId = void 0;
      if (!options.isImmediate) {
        func.apply(context, args);
      }
    };
    const shouldCallNow = options.isImmediate && timeoutId === void 0;
    if (timeoutId !== void 0) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(doLater, waitMilliseconds);
    if (shouldCallNow) {
      func.apply(context, args);
    }
  };
}
function useOnMouseMove(el, options, wait) {
  const mouseX = ref(0);
  const mouseY = ref(0);
  const pageX = ref(0);
  const pageY = ref(0);
  let handler = (ev) => {
    mouseX.value = ev.x;
    mouseY.value = ev.y;
    pageX.value = ev.pageX;
    pageY.value = ev.pageY;
  };
  const [eventOptions, ms] = isNumber(options) ? [void 0, options] : [options, wait];
  if (ms) {
    handler = useDebounce(handler, wait);
  }
  const remove = useEvent(el, "mousemove", handler, eventOptions);
  return {
    mouseX,
    mouseY,
    pageX,
    pageY,
    remove
  };
}
function useOnResize(el, options, wait) {
  const element = wrap(el);
  const height = ref(element.value && element.value.clientHeight);
  const width = ref(element.value && element.value.clientWidth);
  let handler = () => {
    height.value = element.value.clientHeight;
    width.value = element.value.clientWidth;
  };
  const [eventOptions, ms] = isNumber(options) ? [void 0, options] : [options, wait];
  if (ms) {
    handler = useDebounce(handler, wait);
  }
  const remove = isClient ? useEvent(window, "resize", handler, eventOptions || PASSIVE_EV) : (
    /* istanbul ignore next */
    NO_OP
  );
  if (isRef(el) && !el.value) {
    onMounted(handler);
  }
  return {
    height,
    width,
    remove
  };
}
var SCROLL_METHODS = ["scrollBy", "scrollTo", "scrollIntoView"];
function useOnScroll(el, options, wait) {
  const isValidElement = (el2) => isNumber(el2) || isBoolean(el2) || !(isElement(el2) || isRef(el2)) || !el2 ? false : true;
  const element = isValidElement(el) ? wrap(el) : ref(isClient && window || void 0);
  const scrollableElement = isValidElement(el) ? element : ref(isClient && window.document.scrollingElement || void 0);
  const scrollTop = ref(scrollableElement.value && scrollableElement.value.scrollTop || 0);
  const scrollLeft = ref(scrollableElement.value && scrollableElement.value.scrollLeft || 0);
  let handler = () => {
    scrollTop.value = scrollableElement.value.scrollTop;
    scrollLeft.value = scrollableElement.value.scrollLeft;
  };
  const methods = SCROLL_METHODS.reduce((p, c) => {
    p[c] = (...args) => (
      //@ts-ignore
      scrollableElement.value && //@ts-ignore
      scrollableElement.value[c] && //@ts-ignore
      scrollableElement.value[c].apply(scrollableElement.value, args)
    );
    return p;
  }, {});
  const scrollTopTo = (top) => methods.scrollTo({ top });
  const scrollLeftTo = (left) => methods.scrollTo({ left });
  const [eventOptions, ms] = isNumber(el) || !el ? [PASSIVE_EV, el] : isNumber(options) ? [PASSIVE_EV, options] : [options, wait];
  if (ms) {
    handler = useDebounce(handler, wait);
  }
  const eventRemove = useEvent(element, "scroll", handler, eventOptions);
  const watchRemoveTop = watch(scrollTop, scrollTopTo, { immediate: false });
  const watchRemoveLeft = watch(scrollLeft, scrollLeftTo, { immediate: false });
  const remove = () => {
    eventRemove();
    watchRemoveLeft();
    watchRemoveTop();
  };
  return {
    scrollTop,
    scrollLeft,
    remove,
    scrollTopTo,
    scrollLeftTo,
    ...methods
  };
}
var events = ["mousedown", "touchstart"];
function useOnOutsidePress(el, onOutsidePressCallback) {
  if (!isClient) {
    return () => {
    };
  }
  const element = wrap(el);
  const handler = (e) => element.value && !element.value.contains(e.target) && onOutsidePressCallback(e);
  const event = events.find((x) => `on${x}` in document.documentElement);
  return useEvent(document, event, handler, { passive: true });
}
function usePromise(fn, lazyOptions) {
  if (!fn) {
    throw new Error(`[usePromise] argument can't be '${fn}'`);
  }
  if (typeof fn !== "function") {
    throw new Error(`[usePromise] expects function, but received ${typeof fn}`);
  }
  const [lazy, throwException] = isBoolean(lazyOptions) ? [lazyOptions, false] : isObject(lazyOptions) ? [lazyOptions.lazy, lazyOptions.throwException] : [false, false];
  const loading = ref(false);
  const error = ref(null);
  const result = ref(null);
  const promise = ref();
  const exec = async (...args) => {
    loading.value = true;
    error.value = null;
    const throwExp = args && fn.length !== args.length && args.length > 0 && isBoolean(args[args.length - 1]) ? args[args.length - 1] : throwException;
    const currentPromise = promise.value = fn(...args);
    try {
      const r = await currentPromise;
      if (promise.value === currentPromise) {
        result.value = r;
      }
      return r;
    } catch (er) {
      if (toRaw(promise.value) === toRaw(currentPromise)) {
        error.value = er;
        result.value = null;
      }
      return throwExp ? currentPromise : void 0;
    } finally {
      if (promise.value === currentPromise) {
        loading.value = false;
      }
    }
  };
  if (!lazy) {
    if (true) {
      if (fn.length > 0 && !isBoolean(isObject(lazyOptions) ? lazyOptions.lazy : lazyOptions)) {
        console.warn("[usePromise] parameters detected on `fn` factory. Executing promise without arguments.");
      }
    }
    exec();
  }
  return {
    exec,
    result,
    promise,
    loading,
    error
  };
}
function useCancellablePromise(fn, lazyOptions) {
  const cancelled = ref(false);
  let _cancel = void 0;
  const cancel = (result) => {
    if (!_cancel) {
      if (true) {
        console.warn("[useCancellablePromise] There's no promise to cancel. Please make sure to call `exec`");
      }
      return;
    }
    _cancel(result);
  };
  const promise = (p) => new Promise((res, rej) => {
    cancelled.value = false;
    _cancel = (result) => {
      cancelled.value = true;
      rej(result);
    };
    p.then(res).catch(rej);
  });
  const use = usePromise((...args) => promise(fn(...args)), lazyOptions);
  if (getCurrentInstance() && (!isObject(lazyOptions) || lazyOptions.unmountCancel !== false)) {
    onUnmounted(() => _cancel && _cancel());
  }
  return {
    ...use,
    cancel,
    cancelled
  };
}
var MAX_RETRIES = 9e3;
var ExecutionId = Symbol("RetryId");
var CancellationToken = Symbol("CancellationToken");
var defaultStrategy = async (options, context, factory, args) => {
  const retryId = context[ExecutionId].value;
  let i = -1;
  const maxRetries = options.maxRetries || MAX_RETRIES + 1;
  const delay = options.retryDelay || noDelay;
  context.retryErrors.value = [];
  context.isRetrying.value = false;
  context.nextRetry.value = void 0;
  let nextRetry = void 0;
  do {
    let success = false;
    let result = null;
    try {
      ++i;
      if (args) {
        result = factory(...args);
      } else {
        result = factory();
      }
      if (isPromise(result)) {
        result = await result;
      }
      if (context[CancellationToken].value) {
        return null;
      }
      success = true;
    } catch (error) {
      result = null;
      context.retryErrors.value.push(error);
    }
    if (retryId !== context[ExecutionId].value) {
      return result;
    }
    if (success) {
      context.isRetrying.value = false;
      context.nextRetry.value = void 0;
      return result;
    }
    if (i >= maxRetries) {
      context.isRetrying.value = false;
      context.nextRetry.value = void 0;
      return Promise.reject(new Error(`[useRetry] max retries reached ${maxRetries}`));
    }
    context.isRetrying.value = true;
    const now = Date.now();
    const pDelayBy = delay(i);
    const delayBy = isPromise(pDelayBy) ? await pDelayBy : pDelayBy;
    if (!isPromise(pDelayBy) || !!delayBy) {
      if (isNumber(delayBy)) {
        nextRetry = delayBy;
      } else if (isDate(delayBy)) {
        nextRetry = delayBy.getTime();
      } else {
        throw new Error(`[useRetry] invalid value received from options.retryDelay '${typeof delayBy}'`);
      }
      if (nextRetry < now) {
        context.nextRetry.value = now + nextRetry;
      } else {
        context.nextRetry.value = nextRetry;
        nextRetry = nextRetry - now;
      }
      if (nextRetry > 0) {
        await promisedTimeout(nextRetry);
      }
    }
    if (context[CancellationToken].value) {
      return null;
    }
    if (retryId !== context[ExecutionId].value) {
      return result;
    }
  } while (i < MAX_RETRIES);
  return null;
};
function useRetry(options, factory) {
  const opt = !options || isFunction(options) ? {} : options;
  const fn = isFunction(options) ? options : factory;
  if (!isFunction(options) && !isObject(options)) {
    throw new Error("[useRetry] options needs to be 'object'");
  }
  if (!!fn && !isFunction(fn)) {
    throw new Error("[useRetry] factory needs to be 'function'");
  }
  const isRetrying = ref(false);
  const nextRetry = ref();
  const retryErrors = ref([]);
  const cancellationToken = { value: false };
  const retryId = { value: 0 };
  const retryCount = computed(() => retryErrors.value.length);
  const context = {
    isRetrying,
    retryCount,
    nextRetry,
    retryErrors,
    [ExecutionId]: retryId,
    [CancellationToken]: cancellationToken
  };
  const exec = fn ? (...args) => {
    ++context[ExecutionId].value;
    return defaultStrategy(opt, context, fn, args);
  } : (f) => {
    ++context[ExecutionId].value;
    return defaultStrategy(opt, context, f, void 0);
  };
  const cancel = () => {
    context.isRetrying.value = false;
    context.retryErrors.value.push(new Error("[useRetry] cancelled"));
    context.nextRetry.value = void 0;
    cancellationToken.value = true;
  };
  return {
    ...context,
    cancel,
    exec
  };
}
var exponentialDelay = (retryNumber) => {
  const delay = Math.pow(2, retryNumber) * 100;
  const randomSum = delay * 0.2 * Math.random();
  return delay + randomSum;
};
var noDelay = () => 0;
function usePromiseLazy(fn, throwException = false) {
  return usePromise(fn, {
    lazy: true,
    throwException
  });
}
var DEVTOOLS_KEY = Symbol("DEVTOOLS_KEY");
function setDevtools(app, api) {
  if (!isFunction(app.provide)) {
    console.warn("[vue-composable] devtools is not supported for vue 2");
    return;
  }
  app.provide(DEVTOOLS_KEY, api);
}
function getDevtools() {
  const empty = {};
  const devtools = inject(DEVTOOLS_KEY, empty);
  if (devtools === empty) {
    console.warn(`[vue-composable] devtools not found, please run app.use(VueComposableDevtools)`);
    return void 0;
  }
  return devtools;
}
var apiProxyFactory = void 0;
async function pushEventsToApi(api, EventQueue, ApiQueue) {
  setTimeout(async () => {
    const priority = [
      "addTimelineLayer",
      "addInspector",
      "sendInspectorTree",
      "sendInspectorState",
      "addTimelineEvent"
    ];
    for (const k of priority) {
      for (const it of ApiQueue.filter((x) => x.type === k)) {
        api[k](...it.args);
      }
      await promisedTimeout(20);
    }
    new Set(ApiQueue.filter((x) => x.type === "notifyComponentUpdate").map((x) => x.args[0])).forEach((x) => api.notifyComponentUpdate(x));
    EventQueue.forEach((x) => api.on[x.type](...x.args));
    EventQueue.length = 0;
    ApiQueue.length = 0;
  }, 100);
}
{
  apiProxyFactory = (promiseApi) => {
    let api;
    const EventQueue = [];
    const ApiQueue = [];
    const onProxy = new Proxy({}, {
      get: (target, prop) => {
        if (api) {
          return api.on[prop];
        } else if (prop in target) {
          return target[prop];
        } else {
          return target[prop] = (...args) => {
            EventQueue.push({
              type: prop,
              args
            });
          };
        }
      }
    });
    const proxy = new Proxy({
      on: onProxy
    }, {
      get: (target, prop) => {
        if (prop === "on") {
          return target.on;
        }
        if (api) {
          return api[prop];
        }
        if (prop in target) {
          return target[prop];
        }
        return target[prop] = (...args) => {
          ApiQueue.push({
            type: prop,
            args
          });
        };
      }
    });
    promiseApi.then((x) => {
      api = x;
      pushEventsToApi(api, EventQueue, ApiQueue);
    });
    return proxy;
  };
}
var ProxyApi = apiProxyFactory;
var setupDevtoolsPlugin = NO_OP;
if (true) {
  try {
    setupDevtoolsPlugin = (init_esm(), __toCommonJS(esm_exports)).setupDevtoolsPlugin;
  } catch {
  }
}
var UseDevtoolsApp = (app, id = "vue-composable", label = "Vue-composable devtools plugin") => {
  const promise = new Promise((res) => {
    setupDevtoolsPlugin({
      id,
      label,
      app
    }, res);
  });
  setDevtools(app, ProxyApi(promise));
};
var VueComposableDevtools = {
  install(app, options = {
    id: "vue-composable",
    label: "Vue-composable devtools plugin"
  }) {
    return UseDevtoolsApp(app, options.id, options.label);
  }
};
function useDevtoolsInspector(options, nodeList = []) {
  const api = getDevtools();
  const nodes = ref(nodeList);
  const byId = computed(() => {
    if (!nodes.value)
      return /* @__PURE__ */ new Map();
    const r = toRaw(nodes.value);
    const m = /* @__PURE__ */ new Map();
    for (const i of r) {
      m.set(i.id, i);
    }
    return m;
  });
  if (api) {
    const id = options.id;
    api.addInspector(options);
    api.on.getInspectorTree((payload) => {
      if (payload.inspectorId != id)
        return;
      if (!nodes.value)
        return;
      const filter = payload.filter;
      let m = toRaw(nodes.value);
      if (payload.filter) {
        if (options.nodeFilter) {
          m = options.nodeFilter(payload.filter, m);
        } else {
          m = m.filter((x) => x.id.indexOf(filter) >= 0 || x.label.indexOf(filter) >= 0);
        }
      }
      payload.rootNodes = m;
    });
    api.on.getInspectorState((payload) => {
      if (payload.inspectorId != id)
        return;
      const node = byId.value.get(payload.nodeId);
      if (node) {
        const s = reactive(node.state);
        payload.state = options.stateFilter ? options.stateFilter("", s) : s;
      }
    });
    watch(nodes, () => {
      api.sendInspectorTree(id);
      api.sendInspectorState(id);
    }, {
      immediate: true,
      deep: true
    });
  }
  return {
    nodes
  };
}
function useDevtoolsTimelineLayer(id, label, color) {
  const api = getDevtools();
  let addEvent = NO_OP;
  let pushEvent = NO_OP;
  if (api) {
    api.addTimelineLayer({
      id,
      label,
      color
    });
    addEvent = (event, all) => api.addTimelineEvent({ layerId: id, event, all });
    pushEvent = (event) => addEvent({ ...event, time: Date.now() });
  }
  return {
    id,
    addEvent,
    pushEvent
  };
}
function getSetupStateExtra(raw) {
  if (!raw)
    return {};
  const isRef2 = !!raw.__v_isRef;
  const isComputed = isRef2 && !!raw.effect;
  const isReactive = !!raw.__v_reactive;
  const objectType = isComputed ? "Computed" : isRef2 ? "Ref" : isReactive ? "Reactive" : null;
  return {
    ...objectType ? { objectType } : {},
    ...raw.effect ? { raw: raw.effect.raw.toString() } : {}
  };
}
function useDevtoolsComponentState(state, options) {
  const instance = getCurrentInstance();
  const api = getDevtools();
  if (api && instance) {
    api.on.inspectComponent((payload, ctx) => {
      if (payload.componentInstance !== instance)
        return;
      const [type, multiple] = isObject(options) ? [options.type, options.multiple] : ["setup", false];
      if (isFunction(state)) {
        state(payload.instanceData, ctx);
        return;
      }
      let data = isArray(state) ? state : Object.keys(state).map((key) => ({
        type,
        key,
        value: unwrap(state[key]),
        ...getSetupStateExtra(state[key])
      }));
      if (!multiple) {
        const inserted = new Set(payload.instanceData.state.map((x) => x.key));
        data = data.filter((x) => !inserted.has(x.key));
      }
      payload.instanceData.state.push(...data);
    });
  }
}
function isFetchOptions(v) {
  return v && (isBoolean(v.isJson) || isBoolean(v.parseImmediate) || isBoolean(v.unmountCancel));
}
function useFetch(options, requestInitOptions) {
  const json = ref(null);
  const text = ref("");
  const blob = ref();
  const jsonError = ref(null);
  const [isJson, parseImmediate, unmountCancel] = isFetchOptions(options) ? [
    options.isJson !== false,
    options.parseImmediate !== false,
    options.unmountCancel !== false
  ] : isFetchOptions(requestInitOptions) ? [
    requestInitOptions.isJson !== false,
    requestInitOptions.parseImmediate !== false,
    requestInitOptions.unmountCancel !== false
  ] : [true, true, true];
  const requestInit = options ? isString(options) ? requestInitOptions : isFetchOptions(options) ? options : isString(options.url) ? requestInitOptions : options : void 0;
  let addTimelineEvent = void 0;
  let devtoolId = true ? isString(options) ? options : options && isString(options.url) ? options.url : "useFetch" : void 0;
  if (devtoolId) {
    const layer = useDevtoolsTimelineLayer(`useFetch:${devtoolId}`, devtoolId, 3318463);
    addTimelineEvent = (time, request, extra) => layer.addEvent({
      time,
      data: {
        ...request,
        ...extra
      },
      meta: {}
    });
  }
  const isCancelled = ref(false);
  const cancelledMessage = ref();
  let abortController = void 0;
  const cancel = (message) => {
    if (!abortController) {
      if (true) {
        if (addTimelineEvent) {
          addTimelineEvent(Date.now(), { message }, {
            type: "cancel_error",
            error: "No request has been made yet"
          });
        }
        throw new Error("Cannot cancel because no request has been made");
      } else {
        return;
      }
    }
    abortController.abort();
    isCancelled.value = true;
    cancelledMessage.value = message;
    if (addTimelineEvent) {
      addTimelineEvent(Date.now(), { message }, {
        type: "cancel"
      });
    }
  };
  const use = usePromise(async (request, init) => {
    abortController = new AbortController();
    if (addTimelineEvent) {
      addTimelineEvent(Date.now(), isString(request) ? { url: request } : request, { type: "request", init });
    }
    const response = await fetch(request, {
      signal: abortController.signal,
      ...requestInit,
      ...init
    });
    if (addTimelineEvent) {
      addTimelineEvent(Date.now(), response, {
        type: "response",
        init,
        request
      });
    }
    if (response) {
      const promises = [
        // JSON
        isJson ? response.clone().json().then((x) => json.value = x).catch((x) => {
          json.value = null;
          jsonError.value = x;
        }) : Promise.resolve(),
        // BLOB
        response.clone().blob().then((x) => {
          blob.value = x;
        }),
        // TEXT
        response.clone().text().then((x) => {
          text.value = x;
        })
      ];
      if (parseImmediate) {
        await Promise.all(promises);
        if (addTimelineEvent) {
          addTimelineEvent(Date.now(), {}, {
            type: "parsed",
            json: json.value,
            blob: blob.value,
            text: text.value,
            request
          });
        }
      }
    }
    return response;
  }, true);
  const status = computed(() => use.result.value && use.result.value.status || null);
  const statusText = computed(() => use.result.value && use.result.value.statusText || null);
  if (options) {
    if (isString(options) || isString(options.url)) {
      use.exec(options, void 0, false);
    }
  }
  if (unmountCancel && getCurrentInstance()) {
    onUnmounted(() => {
      if (abortController) {
        cancel("unmounted");
      }
    });
  }
  return {
    ...use,
    cancel,
    isCancelled,
    cancelledMessage,
    text,
    blob,
    json,
    jsonError,
    status,
    statusText
  };
}
function useWebSocket(url, protocols) {
  const supported = isClient && "WebSocket" in window;
  let ws = null;
  const messageEvent = ref(null);
  const errorEvent = ref(null);
  const data = ref(null);
  const isOpen = ref(false);
  const isClosed = ref(false);
  const errored = ref(false);
  let lastMessage = Date.now() || void 0;
  let send = NO_OP;
  let close = NO_OP;
  if (supported) {
    ws = new WebSocket(url, protocols);
    ws.addEventListener("message", (x) => {
      messageEvent.value = x;
      data.value = x.data;
      if (true) {
        if (Date.now() - lastMessage < 2) {
          console.warn('[useWebSocket] message rate is too high, if you are using "data" or "messageEvent" you might not get updated of all the messages. Use "ws.addEventListener("message", handler)" instead');
        }
        lastMessage = Date.now();
      }
    });
    ws.addEventListener("error", (error) => {
      errorEvent.value = error;
      errored.value = true;
    });
    ws.addEventListener("close", () => {
      isOpen.value = false;
      isClosed.value = true;
    });
    ws.addEventListener("open", () => {
      isOpen.value = true;
      isClosed.value = false;
    });
    send = (data2) => ws.send(data2);
    close = (code, reason) => {
      ws.close(code, reason);
    };
  }
  return {
    supported,
    ws,
    send,
    close,
    messageEvent,
    errorEvent,
    data,
    isOpen,
    isClosed,
    errored
  };
}
function useIntersectionObserver(refEl, refOptions) {
  const supported = isClient && "IntersectionObserver" in window;
  const wrappedElement = refEl ? wrap(refEl) : void 0;
  const element = wrappedElement && (isElement(wrappedElement.value) || !wrappedElement.value) ? wrappedElement : void 0;
  const options = computed(() => refOptions ? unwrap(refOptions) : !element ? unwrap(refEl) : void 0);
  const elements = ref([]);
  const isIntersecting = computed(() => elements.value.length > 0 && elements.value.every((x) => x.isIntersecting));
  const handling = (entries) => {
    elements.value = entries;
  };
  let observer = ref();
  if (supported) {
    watch(options, (options2) => {
      if (observer.value) {
        observer.value.disconnect();
      }
      const opts = options2 && options2 && {
        root: unwrap(options2.root),
        rootMargin: unwrap(options2.rootMargin),
        threshold: unwrap(options2.threshold)
      } || void 0;
      observer.value = new IntersectionObserver(handling, opts);
      const targets = elements.value.map((x) => x.target);
      targets.forEach(observer.value.observe);
    }, { deep: true, immediate: true });
  }
  const observe = supported ? (element2) => {
    const e = unwrap(element2);
    observer.value.observe(e);
  } : NO_OP;
  const unobserve = supported ? (element2) => {
    const e = unwrap(element2);
    observer.value.unobserve(e);
  } : NO_OP;
  const disconnect = () => observer.value.disconnect();
  if (element) {
    onMounted(() => {
      if (element.value) {
        observe(element);
      }
    });
    onUnmounted(() => {
      disconnect();
    });
  }
  return {
    supported,
    elements,
    observe,
    unobserve,
    disconnect,
    isIntersecting
  };
}
function useNetworkInformation() {
  const connection = isClient ? navigator.connection || navigator.mozConnection || navigator.webkitConnection : false;
  const supported = !!connection;
  const downlink = ref(0);
  const downlinkMax = ref(0);
  const effectiveType = ref("none");
  const rtt = ref(0);
  const saveData = ref(false);
  const type = ref("none");
  let handler = NO_OP;
  let remove = NO_OP;
  if (connection) {
    handler = () => {
      downlink.value = connection.downlink;
      downlinkMax.value = connection.downlinkMax;
      effectiveType.value = connection.effectiveType;
      rtt.value = connection.rtt;
      saveData.value = connection.saveData;
      type.value = connection.type;
    };
    remove = useEvent(connection, "change", handler, PASSIVE_EV);
    handler();
  } else {
    if (true) {
      console.warn("[navigator.connection] not found, networkInformation not available.");
    }
  }
  return {
    supported,
    downlink,
    downlinkMax,
    effectiveType,
    rtt,
    saveData,
    type,
    remove
  };
}
var online = void 0;
function useOnline() {
  const supported = isClient && "onLine" in navigator;
  if (!supported) {
    online = ref(false);
  }
  if (!online) {
    online = ref(navigator.onLine);
    window.addEventListener("offline", () => online.value = false, PASSIVE_EV);
    window.addEventListener("online", () => online.value = true, PASSIVE_EV);
  }
  return {
    supported,
    online
  };
}
var visibility = void 0;
var hidden = void 0;
function usePageVisibility() {
  if (!hidden) {
    hidden = ref(isClient && document.hidden);
  }
  if (!visibility) {
    if (isClient) {
      visibility = ref(document.visibilityState);
      document.addEventListener("visibilitychange", () => {
        visibility.value = document.visibilityState;
        hidden.value = document.hidden;
      }, PASSIVE_EV);
    } else {
      visibility = ref("visible");
    }
  }
  return {
    visibility,
    hidden
  };
}
var language = void 0;
var languages = void 0;
function useLanguage() {
  if (!language) {
    language = isClient ? ref(navigator.language) : ref("");
  }
  if (!languages) {
    if (isClient) {
      languages = ref(navigator.languages);
      const change = () => {
        language.value = navigator.language;
        languages.value = navigator.languages;
      };
      window.addEventListener("languagechange", change, PASSIVE_EV);
    } else {
      languages = ref([]);
    }
  }
  return {
    language,
    languages
  };
}
function useBroadcastChannel(name, onBeforeClose) {
  const supported = isClient && "BroadcastChannel" in self;
  const data = ref(null);
  const messageEvent = ref(null);
  const errorEvent = ref(null);
  const errored = ref(false);
  const isClosed = ref(false);
  let send = NO_OP;
  let close = NO_OP;
  let addListener = NO_OP;
  if (supported) {
    const bc = new BroadcastChannel(name);
    bc.addEventListener("messageerror", (e) => {
      errorEvent.value = e;
      errored.value = true;
    }, PASSIVE_EV);
    bc.addEventListener("message", (ev) => {
      messageEvent.value = ev;
      data.value = ev.data;
    }, PASSIVE_EV);
    send = (d) => bc.postMessage(d);
    close = () => {
      bc.close();
      isClosed.value = true;
    };
    addListener = (cb, o) => {
      bc.addEventListener("message", cb, o);
      onUnmounted(() => bc.removeEventListener("message", cb));
    };
    onUnmounted(() => {
      onBeforeClose && onBeforeClose();
      close();
    });
  } else {
    if (true) {
      console.warn("[BroadcastChannel] is not supported");
    }
  }
  return {
    supported,
    data,
    messageEvent,
    errorEvent,
    errored,
    isClosed,
    send,
    close,
    addListener
  };
}
function useGeolocation(options) {
  const supported = isClient && !!navigator.geolocation;
  const lazy = ref(options ? options.immediate === false : void 0);
  const error = ref(null);
  const timestamp = ref(null);
  const coords = ref(null);
  const highAccuracy = ref(options && options.enableHighAccuracy || null);
  let refresh = NO_OP;
  if (supported) {
    const setPosition = (pos) => {
      timestamp.value = pos.timestamp;
      coords.value = pos.coords;
      error.value = null;
    };
    const setError = (err) => {
      timestamp.value = Date.now();
      coords.value = null;
      error.value = err;
    };
    const clearWatch = () => lazy.value !== true && watchId && navigator.geolocation.clearWatch(watchId);
    let _currentPositionRefresh = () => navigator.geolocation.getCurrentPosition(setPosition, setError, options);
    if (lazy.value) {
      refresh = () => {
        if (lazy.value) {
          lazy.value = false;
        } else {
          _currentPositionRefresh();
        }
      };
    } else {
      refresh = _currentPositionRefresh;
    }
    let watchId = 0;
    onMounted(() => watch([highAccuracy, lazy], (a) => {
      clearWatch();
      const enableHighAccuracy = isBoolean(a[0]) ? a[0] : options ? options.enableHighAccuracy : void 0;
      watchId = navigator.geolocation.watchPosition(setPosition, setError, options ? { ...options, enableHighAccuracy } : { enableHighAccuracy });
    }, {
      immediate: !lazy.value
    }));
    onUnmounted(clearWatch);
  }
  return {
    supported,
    refresh,
    error,
    timestamp,
    coords,
    highAccuracy
  };
}
function getCssVariableFor(element, name) {
  const result = getComputedStyle(element).getPropertyValue(name);
  return result ? result.trim() : null;
}
function setCssVariableFor(element, name, value) {
  element.style.setProperty(name, value);
}
var defaultOptions = {
  attributes: true,
  childList: true,
  subtree: true
};
var sanitizeCssVarName = (name) => {
  if (name.length <= 2 || name[0] !== "-" || name[1] !== "-") {
    return `--${name}`;
  }
  return name;
};
function useCssVariables(variables, elementOrOptions, optionsConfig) {
  const supported = isClient && "MutationObserver" in self;
  const [element, options] = isRef(elementOrOptions) || isElement(elementOrOptions) ? [elementOrOptions, optionsConfig || defaultOptions] : [
    supported && document.documentElement || {},
    elementOrOptions || defaultOptions
  ];
  const observing = ref(true);
  const result = {};
  const updateValues = [];
  const defEntries = Object.entries(variables).map((x) => {
    const [name, value] = isString(x[1]) ? [x[1]] : [x[1].name, x[1].value];
    if (value) {
      updateValues.push(() => setCssVariableFor(unwrap(element), name, unwrap(value)));
      result[x[0]] = wrap(value);
    }
    return [x[0], sanitizeCssVarName(name)];
  });
  for (let i = 0; i < defEntries.length; i++) {
    const [key, name] = defEntries[i];
    if (!result[key]) {
      result[key] = ref(isRef(element) && !element.value || !supported ? null : getCssVariableFor(unwrap(element), name));
    }
    if (supported) {
      watch([result[key], wrap(element)], (val) => {
        if (!observing)
          return;
        if (val[1] && val[0] !== getCssVariableFor(val[1], name)) {
          setCssVariableFor(val[1], name, val[0]);
        }
      }, { immediate: !isRef(element) });
    }
  }
  if (!supported) {
    return {
      ...result,
      stop: NO_OP,
      resume: NO_OP,
      supported,
      observing
    };
  }
  const update = () => {
    for (let i = 0; i < defEntries.length; i++) {
      const [key, value] = defEntries[i];
      result[key].value = getCssVariableFor(unwrap(element), value);
    }
  };
  const observer = new MutationObserver(update);
  const stop = () => {
    observer.disconnect();
    observing.value = false;
  };
  const resume = () => {
    if (!observing.value) {
      update();
    }
    observer.observe(unwrap(element), options);
    observing.value = true;
  };
  onUnmounted(stop);
  if (isRef(element)) {
    onMounted(() => {
      updateValues.forEach((x) => x());
      watch(element, (n, o) => {
        if (o) {
          stop();
        }
        if (n) {
          resume();
        }
      });
    });
  } else if (isClient || element) {
    updateValues.forEach((x) => x());
    resume();
  }
  return {
    ...result,
    supported,
    resume,
    stop,
    observing
  };
}
function exposeWorker(func) {
  this.onmessage = async (e) => {
    const r = func(e.data);
    if (r === void 0) {
      if (true) {
        console.warn(`[exposeWorker] returned \`${r}\`, this might cause unexpected behaviour`);
      }
      this.postMessage(r);
    } else if (r === null) {
      this.postMessage(r);
    } else if (isArray(r)) {
      this.postMessage(r);
    } else if (r[Symbol.asyncIterator]) {
      for await (const i of r)
        this.postMessage(i);
    } else if (r[Symbol.iterator]) {
      for (const i of r)
        this.postMessage(i);
    } else {
      this.postMessage(await r);
    }
  };
}
function useWorker(stringUrl, args, options) {
  const supported = isClient && "Worker" in self;
  const errorEvent = ref();
  const data = ref();
  const terminated = ref(!supported);
  const errored = ref(!supported);
  if (!supported) {
    terminated.value = true;
    return {
      worker: void 0,
      data,
      postMessage: NO_OP,
      terminate: NO_OP,
      errorEvent,
      errored,
      terminated
    };
  }
  const worker = new Worker(stringUrl, options);
  let lastMessage = Date.now() - 20 || void 0;
  const postMessage2 = (data2) => worker.postMessage(data2);
  function terminate() {
    worker.terminate();
    terminated.value = true;
  }
  worker.addEventListener("message", (x) => {
    data.value = x.data;
    if (true) {
      if (Date.now() - lastMessage < 2) {
        console.warn("[useWorker] message rate is too high, you might not get updated of all the messages.");
      }
      lastMessage = Date.now();
    }
  }, PASSIVE_EV);
  worker.addEventListener("error", (error) => {
    errorEvent.value = error;
    errored.value = true;
  }, PASSIVE_EV);
  onUnmounted(terminate);
  if (args) {
    postMessage2(args);
  }
  return {
    worker,
    data,
    postMessage: postMessage2,
    terminate,
    errorEvent,
    errored,
    terminated
  };
}
function useShare(data) {
  const supported = isClient && "share" in navigator;
  let share = () => Promise.resolve(false);
  let canShare = FALSE_OP;
  let shared2 = ref(false);
  let cancelled = ref(false);
  if (supported) {
    share = (data2) => {
      shared2.value = false;
      cancelled.value = false;
      return navigator.share(data2).then((x) => {
        shared2.value = true;
        return x;
      }).catch((e) => {
        shared2.value = false;
        cancelled.value = true;
        return false;
      });
    };
    canShare = (data2) => navigator.canShare(data2);
    if (data) {
      if (canShare(data)) {
        share(data);
      }
    }
  }
  return {
    supported,
    share,
    canShare,
    shared: shared2,
    cancelled
  };
}
function useClipboard() {
  const supported = isClient && "clipboard" in navigator;
  const text = ref();
  const data = ref();
  const writeText = (data2) => {
    text.value = data2;
    if (!supported)
      return Promise.resolve();
    return navigator.clipboard.writeText(data2);
  };
  const write = (data2) => {
    if (!supported)
      return Promise.resolve();
    return navigator.clipboard.write(data2);
  };
  let readText = () => Promise.resolve(void 0);
  let read = readText;
  if (supported) {
    let updating = false;
    const update = () => readText().then((x) => text.value = x);
    ["copy", "cut", "focus"].map((event) => useEvent(window, event, () => update()));
    readText = () => navigator.clipboard.readText().then((x) => {
      try {
        updating = true;
        return text.value = x;
      } finally {
        updating = false;
      }
    });
    read = () => navigator.clipboard.read().then((x) => data.value = x);
    watch(text, debounce((s) => {
      if (updating || !isString(s))
        return;
      writeText(s);
    }, 100));
  }
  return {
    supported,
    text,
    data,
    writeText,
    readText,
    write,
    read
  };
}
function useTimeout(fn, delay = 0) {
  let ready = ref(false);
  const timeoutId = setTimeout(() => {
    ready.value = true;
    fn();
  }, delay);
  const cancel = () => {
    ready.value = null;
    clearTimeout(timeoutId);
  };
  onUnmounted(cancel);
  return {
    ready,
    cancel
  };
}
var inlineWorkExecution = (f) => function(e) {
  const args = e.data || [];
  return new Promise((res) => {
    try {
      Promise.resolve(f.apply(f, args)).then((x) => res(postMessage([true, x]))).catch((x) => res(postMessage([false, x])));
    } catch (e2) {
      res(postMessage([false, e2]));
    }
  });
};
function createBlobUrl(fn, dependencies) {
  const scripts = dependencies.length > 0 ? `importScripts("${dependencies.join('","')}");` : "";
  const blobScript = [
    scripts,
    "onmessage=",
    `(${inlineWorkExecution.toString()})(${fn.toString()})`
  ];
  const blob = new Blob(blobScript, { type: "text/javascript" });
  return URL.createObjectURL(blob);
}
function useWorkerFunction(fn, options) {
  const supported = isClient && "Worker" in self;
  const dependencies = computed(() => options && unwrap(options.dependencies) || []);
  const timeoutRef = computed(() => options && unwrap(options.timeout));
  if (!supported) {
    return useCancellablePromise(fn, { lazy: true, throwException: true });
  }
  const promise = useCancellablePromise((...args) => new Promise((res, rej) => {
    const blobUrl = createBlobUrl(fn, dependencies.value);
    const worker = new Worker(blobUrl);
    let timeoutId = -1;
    const timeout = timeoutRef.value;
    const terminate = () => {
      worker.terminate();
      URL.revokeObjectURL(blobUrl);
      clearTimeout(timeoutId);
      removeWatch();
    };
    const watchCancel = args.length === fn.length + 1 && isRef(args[args.length - 1]) && args[args.length - 1].value === false ? computed(() => promise.cancelled.value || args[args.length - 1].value) : promise.cancelled;
    const removeWatch = watchCancel ? watch(watchCancel, () => {
      terminate();
      res(void 0);
    }, { immediate: false }) : NO_OP;
    worker.addEventListener("message", (e) => {
      if (e.data[0]) {
        res(e.data[1]);
      } else {
        rej(e.data[1]);
      }
      terminate();
    }, PASSIVE_EV);
    worker.addEventListener("error", (e) => {
      terminate();
      rej(e);
    }, PASSIVE_EV);
    worker.postMessage([...args]);
    if (timeout) {
      timeoutId = setTimeout(() => {
        promise.cancel(`[WebWorker] timeout after ${timeout}ms`);
      }, timeout);
    }
  }), {
    lazy: true,
    throwException: true
  });
  return promise;
}
function useMatchMedia(query) {
  const supported = isClient ? "matchMedia" in window : false;
  let mediaQueryList = void 0;
  let matches = void 0;
  let remove = NO_OP;
  if (supported) {
    mediaQueryList = ref(matchMedia(query));
    matches = ref(mediaQueryList.value.matches);
    const process2 = (e) => {
      matches.value = e.matches;
    };
    mediaQueryList.value.addEventListener("change", process2, PASSIVE_EV);
    const remove2 = () => mediaQueryList.value.removeEventListener("change", process2);
    onUnmounted(remove2);
  } else {
    if (true) {
      console.warn("[matchMedia] not supported");
    }
    mediaQueryList = ref({});
    matches = ref(false);
  }
  return {
    supported,
    mediaQueryList,
    matches,
    remove
  };
}
function useSharedRef(name, defaultValue) {
  const { addListener, send, close, supported } = useBroadcastChannel(name, () => disconnect());
  const id = Date.now();
  const master = ref(false);
  const mind = ref(
    0
    /* HIVE */
  );
  const editable = computed(() => mind.value === 1 ? master.value : true);
  const targets = ref([]);
  const data = ref(defaultValue);
  let updateState = false;
  let masterId = void 0;
  send({
    type: 0
    /* INIT */
  });
  const ping = () => send({ type: 5, id });
  const disconnect = () => {
    if (targets.value.length === 0)
      return;
    if (master.value) {
      send({
        type: 3,
        mind: 1,
        id: Math.min(...targets.value)
      });
    }
    send({
      type: 4,
      id
    });
  };
  const setMind = (t) => {
    switch (t) {
      case 1: {
        master.value = true;
        break;
      }
      case 0: {
        master.value = false;
        break;
      }
    }
    mind.value = t;
    send({
      type: 3,
      id,
      mind: mind.value
    });
  };
  addListener((e) => {
    switch (e.data.type) {
      case 0: {
        send({
          type: 2,
          value: data.value,
          mind: mind.value
        });
        break;
      }
      case 4: {
        const index = targets.value.indexOf(e.data.id);
        if (index >= 0) {
          targets.value.splice(index, 1);
        }
        if (masterId === e.data.id && targets.value.length > 0) {
          send({
            type: 3,
            mind: 1,
            id: Math.min(id, ...targets.value)
          });
        }
        break;
      }
      case 2: {
        updateState = true;
        data.value = e.data.value;
        mind.value = e.data.mind;
        break;
      }
      case 3: {
        mind.value = e.data.mind;
        masterId = e.data.mind === 1 && e.data.id || void 0;
        master.value = masterId === id;
        if (master.value) {
          targets.value = [];
          ping();
        }
        break;
      }
      case 5: {
        targets.value = [e.data.id];
        send({
          type: 6,
          id
        });
        break;
      }
      case 6: {
        targets.value.push(e.data.id);
        break;
      }
    }
  }, PASSIVE_EV);
  ping();
  watch(data, (v, o) => {
    if (updateState) {
      updateState = false;
      return;
    }
    if (mind.value === 1 && master.value === false) {
      updateState = true;
      data.value = o;
      return;
    }
    send({
      type: 2,
      mind: mind.value,
      value: isObject(v) ? { ...v } : v
    });
    updateState = false;
  }, { deep: true, immediate: false });
  if (isClient) {
    window.addEventListener("unload", disconnect, PASSIVE_EV);
  }
  onUnmounted(() => {
    disconnect();
    close();
  });
  return {
    supported,
    id,
    data,
    master,
    mind,
    editable,
    targets,
    ping,
    setMind,
    addListener
  };
}
var shared = void 0;
function refShared(defaultValue, id) {
  const vm = getCurrentInstance();
  const name = id ? id : vm.vnode.scopeId;
  if (!name) {
    if (true) {
      console.warn("[refShared] please assign an id, returning `ref`");
    }
    return ref(defaultValue);
  }
  if (true) {
    if (!shared) {
      shared = /* @__PURE__ */ new Set();
    }
    if (shared.has(name)) {
      console.warn("[refShared] You can only have one refShared per component, if you need more please assign pass an id refShared(defaultValue, id)");
    }
    shared.add(name);
  }
  const { data, supported } = useSharedRef(name, defaultValue);
  if (true) {
    if (!supported) {
      console.warn("[refShared] is dependent of BroadcastChannel");
    }
  }
  return data;
}
var SCROLL_LOCK_CLASS = "no-scroll";
function useLockScroll(selectorElements, classOptions) {
  const elements = isString(selectorElements) ? ref([]) : isArray(unref(selectorElements)) ? wrap(selectorElements) : wrap([selectorElements]);
  const options = isString(classOptions) ? { lockedClass: classOptions, auto: true } : classOptions || { auto: true };
  if (!options.lockedClass) {
    options.lockedClass = SCROLL_LOCK_CLASS;
  }
  const locked = ref(false);
  const tracked = computed(() => elements.value.map((x) => ref(x)));
  const remove = watch([locked, tracked], ([l, els], [oldLocked, oldElements]) => {
    for (const refEl of els) {
      const el = unwrap(refEl);
      if (options.lockedClass) {
        if (!el) {
          if (true) {
            console.warn("[useLockScroll] element is undefined");
          }
          return;
        }
        el.classList.toggle(options.lockedClass, l);
      }
      if (options.onChange) {
        if (oldLocked !== l || !oldElements.find((x) => unwrap(x) === el))
          options.onChange(el, l);
      }
    }
  }, { flush: "sync", deep: false });
  const lock = () => locked.value = true;
  const unlock = () => locked.value = false;
  if (isString(selectorElements)) {
    onMounted(() => elements.value = Array.from(document.querySelectorAll(selectorElements)));
  }
  if (options.auto !== false) {
    onMounted(lock);
    onActivated(lock);
    onDeactivated(unlock);
    onBeforeUnmount(unlock);
  }
  return {
    locked,
    lock,
    unlock,
    remove
  };
}
function useVModel(props, name) {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useVModel must be called from the setup or lifecycle hook methods.");
  }
  return computed({
    get() {
      return props[name];
    },
    set(v) {
      instance.emit(`update:${name}`, v);
    }
  });
}
function injectFactory(key, defaultValueFactory) {
  return inject(key, defaultValueFactory, true);
}
function useInterval(callback, ms, ...args) {
  let intervalId = void 0;
  const start = (_ms, ..._args) => {
    remove();
    if (!_ms && !ms) {
      return;
    }
    const m = _ms || ms;
    return intervalId = setInterval(callback, m, ..._args && _args.length ? _args : args);
  };
  const remove = () => {
    if (!intervalId)
      return;
    clearInterval(intervalId);
    intervalId = void 0;
  };
  if (isNumber(ms)) {
    start();
  }
  onUnmounted(remove);
  return { remove, start };
}
function refDebounced(value, delay) {
  let [v, d] = arguments.length === 1 && isNumber(value) && typeof delay === "undefined" ? [ref(), value] : [ref(value), delay];
  return customRef((track, trigger) => ({
    get() {
      track();
      return v.value;
    },
    set: debounce((val) => {
      v.value = val;
      trigger();
    }, d)
  }));
}
function intlDateFormatExtractArguments(localesOptions, opts) {
  const wrappedOpts = wrap(opts);
  const wrappedLocalesOptions = wrap(localesOptions);
  return isObject(wrappedOpts.value) || isRef(opts) ? [
    wrappedLocalesOptions.value !== void 0 ? wrappedLocalesOptions : void 0,
    wrappedOpts
  ] : isObject(wrappedLocalesOptions.value) && !isArray(wrappedLocalesOptions.value) && !isString(wrappedLocalesOptions.value) ? [void 0, wrappedLocalesOptions] : [
    wrappedLocalesOptions.value ? wrappedLocalesOptions : void 0,
    void 0
  ];
}
function useIntlDateTimeFormat(localesOptions, opts) {
  const [locales, options] = intlDateFormatExtractArguments(localesOptions, opts);
  const formatter = computed(() => new Intl.DateTimeFormat(unwrap(locales), unwrap(options)));
  const formatString = (value, overrideOpts, overrideLocale) => {
    const f = overrideOpts || overrideLocale ? new Intl.DateTimeFormat(unwrap(overrideLocale) || unwrap(locales), { ...unwrap(options), ...unwrap(overrideOpts) }) : formatter.value;
    const v = unwrap(value);
    return f.format(isString(v) ? new Date(v) : v);
  };
  const format = (value, overrideOpts, overrideLocale) => computed(() => formatString(value, overrideOpts, overrideLocale));
  return {
    format,
    formatString,
    formatter
  };
}
function useIntlNumberFormat(localesOptions, opts) {
  const [locales, options] = intlDateFormatExtractArguments(localesOptions, opts);
  const formatter = computed(() => new Intl.NumberFormat(unwrap(locales), unwrap(options)));
  const formatString = (value, overrideOpts, overrideLocale) => {
    const f = overrideOpts || overrideLocale ? new Intl.NumberFormat(unwrap(overrideLocale) || unwrap(locales), { ...unwrap(options), ...unwrap(overrideOpts) }) : formatter.value;
    return f.format(unwrap(value));
  };
  const format = (value, overrideOpts, overrideLocale) => computed(() => formatString(value, overrideOpts, overrideLocale));
  return {
    format,
    formatString,
    formatter
  };
}
function useCurrencyFormat(currencyCodeOptions, localesOptions, opts) {
  const unwrapCodeOptions = unwrap(currencyCodeOptions);
  const hasCurrency = !isObject(unwrapCodeOptions);
  const currencyCode = hasCurrency ? currencyCodeOptions : computed(() => {
    const o = unwrap(currencyCodeOptions);
    return o.currency;
  });
  const [locales, argOptions] = intlDateFormatExtractArguments(localesOptions, hasCurrency ? opts : currencyCodeOptions);
  const options = computed(() => {
    const opts2 = unwrap(argOptions) || {};
    const currency = unwrap(currencyCode) || opts2.currency;
    return {
      style: "currency",
      ...opts2,
      currency
    };
  });
  const numberFormat = useIntlNumberFormat(locales);
  const formatString = (amount, currency, display, opts2, overrideLocale) => {
    const o = { ...options.value, ...unwrap(opts2) };
    const c = unwrap(currency) || o.currency;
    const d = unwrap(display) || o.currencyDisplay;
    if (true) {
      if (!c) {
        console.error("[useCurrencyFormat] No currency provided.");
        return "";
      }
      if (o.style !== "currency") {
        console.warn("[useCurrencyFormat] invalid style passed in options, please leave it undefined.");
      }
    }
    return numberFormat.formatString(amount, {
      ...o,
      currency: c,
      currencyDisplay: d
    }, overrideLocale);
  };
  const format = (amount, currency, display, opts2, overrideLocale) => {
    return computed(() => formatString(amount, currency, display, opts2, overrideLocale));
  };
  return {
    format,
    formatString
  };
}
function getBreakpointWidth(bp) {
  if (!bp)
    return void 0;
  if (isNumber(bp))
    return bp;
  return isValidWidthBreakpoint(bp);
}
var isValidWidthBreakpoint = (bp) => {
  const m = bp.match(/^(\d+)px$/);
  if (m) {
    return +m[1];
  }
  return void 0;
};
function useBreakpoint(breakpoints) {
  const result = {};
  const map = /* @__PURE__ */ new Map();
  const current = ref();
  let sorted = [];
  const removeMedia = [];
  for (const key in breakpoints) {
    const bp = breakpoints[key];
    const width = getBreakpointWidth(bp);
    if (width !== void 0) {
      const r = ref(false);
      result[key] = r;
      map.set(width, {
        name: key,
        valid: r
      });
      sorted.push(width);
    } else {
      const { matches, remove: remove2 } = useMatchMedia(bp);
      result[key] = matches;
      removeMedia.push(remove2);
    }
  }
  sorted = sorted.sort((a, b) => b - a);
  const resize = isClient ? () => {
    const width = window.innerWidth;
    let c = void 0;
    for (let i = 0; i < sorted.length; i++) {
      const bp = sorted[i];
      const r = map.get(bp);
      r.valid.value = width >= bp;
      if (width >= bp && c === void 0) {
        c = r.name;
      }
    }
    current.value = c;
  } : NO_OP;
  const processResize = useDebounce(resize, 10);
  const remove = isClient ? () => window.removeEventListener("resize", processResize) : NO_OP;
  if (isClient) {
    onMounted(() => {
      resize();
      window.addEventListener("resize", processResize, PASSIVE_EV);
    });
    onUnmounted(() => {
      remove();
      removeMedia.forEach((x) => x());
    });
  }
  return {
    ...result,
    remove,
    current
  };
}
function useBreakpointChrome() {
  return useBreakpoint({
    mobileS: 320,
    mobileM: 375,
    mobileL: 425,
    tablet: 768,
    laptop: 1024,
    laptopL: 1440,
    desktop4K: 2560
  });
}
var BREAKPOINT_TAILWIND_KEY = Symbol("TAILWIND_BREAKPOINTS");
var defaultTailwindBreakpoint = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280
};
function isTailwind(t) {
  return isObject(t) && isObject(t.theme) && isObject(t.theme.screens);
}
function isRawScreen(t) {
  return isObject(t) && isString(t.raw);
}
function isRangeScreen(t) {
  if (!isObject(t))
    return false;
  return isString(t.min) || isString(t.max) || isNumber(t.min) || isNumber(t.max);
}
function sanitizeWidth(s) {
  return isNumber(s) ? s + "px" : s;
}
function screenRangeToBreakpoint(s) {
  if (!isRangeScreen(s)) {
    if (true) {
      console.warn("[useBreakpointTailwind] screen range provided is not valid");
    }
    return "";
  }
  const condition = [
    s.max && `max-width: ${sanitizeWidth(s.max)}`,
    s.min && `min-width: ${sanitizeWidth(s.min)}`
  ].filter(Boolean).join(" and ");
  return `(${condition})`;
}
function screenToBreakpoint(s) {
  const conditions = [];
  if (isArray(s)) {
    const bks = s.map(screenToBreakpoint);
    for (let i = 0; i < bks.length; i++) {
      const b = bks[i];
      conditions.push(...b);
    }
  } else if (isRawScreen(s)) {
    conditions.push(s.raw);
  } else if (isRangeScreen(s)) {
    conditions.push(screenRangeToBreakpoint(s));
  } else if (isString(s) || isNumber(s)) {
    conditions.push(`(min-width: ${sanitizeWidth(s)})`);
  } else {
    if (true) {
      console.warn("[useBreakpointTailwind] unknown type used for the breakpoint`");
    }
  }
  return conditions;
}
function setBreakpointTailwindCSS(breakpoints) {
  const bk = isTailwind(breakpoints) ? breakpoints.theme.screens : breakpoints;
  if (isTailwind(breakpoints)) {
    for (const k in bk) {
      if (bk.hasOwnProperty(k)) {
        const v = bk[k];
        if (isObject(v)) {
          bk[k] = screenToBreakpoint(bk[k]).join(" or ");
        } else if (isString(v)) {
          if (!v.endsWith("px")) {
            bk[k] = screenToBreakpoint(bk[k]).join(" or ");
          }
        }
      }
    }
  }
  const bp = useBreakpoint(bk);
  provide(BREAKPOINT_TAILWIND_KEY, bp);
  return bp;
}
function useBreakpointTailwindCSS(config) {
  return injectFactory(BREAKPOINT_TAILWIND_KEY, () => setBreakpointTailwindCSS(config || defaultTailwindBreakpoint));
}
var STORAGE_TEST_KEY = true ? "__storage_test__" : ":$";
function isQuotaExceededError(e, storage) {
  return e instanceof DOMException && // everything except Firefox
  (e.code === 22 || // Firefox
  e.code === 1014 || // test name field too, because code might not be present
  // everything except Firefox
  e.name === "QuotaExceededError" || // Firefox
  e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
  (storage && storage.length !== 0 || false);
}
function storageAvailable(storage) {
  try {
    if (!storage) {
      return false;
    }
    const x = STORAGE_TEST_KEY;
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (e) {
    return isQuotaExceededError(e, storage);
  }
}
function safeParse(serializer, value) {
  try {
    return serializer.parse(value);
  } catch {
    return value;
  }
}
var storageMap = void 0;
function useWebStorage(type, serializer = JSON, ms = 10) {
  const storage = isClient ? window[type] : void 0;
  const supported = storageAvailable(storage);
  const remove = () => storageMap.delete(type);
  if (!storageMap) {
    storageMap = /* @__PURE__ */ new Map();
    if (isClient) {
      window.addEventListener("storage", (e) => {
        if (e.newValue === e.oldValue) {
          return;
        }
        let webStore = storageMap.get("localStorage");
        if (e.storageArea === window.localStorage) {
          webStore = storageMap.get("localStorage");
        } else {
          webStore = storageMap.get("sessionStorage");
        }
        if (webStore && Object.keys(webStore.$syncKeys).length > 0) {
          if (e.key === null) {
            webStore.clear();
          } else if (webStore.$syncKeys[e.key]) {
            if (e.newValue === null) {
              webStore.removeItem(e.key);
            } else {
              webStore.updateItem(e.key, e.newValue);
            }
          }
        }
      });
    }
  }
  let store = storageMap.get(type);
  let quotaError;
  if (supported && storage) {
    if (!store) {
      quotaError = ref(false);
      store = {
        $refMap: /* @__PURE__ */ new Map(),
        $watchHandlers: /* @__PURE__ */ new Map(),
        $syncKeys: {},
        $quotaError: quotaError,
        key: storage.key,
        length: storage.length,
        setSync(key, sync) {
          if (sync) {
            this.$syncKeys[key] = true;
          } else {
            delete this.$syncKeys[key];
          }
        },
        save(key, value) {
          try {
            const oldValue = storage.getItem(key);
            const data = isString(value) ? value : serializer.stringify(value);
            storage.setItem(key, data);
            if (oldValue !== data && isClient && store.$syncKeys[key]) {
              window.dispatchEvent(new StorageEvent(key, {
                newValue: data,
                oldValue,
                storageArea: storage
              }));
            }
          } catch (e) {
            quotaError.value = isQuotaExceededError(e, storage);
          }
        },
        clear() {
          this.$refMap.forEach((_, k) => this.removeItem(k));
        },
        removeItem(k) {
          const item = this.$refMap.get(k);
          if (item) {
            item.value = void 0;
          }
          const stop = this.$watchHandlers.get(k);
          if (stop) {
            stop();
          }
          delete this.$syncKeys[k];
          this.$refMap.delete(k);
          storage.removeItem(k);
        },
        getItem(k) {
          const data = storage.getItem(k);
          if (!data) {
            return null;
          }
          return this.setItem(k, safeParse(serializer, data));
        },
        getRef(k) {
          const item = ref();
          let keyWatch = watch(wrap(k), (k2) => {
            const data = storage.getItem(k2);
            if (!data) {
              return item.value = null;
            }
            item.value = safeParse(serializer, data);
          }, {
            immediate: true,
            flush: "sync"
          });
          let valueWatch = watch(item, debounce((i) => {
            this.save(unwrap(k), i);
          }, ms), { deep: true, flush: "sync" });
          const fakeKey = Math.random().toString();
          this.$watchHandlers.set(fakeKey, () => {
            keyWatch();
            valueWatch();
          });
          this.$refMap.set(fakeKey, item);
          return item;
        },
        setItem(k, v) {
          const reference = wrap(v);
          this.$refMap.set(k, reference);
          this.save(k, v);
          const stop = watch(reference, debounce((r) => {
            this.save(k, r);
          }, ms), {
            immediate: false,
            deep: true
          });
          this.$watchHandlers.set(k, stop);
          return reference;
        },
        updateItem(k, data) {
          let r = this.$refMap.get(k);
          if (r) {
            r.value = safeParse(serializer, data);
          }
        }
      };
      storageMap.set(type, store);
    } else {
      quotaError = store.$quotaError;
    }
  } else {
    quotaError = ref(false);
    store = {};
  }
  return {
    supported,
    quotaError,
    store,
    remove
  };
}
function useLocalStorage(key, defaultValue, sync) {
  const { supported, store } = useWebStorage("localStorage");
  let remove = NO_OP;
  let clear = NO_OP;
  let setSync = NO_OP;
  let storage = void 0;
  if (supported && store) {
    setSync = (s) => store.setSync(unwrap(key), s);
    remove = () => store.removeItem(unwrap(key));
    clear = () => store.clear();
    storage = store.getRef(key);
    if (storage.value == null) {
      store.save(unwrap(key), defaultValue);
      storage.value = defaultValue;
    }
    watchEffect(() => {
      if (sync !== false) {
        setSync(true);
      }
    });
  } else {
    if (true) {
      console.warn("[localStorage] is not available");
    }
    storage = ref(defaultValue);
  }
  return {
    supported,
    storage,
    clear,
    remove,
    setSync
  };
}
function useSessionStorage(key, defaultValue, sync) {
  const { supported, store } = useWebStorage("sessionStorage");
  let remove = NO_OP;
  let clear = NO_OP;
  let setSync = FALSE_OP;
  let storage = void 0;
  if (supported && store) {
    if (true) {
      setSync = () => console.warn("sync is not supported, please `useLocalStorage` instead");
      if (sync) {
        setSync(sync);
      }
    }
    remove = () => store.removeItem(unwrap(key));
    clear = () => store.clear();
    storage = store.getRef(key);
    if (storage.value == null) {
      store.save(unwrap(key), defaultValue);
      storage.value = defaultValue;
    }
  } else {
    if (true) {
      console.warn("[sessionStorage] is not available");
    }
    storage = ref(defaultValue);
  }
  return {
    supported,
    storage,
    clear,
    remove,
    setSync
  };
}
var canUseLocalStorage = void 0;
function useStorage(key, defaultValue, sync) {
  if (canUseLocalStorage === void 0) {
    canUseLocalStorage = useWebStorage("localStorage").supported;
  }
  return canUseLocalStorage ? useLocalStorage(key, defaultValue, sync) : useSessionStorage(key, defaultValue, sync);
}
function usePagination(options) {
  const _currentPage = wrap(options.currentPage);
  const _pageSize = wrap(options.pageSize);
  const _offset = ref(0);
  const total = wrap(options.total);
  const offset = computed({
    get() {
      return _offset.value;
    },
    set(v) {
      if (!isNumber(v)) {
        if (true) {
          console.warn(`[offset] expected number but got: '${typeof v}' value: '${v}'`);
        }
        return;
      }
      _offset.value = Math.min(v, total.value);
    }
  });
  const currentPage = computed({
    get() {
      return _currentPage.value;
    },
    set(v) {
      if (!isNumber(v)) {
        if (true) {
          console.warn(`[currentPage] expected number but got: '${typeof v}' value: '${v}'`);
        }
        return;
      }
      _currentPage.value = minMax(v, 1, lastPage.value);
      offset.value = (_currentPage.value - 1) * pageSize.value;
    }
  });
  const pageSize = computed({
    get() {
      return _pageSize.value;
    },
    set(v) {
      if (!isNumber(v)) {
        if (true) {
          console.warn(`[pageSize] expected number but got: '${typeof v}' value: '${v}'`);
        }
        return;
      }
      _pageSize.value = v;
    }
  });
  const lastPage = computed(() => Math.ceil(total.value / pageSize.value));
  currentPage.value = _currentPage.value;
  const prev = () => --currentPage.value;
  const next = () => ++currentPage.value;
  const first = () => currentPage.value = 1;
  const last = () => currentPage.value = lastPage.value;
  watch(
    [total, pageSize],
    (_) => {
      if (currentPage.value > lastPage.value) {
        currentPage.value = lastPage.value;
      }
    },
    { immediate: false }
    // no need to run on first render
  );
  return {
    // Mutable state
    pageSize,
    total,
    currentPage,
    offset,
    // Computed
    lastPage,
    // Functions
    next,
    prev,
    first,
    last
  };
}
function useArrayPagination(array, options) {
  const arrayRef = wrap(array);
  const pagination = usePagination({
    ...{
      currentPage: 1,
      pageSize: 10
    },
    ...options,
    total: computed(() => arrayRef.value.length)
  });
  const result = computed(() => {
    const array2 = arrayRef.value;
    if (!Array.isArray(array2))
      return [];
    return array2.slice(pagination.offset.value, pagination.offset.value + pagination.pageSize.value);
  });
  return {
    ...pagination,
    result
  };
}
function useNow(options) {
  const SYNC_MS = 1e3;
  const ms = options && options.refreshMs || SYNC_MS;
  const sync = options && isBoolean(options.sync) ? options.sync : true;
  const fn = options && isFunction(options.timeFn) && options.timeFn || Date.now;
  if (true) {
    if (options && options.timeFn && isFunction(options.timeFn) === false) {
      console.warn("[useNow] timeFn param must be Function");
    }
  }
  let handler = void 0;
  let timeoutHandler = void 0;
  const now = ref(fn());
  const remove = () => {
    clearInterval(handler);
    clearTimeout(timeoutHandler);
  };
  const start = isClient ? () => handler = setInterval(() => now.value = fn(), ms) : NO_OP;
  if (sync) {
    const offset = SYNC_MS - (now.value - Math.floor(now.value / SYNC_MS) * SYNC_MS);
    timeoutHandler = setTimeout(start, offset);
  } else {
    start();
  }
  onUnmounted(remove);
  return {
    now,
    remove
  };
}
function useDateNow(options) {
  const refreshMs = options && options.refreshMs || 1e3;
  const sync = options && isBoolean(options.sync) ? options.sync : true;
  return useNow({
    refreshMs,
    sync,
    timeFn: Date.now
  });
}
function usePerformanceNow(options) {
  const refreshMs = options && options.refreshMs || 1e3;
  const sync = options && isBoolean(options.sync) ? options.sync : true;
  return useNow({
    refreshMs,
    sync,
    timeFn: () => performance.now()
  });
}
function useFormat(format, args) {
  return computed(() => {
    const f = unwrap(format);
    if (!args) {
      return f;
    }
    const r = isRef(args) ? reactive(args.value) : reactive(args);
    const regEx = /({?{[\w\s]*}?})/g;
    return f.replace(regEx, (s) => {
      const k = s.replace("{", "").replace("}", "").trim();
      if (s[0] === s[1] && s[0] === "{") {
        return `${k}`;
      }
      const v = isArray(r) ? r[+k] : r[k];
      return v === void 0 ? s : `${unwrap(v)}`;
    });
  });
}
function usePath(source, path, separator = ".", notFoundReturn = NO_OP) {
  return computed(() => {
    const s = unwrap(source);
    const p = unwrap(path);
    if (s === void 0)
      return notFoundReturn(p, s, p, s);
    if (!p) {
      return s;
    }
    const fragments = p.split(separator);
    let c = s;
    for (let i = 0; i < fragments.length; i++) {
      let fragmentPath = fragments[i];
      if (fragmentPath[fragmentPath.length - 1] === "]") {
        const r = /\[[`'"]?([^`'"\]]*)[`'"]?\]/g;
        let path2 = fragmentPath;
        let m = r.exec(path2);
        if (m) {
          let lastLen = m[0].length;
          let lastIndex = m.index - lastLen;
          let mi = 1;
          do {
            if (lastIndex + lastLen !== m.index) {
              if (true) {
                console.warn(`[usePath] invalid path "${fragments[i]}"`);
              }
            }
            lastIndex = m.index;
            lastLen = m[0].length;
            fragmentPath = fragmentPath.slice(0, -m[0].length);
            fragments.splice(i + mi, 0, m[1]);
            ++mi;
          } while (m = r.exec(path2));
          if (!fragmentPath && path2[0] === "[" && path2.length > 2) {
            continue;
          }
        } else {
          fragmentPath = "";
          console.warn(`[usePath] invalid path provided "${path2}"`);
        }
      }
      if (isObject(c)) {
        if (!fragmentPath) {
          if (true) {
            console.warn(`Path "${fragments.slice(0, i + 1).join(separator)}" doesn't exist on:`, source);
          }
          return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);
        }
        c = c[fragmentPath];
      } else {
        if (true) {
          console.warn(`Path "${fragments.slice(0, i + 1).join(separator)}" doesn't exist on:`, source);
        }
        return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);
      }
      if (!c) {
        if (true) {
          console.warn(`Path "${fragments.slice(0, i + 1).join(separator)}" doesn't exist on:`, source);
        }
        return notFoundReturn(fragments.slice(0, i + 1).join(separator), c, p, s);
      }
    }
    return c;
  });
}
function isValidation(v) {
  return typeof v.$value !== "undefined";
}
function isValidatorObject(v) {
  return isObject(v);
}
var buildValidationFunction = (r, f, m, handlers) => {
  const $promise = ref(null);
  const $pending = ref(false);
  const $error = ref();
  const $invalid = ref(false);
  let context = void 0;
  const onChange = (r2) => {
    const p = async () => {
      try {
        $pending.value = true;
        const result = f(r2, context);
        if (isPromise(result)) {
          $invalid.value = !await result;
        } else {
          $invalid.value = !result;
        }
        $error.value = $invalid.value ? m.value || true : void 0;
      } catch (e) {
        $invalid.value = true;
        throw e;
      } finally {
        $pending.value = false;
      }
    };
    $promise.value = p().catch((x) => {
      $error.value = unwrap(x);
      $invalid.value = true;
      return x;
    });
  };
  handlers.push((ctx) => {
    context = ctx;
    watch(() => {
      try {
        f(r.value, context);
      } catch (e) {
      }
      return r.value;
    }, onChange, { deep: true, immediate: true });
  });
  function $touch() {
    onChange(r.value);
  }
  return {
    $promise,
    $pending,
    $invalid,
    $error,
    $touch
  };
};
var buildValidationValue = (r, v, handlers) => {
  const { $message, $validator, ...$rest } = isValidatorObject(v) ? v : { $validator: v, $message: void 0 };
  const { $pending, $promise, $invalid, $error, $touch } = buildValidationFunction(r, $validator, ref($message), handlers);
  return {
    $pending,
    $error,
    $promise,
    $invalid,
    $message,
    $touch,
    ...$rest
  };
};
var buildValidation = (o, handlers) => {
  const r = {};
  const $value = isValidation(o) ? wrap(o.$value) : void 0;
  for (const k of Object.keys(o)) {
    if (k[0] === "$") {
      if (k === "$value") {
        r[k] = $value;
        const $dirty = ref(false);
        let dirtyWatch = NO_OP;
        const createDirtyWatcher = () => {
          dirtyWatch();
          dirtyWatch = watch($value, () => {
            $dirty.value = true;
            dirtyWatch();
          }, { immediate: false, deep: true });
        };
        createDirtyWatcher();
        r["$dirty"] = $dirty;
        r["$reset"] = () => {
          $dirty.value = false;
          createDirtyWatcher();
        };
        r["$touch"] = () => $dirty.value = true;
        r.toObject = () => unwrap($value);
        continue;
      } else {
        r[k] = o[k];
        continue;
      }
    }
    if ($value) {
      const validation = buildValidationValue($value, o[k], handlers);
      r[k] = validation;
    } else {
      const validation = buildValidation(o[k], handlers);
      let $anyDirty = void 0;
      let $errors;
      let $anyInvalid;
      let toObject = NO_OP;
      if (isValidation(validation)) {
        const validations = Object.keys(validation).filter((x) => x[0] !== "$").map((x) => validation[x]);
        $errors = computed(() => validations.map((x) => x.$error).map((x) => unwrap(x)).filter((x) => x !== void 0));
        $anyInvalid = computed(() => validations.some((x) => {
          return !!unwrap(x.$invalid);
        }));
        toObject = () => {
          return Object.keys(validation).filter((x) => x[0] !== "$").reduce((p, c) => {
            p[c] = validation[c].toObject();
            return p;
          }, {});
        };
      } else {
        const validations = Object.keys(validation).map((x) => validation[x]);
        $errors = computed(() => {
          return validations.map((x) => unwrap(x.$errors)).filter((x) => x !== void 0).filter((x) => {
            return x.some(Boolean);
          });
        });
        $anyDirty = computed(() => {
          return validations.some((x) => {
            return unwrap(x.$anyDirty) || isBoolean(unwrap(x.$dirty)) && unwrap(x.$dirty);
          });
        });
        $anyInvalid = computed(() => validations.some((x) => {
          return !!unwrap(x.$anyInvalid);
        }));
        toObject = () => {
          return Object.keys(validation).filter((x) => x[0] !== "$").reduce((p, c) => {
            p[c] = validation[c].toObject();
            return p;
          }, {});
        };
      }
      r[k] = {
        toObject,
        ...validation,
        $errors,
        $anyInvalid
      };
      if ($anyDirty) {
        r[k].$anyDirty = $anyDirty;
        const keys = Object.keys(r[k]).filter((x) => x[0] !== "$" && isObject(r[k][x]));
        r[k].$touch = () => {
          keys.forEach((m) => {
            const touch = r[k][m].$touch;
            if (touch) {
              touch();
            }
          });
        };
        r[k].$reset = () => {
          keys.forEach((m) => {
            const reset = r[k][m].$reset;
            if (reset) {
              reset();
            }
          });
        };
      }
    }
  }
  return r;
};
function useValidation(input) {
  const handlers = [];
  const validation = buildValidation({ input }, handlers);
  const validationInput = reactive(validation.input);
  handlers.forEach((x) => x(validationInput));
  return validationInput;
}
var I18n_ACCESS_SYMBOL = Symbol("I18n");
function useI18n(definition) {
  if (definition) {
    return setI18n(definition);
  } else
    return inject(I18n_ACCESS_SYMBOL);
}
function buildI18n(definition) {
  const locales = ref(Object.keys(definition.messages));
  const localeMessages = ref(definition.messages);
  const locale = ref(definition.locale);
  const i18n = ref({});
  let fallback = ref();
  const cache = {};
  const retrieveLocaleValue = (x) => {
    return ("__esModule" in x || x[Symbol.toStringTag] === "Module") && "default" in x ? x.default : x;
  };
  const loadLocale = (locale2, messages) => {
    if (cache[locale2]) {
      return cache[locale2];
    }
    const l = messages.value[locale2];
    if (!l) {
      return ref({});
    }
    let m = isFunction(l) ? l() : l;
    if (isPromise(m)) {
      return m.then((x) => {
        return cache[locale2] = wrap(retrieveLocaleValue(x));
      });
    }
    if (isFunction(l)) {
      return wrap(retrieveLocaleValue(m));
    }
    return cache[locale2] = computed(() => retrieveLocaleValue(messages.value[locale2]));
  };
  const shouldFallback = definition.fallback ? isBoolean(definition.notFoundFallback) ? definition.notFoundFallback : true : false;
  let fallbackIsPromise = false;
  if (shouldFallback) {
    const fallbackI18n = loadLocale(definition.fallback, localeMessages);
    if (isPromise(fallbackI18n)) {
      fallbackI18n.then((x) => {
        fallback.value = x.value;
      });
      fallbackIsPromise = true;
    } else {
      fallback.value = fallbackI18n.value;
    }
  } else {
    fallback.value = {};
  }
  const localeChangesCount = ref(0);
  watch(localeMessages, () => localeChangesCount.value++, {
    deep: true,
    immediate: false
  });
  watch([locale, fallback, localeChangesCount], ([l, fb, _]) => {
    if (l === definition.fallback && shouldFallback) {
      i18n.value = fb;
    } else {
      const setI18n2 = (v) => i18n.value = deepClone({}, fb, unwrap(v));
      const r = loadLocale(l, localeMessages);
      if (isPromise(r)) {
        r.then(setI18n2);
      } else {
        setI18n2(r);
      }
    }
  }, {
    immediate: !fallbackIsPromise
  });
  const $t = (path, args) => {
    if (definition.resolve) {
      return wrap(definition.resolve(i18n.value, path, args));
    }
    return useFormat(usePath(i18n, path, ".", (_, _1, p, _2) => p), args);
  };
  const $ts = (path, args) => {
    return $t(path, args).value;
  };
  const addLocale = (l, m) => {
    if (locales.value.indexOf(l) >= 0) {
      if (true) {
        console.warn(`[useI18n] Locale "${l}" already exists, overriding it...`);
      }
    } else {
      locales.value.push(l);
    }
    delete cache[l];
    {
      localeMessages.value[l] = m;
    }
  };
  const removeLocale = (l) => {
    const index = locales.value.indexOf(l);
    if (index >= 0) {
      const nextLocale = [
        locale.value,
        fallback.value && definition.fallback,
        ...locales.value
      ].find((x) => x && x !== l);
      if (nextLocale) {
        if (l === definition.fallback) {
          if (true) {
            console.warn(`[useI18n] removing default fallback locale "${l}"`);
          }
          fallback.value = void 0;
        }
        if (l === locale.value) {
          if (true) {
            console.warn(`[useI18n] removing current locale "${l}", setting current locale to "${nextLocale}"`);
          }
          locale.value = nextLocale;
        }
      } else {
        if (true) {
          console.error("[useI18n] No locales available to use");
        }
      }
      locales.value.splice(index, 1);
    } else {
      if (true) {
        console.warn(`[useI18n] Locale "${l}" doesn't exist`);
      }
    }
    {
      delete localeMessages.value[l];
    }
    delete cache[l];
  };
  return {
    locale,
    locales,
    i18n,
    $t,
    $ts,
    addLocale,
    removeLocale
  };
}
function setI18n(definition) {
  const r = buildI18n(definition);
  provide(I18n_ACCESS_SYMBOL, r);
  return r;
}
var SSR_TITLE_KEY = Symbol("SSR_TITLE_KEY");
function provideSSRTitle(app, title) {
  const r = wrap(title === void 0 ? "" : title);
  app.provide(SSR_TITLE_KEY, r);
  return r;
}
function useSSRTitle(defaultTitle) {
  const s = Symbol();
  const title = inject(SSR_TITLE_KEY, s);
  if (title === s) {
    if (true) {
      console.warn("[useSSRTitle] can't find SSRTitle have you forgotten calling `provideSSRTitle`?");
    }
    return ref(isString(defaultTitle) ? defaultTitle : "");
  }
  if (title === void 0) {
    return ref(isString(defaultTitle) ? defaultTitle : "");
  }
  if (isString(defaultTitle)) {
    title.value = defaultTitle;
  }
  return title;
}
function useTitle(overrideTitle = null) {
  if ((globalThis.import ? globalThis.import.meta.env.SSR : process.env.SSR) && !isClient) {
    return useSSRTitle(overrideTitle);
  }
  const title = ref(isString(overrideTitle) ? overrideTitle : document.title);
  const observer = new MutationObserver((m) => {
    title.value = m[0].target.textContent;
  });
  watch(title, (t, o) => {
    if (isString(t) && t !== o) {
      document.title = t;
    }
  }, {
    immediate: true,
    flush: "sync"
  });
  const titleElement = document.querySelector("title");
  observer.observe(titleElement, { childList: true });
  onUnmounted(() => observer.disconnect());
  return title;
}
var HYDRATION_KEY = Symbol("VUE_COMPOSABLE_HYDRATION_KEY");
var hydrationPlugin = {
  // @ts-ignore
  install(app) {
    const hydrating = ref(true);
    const h = readonly(hydrating);
    {
      app._context.provides[HYDRATION_KEY] = h;
      const appMount = app.mount;
      app.mount = (...args) => {
        const component = appMount(...args);
        hydrating.value = false;
        return component;
      };
    }
  }
};
function useHydration() {
  if (true) {
    const s = Symbol();
    const r = inject(HYDRATION_KEY, s);
    if (r === s) {
      console.warn("[useHydration] no hydration found, did you forget to `app.use(HydrationPlugin)`?");
    }
  }
  return inject(HYDRATION_KEY, computed(() => false));
}
function useValueSync(main, args) {
  const master = wrap(main);
  const list = arguments.length === 2 ? isRef(arguments[1]) && isArray(arguments[1].value) ? arguments[1] : ref([wrap(arguments[1])]) : ref(Array.from(arguments).slice(1).map((x) => wrap(x)));
  list.value.forEach((x) => {
    x.value = master.value;
  });
  let lastLen = list.value.length;
  watch([master, list], ([m, list2]) => {
    if (lastLen < list2.length) {
      list2.forEach((x) => {
        if (x.value !== m) {
          x.value = m;
        }
      });
      return;
    }
    lastLen = list2.length;
    for (const v of list2) {
      if (v.value !== m) {
        master.value = v.value;
        return;
      }
    }
  }, {
    deep: true
  });
  watch(master, (m) => {
    list.value.forEach((x) => x.value = m);
  }, {
    deep: true,
    flush: "sync"
  });
  return list;
}
function useTimeline(value, options) {
  const timeline = ref([]);
  const clone = options && options.clone ? options.clone : (x) => x;
  const maxLength = options && options.maxLength || MAX_ARRAY_SIZE;
  watch(value, (_, o) => {
    timeline.value.unshift({
      item: clone(o),
      date: /* @__PURE__ */ new Date()
    });
    if (timeline.value.length > maxLength) {
      timeline.value.pop();
    }
  }, {
    immediate: false,
    flush: "sync",
    // allow options to override defaults
    ...options
  });
  return readonly(timeline);
}
function useUndo(defaultValue, options) {
  const current = wrap(defaultValue);
  const timeline = ref([]);
  const position = ref(0);
  const maxLen = options && options.maxLength || MAX_ARRAY_SIZE;
  const clone = options && options.clone || ((t) => t);
  const prev = computed(() => {
    const p = position.value === 0 ? 1 : position.value;
    return timeline.value.slice(p);
  });
  const next = computed(() => {
    const p = position.value === 0 ? 1 : 0;
    return timeline.value.slice(p, position.value);
  });
  let addTimelineEvent = void 0;
  if (options && options.devtoolId) {
    const layer = useDevtoolsTimelineLayer(
      `useUndo:${options.devtoolId}`,
      options.devtoolId,
      3318463
      // TODO devtools fix color
    );
    addTimelineEvent = (time, data) => layer.addEvent({
      time,
      data: {
        value: data,
        prev: [...prev.value],
        next: [...next.value]
      },
      meta: {
        prev: [...prev.value],
        next: [...next.value]
      }
    });
  }
  watch(current, (c) => {
    if (timeline.value[position.value] === c) {
      return;
    }
    if (position.value > 0) {
      const pos = position.value;
      timeline.value.splice(0, pos);
      position.value = 0;
    }
    if (timeline.value.length > maxLen) {
      timeline.value.pop();
    }
    const v = clone(c);
    timeline.value.unshift(v);
    if (addTimelineEvent) {
      addTimelineEvent(Date.now(), c);
    }
  }, {
    ...options,
    immediate: true,
    flush: "sync"
  });
  const undo = (step = 1) => jump(step);
  const redo = (step = 1) => jump(-step);
  const jump = (delta) => {
    const s = Math.sign(delta) <= 0 ? Math.max(delta, -next.value.length) : Math.min(delta, prev.value.length);
    position.value += s;
    current.value = timeline.value[position.value];
    if (addTimelineEvent) {
      addTimelineEvent(Date.now(), clone(current.value));
    }
  };
  return {
    value: current,
    undo,
    redo,
    jump,
    prev,
    next
  };
}
function useMouseDistanceFromElement(el, options, wait) {
  let distance = void 0;
  let remove = NO_OP;
  if (isClient) {
    const { pageX, pageY, remove: removeMouseEvent } = useOnMouseMove(window, options, wait);
    distance = computed(() => {
      const elem = unwrap(el);
      if (!elem)
        return 0;
      return Math.floor(Math.sqrt(Math.pow(pageX.value - (elem.offsetLeft + elem.clientWidth / 2), 2) + Math.pow(pageY.value - (elem.offsetTop + elem.clientHeight / 2), 2)));
    });
    remove = removeMouseEvent;
  } else {
    distance = computed(() => -1);
  }
  return {
    distance,
    remove
  };
}
var VERSION = "1.0.0-beta.24";
var VUE_VERSION = "3";
var COMMIT = "cca1e18";
export {
  COMMIT,
  FALSE_OP,
  MAX_ARRAY_SIZE,
  NO_OP,
  PASSIVE_EV,
  SCROLL_LOCK_CLASS,
  UseDevtoolsApp,
  VERSION,
  VUE_VERSION,
  VueComposableDevtools,
  buildI18n,
  debounce,
  deepClone,
  exponentialDelay,
  exposeWorker,
  getCssVariableFor,
  getDevtools,
  hydrationPlugin,
  injectFactory,
  isArray,
  isBoolean,
  isClient,
  isDate,
  isElement,
  isFunction,
  isNull,
  isNumber,
  isObject,
  isPromise,
  isString,
  isSymbol,
  isUndefined,
  minMax,
  noDelay,
  promisedTimeout,
  provideSSRTitle,
  refDebounced,
  refShared,
  setBreakpointTailwindCSS,
  setCssVariableFor,
  setDevtools,
  setI18n,
  storageAvailable,
  unwrap,
  useArrayPagination,
  useBreakpoint,
  useBreakpointChrome,
  useBreakpointTailwindCSS,
  useBroadcastChannel,
  useCancellablePromise,
  useClipboard,
  useCssVariables,
  useCurrencyFormat,
  useDateNow,
  useDebounce,
  useDevtoolsComponentState,
  useDevtoolsInspector,
  useDevtoolsTimelineLayer,
  useEvent,
  useFetch,
  useFormat,
  useGeolocation,
  useHydration,
  useI18n,
  useIntersectionObserver,
  useInterval,
  useIntlDateTimeFormat,
  useIntlNumberFormat,
  useLanguage,
  useLocalStorage,
  useLockScroll,
  useMatchMedia,
  useMouseDistanceFromElement,
  useNetworkInformation,
  useNow,
  useOnMouseMove,
  useOnOutsidePress,
  useOnResize,
  useOnScroll,
  useOnline,
  usePageVisibility,
  usePagination,
  usePath,
  usePerformanceNow,
  usePromise,
  usePromiseLazy,
  useRetry,
  useSSRTitle,
  useSessionStorage,
  useShare,
  useSharedRef,
  useStorage,
  useTimeline,
  useTimeout,
  useTitle,
  useUndo,
  useVModel,
  useValidation,
  useValueSync,
  useWebSocket,
  useWebStorage,
  useWorker,
  useWorkerFunction,
  wrap
};
//# sourceMappingURL=vue-composable.js.map
