import { addPluginTemplate, extendPages, createResolver, defineNuxtModule } from '@nuxt/kit';
import chalk from 'chalk';
import logSymbols from 'log-symbols';
import path from 'path';
import { defu } from 'defu';
import { startCase, camelCase } from 'lodash-es';
import { nanoid } from 'nanoid/non-secure';
import prettier from 'prettier';
import fs, { existsSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'pathe';
import { mkdirp } from 'mkdirp';
import { readFile } from 'fs/promises';

class ModuleOptionsStore {
  plugin = false;
  strict = false;
  pathCheck = true;
  autoImport = false;
  rootDir = "";
  buildDir = "";
  srcDir = "";
  pagesDir = "";
  i18n = false;
  i18nOptions = null;
  i18nLocales = [];
  ignoreRoutes = [];
  updateOptions(options) {
    if (options.plugin != null)
      this.plugin = options.plugin;
    if (options.strict != null)
      this.strict = options.strict;
    if (options.autoImport != null)
      this.autoImport = options.autoImport;
    if (options.rootDir != null)
      this.rootDir = options.rootDir;
    if (options.srcDir != null)
      this.srcDir = options.srcDir;
    if (options.buildDir != null)
      this.buildDir = options.buildDir;
    this.pagesDir = path.join(this.srcDir, "pages");
    if (options.i18n != null)
      this.i18n = options.i18n;
    if (options.i18nOptions != null) {
      this.i18nOptions = defu(options.i18nOptions, {
        strategy: "prefix_except_default"
      });
      if (this.i18nOptions.strategy === "prefix_except_default" && !options.i18nOptions.defaultLocale) {
        console.error(
          logSymbols.error,
          "You have not set 'i18n.defaultLocale', it's required when using 'prefix_except_default' mode (default one)"
        );
      }
      if (options.i18nOptions.locales) {
        this.i18nLocales = options.i18nOptions.locales.map((l) => {
          if (typeof l === "string") {
            return l;
          } else {
            return l.code;
          }
        });
      }
    }
    if (options.pathCheck != null) {
      this.pathCheck = options.pathCheck;
    }
    if (options.ignoreRoutes) {
      this.ignoreRoutes = options.ignoreRoutes;
    }
    if (options.isDocumentDriven) {
      this.ignoreRoutes.push("[...slug].vue");
    }
  }
  get resolvedIgnoredRoutes() {
    return this.ignoreRoutes.map((file) => path.join(this.pagesDir, file));
  }
  getResolvedStrictOptions() {
    let resolved;
    if (typeof this.strict === "boolean") {
      if (this.strict) {
        resolved = {
          NuxtLink: {
            strictRouteLocation: true,
            strictToArgument: true
          },
          router: {
            strictRouteLocation: true,
            strictToArgument: true
          }
        };
      } else {
        resolved = {
          NuxtLink: {
            strictRouteLocation: false,
            strictToArgument: false
          },
          router: {
            strictRouteLocation: false,
            strictToArgument: false
          }
        };
      }
    } else {
      resolved = defu(this.strict, {
        NuxtLink: {
          strictRouteLocation: false,
          strictToArgument: false
        },
        router: {
          strictRouteLocation: false,
          strictToArgument: false
        }
      });
    }
    return resolved;
  }
}
const moduleOptionStore = new ModuleOptionsStore();

function createRoutesNamesListExport(routesList) {
  return `
  /**
   * Exhaustive list of all the available route names in the app
   * */
  export type RoutesNamesList = ${routesList.length ? routesList.map((m) => `'${m}'`).join("|\n") : '""'}`;
}

function createRoutesParamsRecordExport(routesParams) {
  return `
  /** 
   * Routes params are only required for the exact targeted route name,
   * vue-router behaviour allow to navigate between children routes without the need to provide all the params every time.
   * So we can't enforce params when navigating between routes, only a \`[xxx].vue\` page will have required params in the type definition
   * 
   * */
  export type RoutesParamsRecord = {
    ${routesParams.map(
    ({ name, params }) => `"${name}": ${params.length ? `{
                ${params.map(
      ({ key, required, catchAll }) => `"${key}"${required ? "" : "?"}: (string | number)${catchAll ? "[]" : ""}`
    ).join(",\n")}
        }` : "never"}`
  ).join(",\n")}
  }`;
}

function createRoutesNamedLocationsExport(routesParams) {
  return `
  /**
   * Discriminated union that will allow to infer params based on route name
   * It's used for programmatic navigation like router.push or <NuxtLink/>
   * */
  export type RoutesNamedLocations = 
    ${routesParams.length ? routesParams.map(
    ({ name, params }) => `{name: "${name}" ${params.length ? `, params${params.some((s) => s.required) ? "" : "?"}: {
          ${params.map(
      ({ key, required, catchAll }) => `"${key}"${required ? "" : "?"}: (string | number)${catchAll ? "[]" : ""}`
    ).join(",\n")}
        }` : ""}}`
  ).join("|\n") : "''"}
  `;
}

function createRoutesNamedLocationsResolvedExport(routesParams) {
  return `
  /**
   * Type returned by a resolved Route that will allow to type guard the route name.
   * By default the params are unknown
   * */
  export type RoutesNamedLocationsResolved = 
  {
    name: RoutesNamesList;
    params: unknown;
  } ${routesParams.length ? `& (
    ${routesParams.map(
    ({ name, params }) => `{name: "${name}" ${params.length ? `, params: {
                ${params.map(
      ({ key, notRequiredOnPage, catchAll }) => `"${key}"${notRequiredOnPage ? "?" : ""}: string${catchAll ? "[]" : ""}`
    ).join(",\n")}
        }` : ""}}`
  ).join("|\n")}
      )` : ""} 
  `;
}

function createRoutesParamsRecordResolvedExport(routesParams) {
  return `
  /** 
   * Record resolved used for resolved routes
   * 
   * */
  export type RoutesParamsRecordResolved = {
    ${routesParams.map(
    ({ name, params }) => `"${name}": ${params.length ? `{
                ${params.map(
      ({ key, notRequiredOnPage, catchAll }) => `"${key}"${notRequiredOnPage ? "?" : ""}: string${catchAll ? "[]" : ""}`
    ).join(",\n")}
        }` : "never"}`
  ).join(",\n")}
  }`;
}

function isItemLast(array, index) {
  return array ? index === array.length - 1 : false;
}
function returnIfTrue(condition, template, otherwise) {
  if (condition) {
    return template;
  }
  return otherwise ?? "";
}

function pascalCase(str) {
  return startCase(camelCase(str)).replace(/ /g, "");
}
function createRoutePathSchema(routePaths) {
  const paths = routePaths.filter((f) => !!f.path);
  return `export type RoutePathSchema = 
    ${paths.length ? paths.map((route) => `"${route.path}"`).join("|") : "any"}
  `;
}
function createLocaleRoutePathSchema(routePaths) {
  const paths = routePaths.filter((f) => !!f.path && !f.isLocale);
  return `export type LocaleRoutePathSchema = 
    ${paths.length ? paths.map((route) => `"${route.path}"`).join("|") : "any"}
  `;
}
function createValidatePathTypes(pathElements, routesList, withLocale = false) {
  let pathConditions = pathElements.map((m) => createTypeValidatePathCondition(m, withLocale)).filter((f) => {
    if (withLocale) {
      return !f.isLocale;
    }
    return true;
  });
  const conditionsList = pathConditions.map((m) => m.condition);
  return `
    ${pathConditions.length ? conditionsList.join("\n\n") : ""}

    export type Validate${returnIfTrue(
    withLocale,
    "Locale"
  )}Path<T extends string> = T extends string 
      ? T extends '/' 
        ? T 
         ${pathConditions.length ? `:${pathConditions.map((t) => `${t.typeName}<T> extends true ? T`).join(": ")}` : ""} 
      : string extends T
      ? T
      : ${pathConditions.length ? `\`Error: \${${pathConditions.map((t) => `${t.typeName}<T>`).join("|")}}\`` : "never"}
      : never;
  
    // RouteNameFromPath, RouteNameFromLocalePath
    export type RouteNameFrom${returnIfTrue(
    withLocale,
    "Locale"
  )}Path<T extends string> = T extends string 
      ? T extends '/' 
        ? "index"
         ${pathConditions.length ? `: ${pathConditions.filter((f) => routesList.includes(f.routeName)).length ? pathConditions.filter((f) => routesList.includes(f.routeName)).map((t) => `${t.typeName}<T> extends true ? "${t.routeName}"`).join(": ") : "any"} : never` : ": never"} 
       : never; 
  
        `;
}
function createTypeValidatePathCondition(elements, withLocale) {
  const seedName = pascalCase(elements[0][0].fullPath);
  const typeName = `Validate${returnIfTrue(withLocale, "Locale")}${seedName}`;
  const params = /* @__PURE__ */ new Map();
  const routeName = elements.flat()[0]?.routeName ?? "index";
  elements.flat().every((elem) => elem.type === "name");
  const isLocale = elements.flat()[0]?.isLocale ?? false;
  const condition = `type ${typeName}<T> = T extends \`/${elements.map((elementArray, index) => {
    return elementArray.map((elem) => {
      const isLast = index === elements.flat().length - 1;
      if (elem.type === "name" && isLast) {
        const id = `T${pascalCase(elem.content)}`;
        params.set(elem.id, id);
        return `${elem.content}\${infer ${id}}`;
      } else if (elem.type === "name") {
        return elem.content;
      } else if (elem.type === "param" || elem.type === "optionalParam") {
        const id = `T${pascalCase(elem.content)}`;
        params.set(elem.id, id);
        return `\${infer ${id}}`;
      } else if (elem.type === "catchAll") {
        return `\${string}`;
      }
    }).join("");
  }).join("/")}\`
    ? ${elements.flat().map((elem, index) => {
    let output = "";
    const isLast = index === elements.flat().length - 1;
    const isName = elem.type === "name";
    const isOptional = elem.type === "optionalParam";
    const isParam = elem.type === "param";
    elem.type === "catchAll";
    if (isName && isLast) {
      output = `ValidEndOfPath<${params.get(elem.id)}> extends false ? "End of path '${elem.fullPath}' is invalid" : true :`;
    } else if (isParam && isLast) {
      output = `ValidParam<${params.get(elem.id)}> extends false ? "Parameter {${elem.content}} of path '${elem.fullPath}' is invalid" : true :`;
    } else if (isParam) {
      output = `ValidStringPath<${params.get(elem.id)}> extends false ? "Parameter {${elem.content}} of path '${elem.fullPath}' is required" : `;
    } else if (isOptional && isLast) {
      output = `ValidParam<${params.get(elem.id)}, false> extends false ? "Parameter {${elem.content}} of path '${elem.fullPath}' is invalid" : true :`;
    } else if (isLast) {
      output += "true :";
    }
    return output;
  }).join("")} false ;`;
  return {
    typeName,
    condition,
    routeName,
    isLocale
  };
}

function createRoutesTypesFile({
  routesList,
  routesObjectTemplate,
  routesDeclTemplate,
  routesParams,
  routesPaths
}) {
  return (
    /* typescript */
    `
    ${createRoutesNamesListExport(routesList)}

    ${createRoutesParamsRecordExport(routesParams)}
    
    ${createRoutesParamsRecordResolvedExport(routesParams)}

    ${createRoutesNamedLocationsExport(routesParams)}

    ${createRoutesNamedLocationsResolvedExport(routesParams)}

    export type RoutesNamesListRecord = ${routesDeclTemplate};

    export const routesNames = ${routesObjectTemplate};
  `
  );
}

function createTypedRouterFile() {
  const strictOptions = moduleOptionStore.getResolvedStrictOptions();
  const { i18n, pathCheck } = moduleOptionStore;
  return (
    /* typescript */
    `
  
  import type { Ref } from 'vue';
  import type {
    NavigationFailure,
    RouteLocation,
    RouteLocationNormalizedLoaded,
    RouteLocationRaw,
    Router,
    RouteLocationPathRaw
  } from 'vue-router';
  import type {
    RoutesNamedLocations,
    RoutesNamedLocationsResolved,
    RoutesNamesList,
    RoutesParamsRecord,
    RoutesParamsRecordResolved,
  } from './__routes';
  ${returnIfTrue(
      pathCheck,
      `import type {TypedPathParameter, RouteNameFromPath} from './__paths';`
    )}
  import type { HasOneRequiredParameter } from './__types_utils';


  // - Routes location for navigation types (ex: router.push or navigateTo)


  export type NuxtRoute<T extends RoutesNamesList, P extends string, E extends boolean = false> = 
    | TypedRouteLocationRawFromName<T, P>
    ${returnIfTrue(!pathCheck && !strictOptions.NuxtLink.strictToArgument, ` | string`)}
    ${returnIfTrue(
      pathCheck && strictOptions.NuxtLink.strictToArgument,
      ` | (E extends true ? string : never)`
    )}
    ${returnIfTrue(
      pathCheck && !strictOptions.NuxtLink.strictToArgument,
      ` | (E extends true ? string : TypedPathParameter<P>)`
    )}

  /** 
   * RouteLocationRaw with discrimanated name and params properties 
   * {@link RouteLocationRaw}
   * */
  export type TypedRouteLocationRaw<T extends string = string> =
  | (Omit<Exclude<RouteLocationRaw, string>, 'name' | 'params'> & RoutesNamedLocations)
  | Omit<RouteLocationPathRaw, 'path'>
  ${returnIfTrue(
      pathCheck && !strictOptions.router.strictRouteLocation,
      `& {path?: TypedPathParameter<T>}`
    )}
  ${returnIfTrue(!pathCheck && !strictOptions.router.strictToArgument, ` | string`)}
  ;
  

  /**
   * Alternative version of {@link TypedRouteLocationRaw} but with a name generic
   */
  export type TypedRouteLocationRawFromName<T extends RoutesNamesList, P extends string = string> =
  | (Omit<Exclude<RouteLocationRaw, string>, 'name' | 'params'> & TypedLocationAsRelativeRaw<T>)
  | Omit<RouteLocationPathRaw, 'path'>
  ${returnIfTrue(
      pathCheck && !strictOptions.router.strictRouteLocation,
      `& {path?: TypedPathParameter<P>}`
    )}
  ${returnIfTrue(!pathCheck && !strictOptions.router.strictToArgument, ` | string`)}
  ${returnIfTrue(
      pathCheck && strictOptions.router.strictToArgument,
      `| (E extends true ? string : void)`
    )}


  /** 
   * Generic providing inference and dynamic inclusion of \`params\` property
   * {@link import('vue-router').LocationAsRelativeRaw} 
   * */
  export type TypedLocationAsRelativeRaw<T extends RoutesNamesList> = {
    name?: T;
  } & ([RoutesParamsRecord[T]] extends [never]
    ? {}
    : HasOneRequiredParameter<T> extends false
    ? { params?: RoutesParamsRecord[T] }
    : { params: RoutesParamsRecord[T] });

  
   /** 
   * Used for type assertion:
   * 
   * @usage
   * 
   * \`\`\`ts
   *  const myRoute = '/foo' as TypedRouteLocation;
   * \`\`\`
   * */
  export type TypedRouteLocation<T extends '/' = '/'> =
  TypedRouteLocationRawFromName<any, T>
  ${returnIfTrue(!pathCheck && !strictOptions.router.strictToArgument, ` & string`)}
  ${returnIfTrue(pathCheck && !strictOptions.router.strictToArgument, `& TypedPathParameter<T>`)}
  ;

  
  /** Augmented Router with typed methods
   * {@link Router}
   */
  export interface TypedRouter
    extends Omit<Router, 'removeRoute' | 'hasRoute' | 'resolve' | 'push' | 'replace' | 'currentRoute'> {
    readonly currentRoute: Ref<TypedRoute>;
    /**
     * Remove an existing route by its name.
     *
     * @param name - Name of the route to remove
     */
    removeRoute(name: RoutesNamesList): void;
    /**
     * Checks if a route with a given name exists
     *
     * @param name - Name of the route to check
     */
    hasRoute(name: RoutesNamesList): boolean;
    /**
     * Returns the {@link RouteLocation | normalized version} of a
     * {@link RouteLocationRaw | route location}. Also includes an \`href\` property
     * that includes any existing \`base\`. By default the \`currentLocation\` used is
     * \`route.currentRoute\` and should only be overriden in advanced use cases.
     *
     * @param to - Raw route location to resolve
     * @param currentLocation - Optional current location to resolve against
     */
    resolve<T extends RoutesNamesList, P extends string>(
      to: TypedRouteLocationRawFromName<T, P>,
      currentLocation?: TypedRouteLocationRaw
    ): TypedRouteLocationFromName<T>;
    ${returnIfTrue(
      pathCheck && !strictOptions.router.strictToArgument,
      `resolve<T extends string>(to: TypedPathParameter<T>, currentLocation?: TypedRouteLocationRaw): TypedRouteLocationFromName<RouteNameFromPath<T>>;`
    )}
    /**
     * Programmatically navigate to a new URL by pushing an entry in the history
     * stack.
     *
     * @param to - Route location to navigate to
     */
    push<T extends RoutesNamesList, P extends string>(to: NuxtRoute<T, P>): Promise<NavigationFailure | void | undefined>;
    /**
     * Programmatically navigate to a new URL by replacing the current entry in
     * the history stack.
     *
     * @param to - Route location to navigate to
     */
    replace<T extends RoutesNamesList, P extends string>(to: NuxtRoute<T, P>): Promise<NavigationFailure | void | undefined>;
  }

  



  // - Resolved normalized routes for current Location (ex: useRoute and currentRoute)
  
  

  /**
   * Clone of {@link RouteLocationNormalizedLoaded} with a discriminated union for name and params
   */
  export type TypedRoute = Omit<RouteLocationNormalizedLoaded, 'name' | 'params'> &
    RoutesNamedLocationsResolved;

  /**
   * Clone of {@link TypedRoute} with generic param for route name that can dynamicaly add params property
   */
  export type TypedRouteFromName<T extends RoutesNamesList> = Omit<
    RouteLocationNormalizedLoaded,
    'name' | 'params'
  > &
  TypedResolvedMatcherLocation<T>;

  /** 
   * Generic providing inference and dynamic inclusion of \`params\` property
   * {@link import('vue-router').LocationAsRelativeRaw} 
   * */
  export type TypedResolvedMatcherLocation<T extends RoutesNamesList> = {
    name: T;
  } & ([RoutesParamsRecordResolved[T]] extends [never] ? {} : { params: RoutesParamsRecordResolved[T] });
  

  /** 
   * Clone of {@link RouteLocation} with generic param for route name that can dynamicaly add params property
   * Used by Router.resolve
   * */
  export type TypedRouteLocationFromName<T extends RoutesNamesList> = TypedRouteFromName<T> & {href: string};
  `
  );
}

function createTypedRouterDefinitionFile() {
  moduleOptionStore.getResolvedStrictOptions();
  const { plugin, autoImport, i18n, pathCheck } = moduleOptionStore;
  return (
    /* typescript */
    `
    
    import type { NuxtLinkProps, PageMeta } from 'nuxt/app';
    import NuxtLink from 'nuxt/dist/app/components/nuxt-link';
    import type { RouteLocationRaw, RouteLocationPathRaw } from 'vue-router';
    import type { RoutesNamedLocations, RoutesNamesListRecord, RoutesNamesList } from './__routes';
    import type {TypedRouter, TypedRoute, TypedRouteLocationRawFromName, TypedLocationAsRelativeRaw, NuxtRoute} from './__router';
    import { useRoute as _useRoute } from './__useTypedRoute';
    import { useRouter as _useRouter } from './__useTypedRouter';
    import { useLink as _useLink } from './__useTypedLink';
    import { navigateTo as _navigateTo } from './__navigateTo';
    ${returnIfTrue(
      i18n,
      `import { useLocalePath as _useLocalePath, useLocaleRoute as _useLocaleRoute} from './__i18n-router';
      import type {TypedNuxtLinkLocale} from './__NuxtLinkLocale'`
    )}

    import {definePageMeta as _definePageMeta} from './__definePageMeta';

    ${returnIfTrue(pathCheck, `import type {TypedPathParameter} from './__paths';`)}


    declare global {
 
      ${returnIfTrue(
      autoImport,
      /* typescript */
      `
            const useRoute: typeof _useRoute;
            const useRouter: typeof _useRouter;
            const useLink: typeof _useLink;
            const navigateTo: typeof _navigateTo;
            const definePageMeta: typeof _definePageMeta;
            
            ${returnIfTrue(
        i18n,
        /* typescript */
        `
              const useLocalePath: typeof _useLocalePath;
              const useLocaleRoute: typeof _useLocaleRoute;
            `
      )}
          `
    )}
    }
    
    type TypedNuxtLinkProps<
    T extends RoutesNamesList,
    P extends string,
    E extends boolean = false> = Omit<NuxtLinkProps, 'to' | 'external'> &
     {
      to: NuxtRoute<T, P, E>,
      external?: E
      }
    
        
          
    export type TypedNuxtLink = new <T extends RoutesNamesList, P extends string, E extends boolean = false>(props: TypedNuxtLinkProps<T, P, E>) => Omit<
      typeof NuxtLink,
      '$props'
    > & {
      $props: TypedNuxtLinkProps<T, P, E>;
    };
    
    declare module 'vue' {
      interface GlobalComponents {
        NuxtLink: TypedNuxtLink;
        ${returnIfTrue(i18n, ` NuxtLinkLocale: TypedNuxtLinkLocale;`)}
      }
    }

    ${returnIfTrue(
      plugin,
      /* typescript */
      `
          interface CustomPluginProperties {
            $typedRouter: TypedRouter,
            $typedRoute: TypedRoute,
            $routesNames: RoutesNamesListRecord
          }
          declare module '#app' {
            interface NuxtApp extends CustomPluginProperties {}
          }
          declare module 'vue' {
            interface ComponentCustomProperties extends CustomPluginProperties {}
          }
        `
    )}
  `
  );
}

function createIndexFile() {
  const { i18n, i18nOptions, pathCheck } = moduleOptionStore;
  const hasPrefixStrategy = i18n && i18nOptions?.strategy !== "no_prefix";
  return (
    /* typescript */
    `

    export type {
      TypedLocationAsRelativeRaw,
      TypedResolvedMatcherLocation,
      TypedRoute,
      TypedRouteFromName,
      TypedRouteLocation,
      TypedRouteLocationFromName,
      TypedRouteLocationRaw,
      TypedRouteLocationRawFromName,
      TypedRouter,
      NuxtRoute
    } from './__router';
    export { routesNames } from './__routes';
    export type {
      RoutesNamedLocations,
      RoutesNamedLocationsResolved,
      RoutesNamesList,
      RoutesNamesListRecord,
      RoutesParamsRecord,
    } from './__routes';
    export { useRoute } from './__useTypedRoute';
    export { useRouter } from './__useTypedRouter';
    export { useLink } from './__useTypedLink';
    export { navigateTo } from './__navigateTo';
    export { definePageMeta } from './__definePageMeta';
    export { helpers } from './__helpers';
    
    ${returnIfTrue(
      pathCheck,
      `export type { ValidatePath, RoutePathSchema, TypedPathParameter, RouteNameFromPath, ${returnIfTrue(
        hasPrefixStrategy,
        `TypedLocalePathParameter`
      )} } from './__paths';`
    )}
    ${returnIfTrue(
      i18n,
      `export {useLocalePath, useLocaleRoute} from './__i18n-router';
      export type {TypedToLocalePath, TypedLocaleRoute, I18nLocales} from './__i18n-router';`
    )}

    
  `
  );
}

function createPluginFile() {
  return (
    /* typescript */
    `
  
  import { defineNuxtPlugin, useRouter, useRoute } from '#imports';
  import {TypedRouter, TypedRoute, routesNames} from '@typed-router';

  export default defineNuxtPlugin(() => {
    const router = useRouter();
    const route = useRoute();

    return {
      provide: {
        typedRouter: router as TypedRouter,
        typedRoute: route as TypedRoute,
        routesNames,
      },
    };
  });
  `
  );
}

function createUseTypedRouteFile() {
  return (
    /* typescript */
    `
  import { useRoute as defaultRoute } from '#imports';
  import type { RoutesNamesList } from './__routes';
  import type {TypedRoute, TypedRouteFromName} from './__router'

  /**
   * Typed clone of \`useRoute\`
   *
   * @exemple
   *
   * \`\`\`ts
   * const route = useRoute();
   * \`\`\`
   *
   * \`\`\`ts
   * const route = useRoute('my-route-with-param-id');
   * route.params.id // autocompletes!
   * \`\`\`
   *
   * \`\`\`ts
   * const route = useRoute();
   * if (route.name === 'my-route-with-param-id') {
   *    route.params.id // autocompletes!
   * }
   * \`\`\`
   */
  export function useRoute<T extends RoutesNamesList = never>(
    name?: T
  ): [T] extends [never] ? TypedRoute : TypedRouteFromName<T> {
    const route = defaultRoute();

    return route as any;
  }
`
  );
}

function createUseTypedRouterFile() {
  return (
    /* typescript */
    `
  
  import { useRouter as defaultRouter } from '#imports';
  import type { TypedRouter } from './__router';

  /** 
   * Typed clone of \`useRouter\`
   * 
   * @exemple
   * 
   * \`\`\`ts
   * const router = useRouter();
   * \`\`\`
   */
  export function useRouter(): TypedRouter {
    const router = defaultRouter();

    return router;
  };

  `
  );
}

function createUseTypedLinkFile() {
  const strictOptions = moduleOptionStore.getResolvedStrictOptions();
  const { pathCheck } = moduleOptionStore;
  return (
    /* typescript */
    `
  
  import { useLink as defaultLink } from '#imports';
  import type {MaybeRef, Ref} from 'vue';
  import type { NavigateToOptions } from 'nuxt/dist/app/composables/router';
  import type { NavigationFailure } from 'vue-router';
  import type { TypedRouteLocationRawFromName, TypedRouteFromName, TypedRoute } from './__router';
  import type { RoutesNamesList } from './__routes';
  ${returnIfTrue(
      pathCheck,
      `import type {TypedPathParameter, RouteNameFromPath} from './__paths';`
    )}


  type LinkedRoute<T extends RoutesNamesList> = {
    route: ComputedRef<TypedRouteFromName<T> & {
        href: string;
    }>;
    href: ComputedRef<string>;
    isActive: ComputedRef<boolean>;
    isExactActive: ComputedRef<boolean>;
    navigate: (e?: MouseEvent) => Promise<void | NavigationFailure>;
};


  interface UseLinkFunction {
    <T extends RoutesNamesList, P extends string>(props: {
      to: TypedRouteLocationRawFromName<T, P>;
      replace?: MaybeRef<boolean>;
    }): LinkedRoute<T>;
    <T extends RoutesNamesList, P extends string>(props: {
      to: Ref<TypedRouteLocationRawFromName<T, P>>;
      replace?: MaybeRef<boolean>;
    }): LinkedRoute<T>;
    
    ${returnIfTrue(
      pathCheck && !strictOptions.router.strictToArgument,
      `<P extends string>(
       props: {
        to: TypedPathParameter<P>,
        replace?: MaybeRef<boolean>
       }
      ) : LinkedRoute<RouteNameFromPath<P>>
      <P extends string>(props: {
        to: Ref<TypedPathParameter<P>>;
        replace?: MaybeRef<boolean>;
      }): LinkedRoute<RouteNameFromPath<P>>;
      
      `
    )}
  }

  /** 
   * Typed clone of \`useLink\`
   * 
   * @exemple
   * 
   * \`\`\`ts
   * const router = useLink(props);
   * \`\`\`
   */
  export const useLink: UseLinkFunction = defaultLink as any;

  `
  );
}

function createNavigateToFile() {
  const { router } = moduleOptionStore.getResolvedStrictOptions();
  const { pathCheck } = moduleOptionStore;
  return (
    /* typescript */
    `
    import { navigateTo as defaultNavigateTo } from '#imports';
    import type { NavigateToOptions } from 'nuxt/dist/app/composables/router';
    import type { NavigationFailure } from 'vue-router';
    import type { TypedRouteLocationRawFromName, TypedRouteFromName, TypedRoute } from './__router';
    import type { RoutesNamesList } from './__routes';
    ${returnIfTrue(
      pathCheck,
      `import type {TypedPathParameter, RouteNameFromPath} from './__paths';`
    )}

    type TypedNavigateToOptions<E extends boolean> = Omit<NavigateToOptions, 'external'> & {
      external?: E
    }

    /** 
   * Typed clone of \`navigateTo\`
   * 
   * @exemple
   * 
   * \`\`\`ts
   * const resolved = navigateTo({name: 'foo', params: {foo: 'bar'}});
   * \`\`\`
   */
  

  interface NavigateToFunction {
    <T extends RoutesNamesList, P extends string, E extends boolean = false>(
      to: TypedRouteLocationRawFromName<T, P>,
      options?: TypedNavigateToOptions<E>
    ) : Promise<void | NavigationFailure | TypedRouteFromName<T>>
    ${returnIfTrue(
      pathCheck && !router.strictToArgument,
      `<T extends string, E extends boolean = false>(
        to: (E extends true ? string : TypedPathParameter<T>),
        options?: TypedNavigateToOptions<E>
      ) : Promise<void | NavigationFailure | TypedRouteFromName<RouteNameFromPath<T>>>`
    )}
  }
  
  export const navigateTo: NavigateToFunction = defaultNavigateTo as any;

  `
  );
}

function createTypeUtilsRuntimeFile() {
  return (
    /* typescript */
    `
  
  import { RoutesNamesList, RoutesParamsRecord } from './__routes';

  // - Type utils
  export type ExtractRequiredParameters<T extends Record<string, any>> = Pick<
    T,
    { [K in keyof T]: undefined extends T[K] ? never : K }[keyof T]
  >;
  
  export type HasOneRequiredParameter<T extends RoutesNamesList> = [RoutesParamsRecord[T]] extends [
    never
  ]
    ? false
    : [keyof ExtractRequiredParameters<RoutesParamsRecord[T]>] extends [undefined]
    ? false
    : true;
  `
  );
}

function createi18nRouterFile() {
  const { router, NuxtLink } = moduleOptionStore.getResolvedStrictOptions();
  const { i18nOptions, pathCheck, i18nLocales } = moduleOptionStore;
  const LocalePathType = i18nOptions?.strategy === "no_prefix" ? "TypedPathParameter" : "TypedLocalePathParameter";
  return (
    /* typescript */
    `
  import type { RouteLocationRaw } from 'vue-router';
  import { useLocalePath as _useLocalePath, useLocaleRoute as _useLocaleRoute} from '#imports';
  import type {TypedRouteLocationRawFromName, TypedLocationAsRelativeRaw, TypedRouteFromName} from './__router';
  import type {RoutesNamesList} from './__routes';
  ${returnIfTrue(
      pathCheck,
      `import type {TypedLocalePathParameter, TypedPathParameter, RouteNameFromLocalePath} from './__paths';`
    )}

  export type I18nLocales = ${i18nLocales?.length ? i18nLocales.map((loc) => `"${loc}"`).join("|") : "string"};


  export type NuxtLocaleRoute<T extends RoutesNamesList, P extends string, E extends boolean = false> = 
    | TypedRouteLocationRawFromName<T, P>
    ${returnIfTrue(!pathCheck && !NuxtLink.strictToArgument, ` | string`)}
    ${returnIfTrue(pathCheck && NuxtLink.strictToArgument, ` | (E extends true ? string : never)`)}
    ${returnIfTrue(
      pathCheck && !NuxtLink.strictToArgument,
      ` | (E extends true ? string : ${LocalePathType}<P>)`
    )}

  export interface TypedToLocalePath {
    <T extends RoutesNamesList, P extends string>(
      to: TypedRouteLocationRawFromName<T, P>,
      locale?: I18nLocales | undefined
    ) : [T] extends [never] ? string : Required<
    (Omit<Exclude<RouteLocationRaw, string>, 'name' | 'params'> & TypedLocationAsRelativeRaw<T>)
    >
    ${returnIfTrue(
      pathCheck && !router.strictToArgument,
      `<T extends string>(
      to: ${LocalePathType}<T>,
      locale?: I18nLocales | undefined
    ) : [T] extends [never] ? string : Required<TypedRouteLocationRawFromName<RouteNameFromLocalePath<T>, T>>;`
    )}
  }

  export function useLocalePath(): TypedToLocalePath {
     return _useLocalePath() as any;
  }
  
  export interface TypedLocaleRoute {
    <T extends RoutesNamesList, P extends string>(to: TypedRouteLocationRawFromName<T, P>, locale?: I18nLocales | undefined) : TypedRouteFromName<T>
    ${returnIfTrue(
      pathCheck && !router.strictToArgument,
      ` <T extends string>(to: ${LocalePathType}<T>, locale?: I18nLocales | undefined) : TypedRouteFromName<RouteNameFromLocalePath<T>>;`
    )}
  }


  export function useLocaleRoute(): TypedLocaleRoute {
    return _useLocaleRoute() as any;
  }

  `
  );
}

const routeParamExtractRegxp = /(:(\w+)(\(\.[^(]\)[*+]?)?(\?)?)+/g;
function extractParamsFromPathDecl(path) {
  let params = [];
  let matches;
  do {
    matches = routeParamExtractRegxp.exec(path);
    if (matches) {
      const [_, mtch, key, catchAll, optional] = matches;
      if (mtch) {
        const _param = {
          name: key,
          optional: !!optional,
          catchAll: !!catchAll
        };
        params.push(_param);
      }
    }
  } while (matches);
  return params;
}

function extractRouteParamsFromPath(path, isIndexFileForRouting, previousParams) {
  const params = extractParamsFromPathDecl(path);
  let allMergedParams = params.map(
    ({ name, optional, catchAll }) => ({
      key: name,
      required: !optional,
      notRequiredOnPage: optional,
      catchAll
    })
  );
  if (previousParams?.length) {
    allMergedParams = previousParams.map((m) => ({ ...m, required: false })).concat(allMergedParams);
  }
  if (!params.length && isIndexFileForRouting) {
    const lastItem = allMergedParams[allMergedParams.length - 1];
    if (lastItem) {
      lastItem.required = true;
    }
  }
  return allMergedParams;
}

const ExtractRegex = /(^(\/)?([^:/]+)?(:(\w+)(\((.*)\)[*+]?)?(\?)?)*([^:/]+)?)+/g;
function destructurePath(path, route) {
  let allPathElements = [];
  let _path = `${path}`;
  do {
    const { pathElements, strippedPath } = extractPathElements(_path, route);
    allPathElements = allPathElements.concat(pathElements);
    _path = _path.replace(strippedPath, "");
  } while (_path.length);
  return allPathElements;
}
function extractPathElements(partOfPath, route) {
  let pathElements = [];
  let strippedPath = "";
  let matches;
  matches = ExtractRegex.exec(partOfPath);
  if (matches) {
    const [_, mtch, slash, path1, paramDef, key, catchAll, parentheseContent, optional, path2] = matches;
    if (mtch) {
      strippedPath = mtch;
      const sharedProperties = {
        fullPath: route.path,
        routeName: route.name,
        isLocale: route.isLocale
      };
      if (path1) {
        pathElements.push({
          type: "name",
          content: path1,
          id: nanoid(6),
          ...sharedProperties
        });
      }
      if (key) {
        pathElements.push({
          type: catchAll && parentheseContent ? "catchAll" : optional ? "optionalParam" : "param",
          content: key,
          id: nanoid(6),
          ...sharedProperties
        });
      }
      if (path2) {
        pathElements.push({
          type: "name",
          content: path2,
          id: nanoid(6),
          ...sharedProperties
        });
      }
    }
  }
  return { pathElements, strippedPath };
}

function createPathsFiles({ routesPaths, routesList }) {
  const { i18n, i18nOptions } = moduleOptionStore;
  const hasPrefixStrategy = i18n && i18nOptions?.strategy !== "no_prefix";
  const filteredRoutesPaths = routesPaths.filter((route) => !routesPaths.find((r) => `${route.path}/` === r.path)).map((route) => ({
    ...route,
    path: route.path.replace(/\(\)/g, "")
  })).sort((a, b) => {
    const pathCountA = a.path.split("/");
    const pathCountB = b.path.split("/");
    pathCountA.splice(0, 1);
    pathCountB.splice(0, 1);
    const maxIndex = Math.max(pathCountA.length, pathCountB.length) - 1;
    let order = 0;
    let index = 0;
    let alphabetOrder;
    let hasElement;
    let hasParam;
    let indexOfParam;
    do {
      alphabetOrder = pathCountA[index]?.localeCompare(pathCountB[index]);
      hasElement = (pathCountA[index] != null ? 1 : 0) - (pathCountB[index] != null ? 1 : 0);
      hasParam = (pathCountA[index]?.includes(":") ? 1 : 0) - (pathCountB[index]?.includes(":") ? 1 : 0);
      indexOfParam = pathCountB[index]?.indexOf(":") - pathCountA[index]?.indexOf(":");
      if (alphabetOrder !== 0 && index === 0) {
        order = alphabetOrder;
        break;
      } else {
        if (hasElement !== 0) {
          order = hasElement;
          break;
        } else if (hasParam !== 0) {
          order = hasParam;
          break;
        } else if (hasParam === 0 && indexOfParam !== 0) {
          order = indexOfParam;
          break;
        } else if (alphabetOrder !== 0) {
          order = alphabetOrder;
          break;
        }
      }
      index = index + 1;
    } while (index < maxIndex);
    return order;
  });
  const pathElements = filteredRoutesPaths.filter((f) => f.path && f.path !== "/").map((route) => {
    return route.path.split("/").filter((f) => f.length).map((m) => destructurePath(m, route));
  }).filter((f) => f.length);
  const validatePathTypes = createValidatePathTypes(pathElements, routesList);
  const validateLocalePathTypes = createValidatePathTypes(pathElements, routesList, true);
  return (
    /* typescript */
    `
    
  ${createRoutePathSchema(filteredRoutesPaths)};

  ${returnIfTrue(hasPrefixStrategy, createLocaleRoutePathSchema(filteredRoutesPaths))}

  type ValidStringPath<T> = T extends \`\${string} \${string}\` ? false : T extends '' ? false : true;

  type ValidParam<T, R extends boolean = true> = T extends \`\${infer A}/\${infer B}\`
  ? A extends \`\${string} \${string}\`
    ? false
    : A extends \`?\${string}\`
    ? false
    : A extends \`\${string} \${string}\`
    ? false
    : A extends ''
    ? B extends ''
      ? true
      : false
    : B extends \`?\${string}\`
    ? false
    : B extends \`#\${string}\`
    ? true
    : B extends ''
    ? true
    : false
  : R extends true
  ? T extends ''
    ? false
    : ValidParam<T, false>
  : T extends \`?\${string}\`
  ? false
  : T extends \`\${string} \${string}\`
  ? false
  : true;

  type ValidEndOfPath<T> = T extends \`/\`
    ? true
    : T extends ''
    ? true
    : T extends \`\${string} \${string}\`
    ? false 
    : T extends \`?\${string}\`
    ? true
    : T extends \`#\${string}\`
    ? true
    : false;

  ${validatePathTypes}
  ${returnIfTrue(hasPrefixStrategy, validateLocalePathTypes)}


  export type TypedPathParameter<T extends string> = ValidatePath<T> | RoutePathSchema;
  ${returnIfTrue(
      hasPrefixStrategy,
      `export type TypedLocalePathParameter<T extends string> = ValidateLocalePath<T> | LocaleRoutePathSchema;`
    )}

  `
  );
}

function createDefinePageMetaFile() {
  const strictOptions = moduleOptionStore.getResolvedStrictOptions();
  const { pathCheck } = moduleOptionStore;
  return (
    /* typescript */
    `
  
  import { definePageMeta as defaultDefinePageMeta } from '#imports';
  import type {PageMeta, NuxtError} from 'nuxt/app'
  import type {TypedRouteFromName, TypedRoute, TypedRouteLocationRawFromName, TypedRouteLocationRaw} from './__router';
  import type {RoutesNamesList} from './__routes';
  ${returnIfTrue(pathCheck, `import type {TypedPathParameter} from './__paths';`)}

  type FilteredPageMeta = {
    [T in keyof PageMeta as [unknown] extends [PageMeta[T]] ? never : T]: PageMeta[T];
  }

  export type TypedPageMeta = Omit<FilteredPageMeta, 'redirect' | 'validate' | 'key'> & {
    /**
     * Validate whether a given route can validly be rendered with this page.
     *
     * Return true if it is valid, or false if not. If another match can't be found,
     * this will mean a 404. You can also directly return an object with
     * statusCode/statusMessage to respond immediately with an error (other matches
     * will not be checked).
     */
    validate?: (route: TypedRoute) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>;
    key?: false | string | ((route: TypedRoute) => string);
    /** Allow types augmented by other modules */
    [key: string]: any;
  }


  /** 
   * Typed clone of \`definePageMeta\`
   * 
   * \u26A0\uFE0F Types for the redirect function may be buggy or not display autocomplete
   * Use \`helpers.route\` or \`helpers.path\` to provide autocomplete.
   *
   * \`\`\`ts
   * import {helpers} from '@typed-router';
   * definePageMeta({
   *   redirect(route) {
   *      return helpers.path('/foo')
   *   }
   * });
   * \`\`\`
   * @exemple
   * 
   * \`\`\`ts
   * definePageMeta({
   *   validate(route) {
   * });
   * \`\`\`
   */
export function definePageMeta<P extends string, U extends RoutesNamesList>(
  meta: TypedPageMeta & { redirect: TypedRouteLocationRawFromName<U, P> }
): void;
${returnIfTrue(
      pathCheck && !strictOptions.router.strictToArgument,
      `export function definePageMeta<P extends string>(
  meta: TypedPageMeta & { redirect: TypedPathParameter<P> }
): void;`
    )}
export function definePageMeta<P extends string = string>(
  meta: TypedPageMeta & {
    redirect?: (to: TypedRoute) => TypedRouteLocationRaw<P> ${returnIfTrue(
      pathCheck && !strictOptions.router.strictToArgument,
      ` | TypedPathParameter<P>`
    )};
  }
): void;
export function definePageMeta<P extends string = string>(
  meta: TypedPageMeta & {
    redirect?: () => TypedRouteLocationRaw<P> ${returnIfTrue(
      pathCheck && !strictOptions.router.strictToArgument,
      ` | TypedPathParameter<P>`
    )};
  }
): void;
export function definePageMeta(meta?: TypedPageMeta): void {
  return defaultDefinePageMeta(meta);
}
   
  `
  );
}

function createHelpersFile() {
  const { pathCheck } = moduleOptionStore;
  return (
    /* typescript */
    `
  
  

  import type { RouteLocationRaw } from 'vue-router';
  import type { TypedRouteLocationRawFromName, TypedLocationAsRelativeRaw } from './__router';
  import type { RoutesNamesList } from './__routes';
  ${returnIfTrue(
      pathCheck,
      `import type {TypedPathParameter, RouteNameFromPath} from './__paths';`
    )}

export const helpers = {
  route<T extends RoutesNamesList = never, P extends string = never>(
    to: TypedRouteLocationRawFromName<T, P>
  ): [T] extends [never]
    ? string
    : Required<
        Omit<Exclude<RouteLocationRaw, string>, 'name' | 'params'> & TypedLocationAsRelativeRaw<T>
      > {
    return to as any;
  },
  path<T extends string = never>(
    to: TypedPathParameter<T>
  ): [T] extends [never]
    ? string
    : Required<TypedRouteLocationRawFromName<RouteNameFromPath<T>, T>> {
    return to as any;
  },
};

   
  `
  );
}

function createNuxtLinkLocaleDefinitionFile() {
  moduleOptionStore.getResolvedStrictOptions();
  return (
    /* typescript */
    `
    
    import type { NuxtLinkProps, PageMeta } from 'nuxt/app';
    import NuxtLink from 'nuxt/dist/app/components/nuxt-link';
    import type { RoutesNamedLocations, RoutesNamesListRecord, RoutesNamesList } from './__routes';
    import type {TypedRouter, TypedRoute, TypedRouteLocationRawFromName, TypedLocationAsRelativeRaw} from './__router';
    import type {NuxtLocaleRoute, I18nLocales} from './__i18n-router';
    
    
    type TypedNuxtLinkLocaleProps<
    T extends RoutesNamesList,
    P extends string,
    E extends boolean = false> = Omit<NuxtLinkProps, 'to' | 'external'> &
     {
      to: NuxtLocaleRoute<T, P, E>,
      external?: E,
      locale?: E extends true ? never : I18nLocales
      }
    
    export type TypedNuxtLinkLocale = new <T extends RoutesNamesList, P extends string, E extends boolean = false>(props: TypedNuxtLinkLocaleProps<T, P, E>) => Omit<
      typeof NuxtLink,
      '$props'
    > & {
      $props: TypedNuxtLinkLocaleProps<T, P, E>;
    };
    
  `
  );
}

async function handleAddPlugin() {
  const pluginName = "__typed-router.plugin.ts";
  addPluginTemplate({
    filename: pluginName,
    getContents: createPluginFile,
    mode: "all"
  });
}

const defaultPrettierOptions = {
  printWidth: 100,
  tabWidth: 2,
  trailingComma: "es5",
  singleQuote: true,
  semi: true,
  bracketSpacing: true,
  htmlWhitespaceSensitivity: "strict"
};
async function formatOutputWithPrettier(template) {
  try {
    let prettierFoundOptions = await prettier.resolveConfig(process.cwd());
    if (!prettierFoundOptions) {
      prettierFoundOptions = defaultPrettierOptions;
    }
    const formatedTemplate = prettier.format(template, {
      ...prettierFoundOptions,
      parser: "typescript"
    });
    return formatedTemplate;
  } catch (e) {
    console.error(logSymbols.error, chalk.red("Error while formatting the output"), "\n" + e);
    return Promise.reject(e);
  }
}

dirname(fileURLToPath(import.meta.url));
async function processPathAndWriteFile({
  content,
  fileName,
  outDir
}) {
  try {
    const { rootDir } = moduleOptionStore;
    const finalOutDir = outDir ?? `.nuxt/typed-router`;
    const processedOutDir = resolve(rootDir, finalOutDir);
    const outputFile = resolve(process.cwd(), `${processedOutDir}/${fileName}`);
    const formatedContent = await formatOutputWithPrettier(content);
    if (fs.existsSync(outputFile)) {
      await writeFile(outputFile, formatedContent);
    } else {
      let dirList = outputFile.split("/");
      dirList.pop();
      const dirPath = dirList.join("/");
      await mkdirp(dirPath);
      await writeFile(outputFile, formatedContent);
    }
  } catch (e) {
    return Promise.reject(e);
  }
}
async function writeFile(path, content) {
  try {
    await fs.writeFileSync(path, content);
  } catch (e) {
    console.log(logSymbols.error, chalk.red(`Error while saving file at ${path}`, e));
    return Promise.reject(e);
  }
}

const watermarkTemplate = `
  // @ts-nocheck
  // eslint-disable
  // ---------------------------------------------------
  // \u{1F697}\u{1F6A6} Generated by nuxt-typed-router. Do not modify !
  // ---------------------------------------------------
  
  
 
`;

let previousGeneratedRoutes = "";
async function saveGeneratedFiles({ outputData }) {
  const { i18n } = moduleOptionStore;
  const filesMap = [
    {
      fileName: "__useTypedRouter.ts",
      content: createUseTypedRouterFile()
    },
    {
      fileName: "__useTypedRoute.ts",
      content: createUseTypedRouteFile()
    },
    {
      fileName: "__useTypedLink.ts",
      content: createUseTypedLinkFile()
    },
    {
      fileName: "__paths.d.ts",
      content: createPathsFiles(outputData)
    },
    {
      fileName: `__routes.ts`,
      content: createRoutesTypesFile(outputData)
    },
    {
      fileName: `__helpers.ts`,
      content: createHelpersFile()
    },
    {
      fileName: "__navigateTo.ts",
      content: createNavigateToFile()
    },
    {
      fileName: "__definePageMeta.ts",
      content: createDefinePageMetaFile()
    },
    {
      fileName: `__router.d.ts`,
      content: createTypedRouterFile()
    },
    {
      fileName: `__types_utils.d.ts`,
      content: createTypeUtilsRuntimeFile()
    },
    {
      fileName: `typed-router.d.ts`,
      content: createTypedRouterDefinitionFile()
    },
    {
      fileName: "index.ts",
      content: createIndexFile()
    }
  ];
  if (i18n) {
    filesMap.push({
      fileName: "__i18n-router.ts",
      content: createi18nRouterFile()
    });
    filesMap.push({
      fileName: "__NuxtLinkLocale.ts",
      content: createNuxtLinkLocaleDefinitionFile()
    });
  }
  await Promise.all(
    filesMap.map(({ content, fileName }) => {
      const waterMakeredContent = `
        ${watermarkTemplate}

        ${content}
      `;
      return processPathAndWriteFile({ content: waterMakeredContent, fileName });
    })
  );
  if (previousGeneratedRoutes !== outputData.routesList.join(",")) {
    previousGeneratedRoutes = outputData.routesList.join(",");
    console.log(logSymbols.success, `Router autocompletions generated \u{1F6A6}`);
  }
}

function extractUnMatchingSiblings(mainRoute, siblingRoutes) {
  return siblingRoutes?.filter((s) => {
    return s.name !== mainRoute.name;
  });
}

const specialCharacterRegxp = /([^a-zA-Z0-9_])/gm;
function is18Sibling(source, route) {
  const { i18n, i18nOptions, i18nLocales } = moduleOptionStore;
  if (i18n && i18nOptions && i18nOptions?.strategy !== "no_prefix") {
    const i18LocalesRecognizer = i18nLocales?.map((m) => m.replace(specialCharacterRegxp, "\\$&")).join("|");
    return !!route.path?.match(new RegExp(`^/?(${i18LocalesRecognizer})(/.*)?$`, "g"));
  }
  return false;
}
function modifyRoutePrefixDefaultIfI18n(route) {
  const { i18n, i18nOptions, i18nLocales } = moduleOptionStore;
  if (i18n && i18nOptions && route.name) {
    const separator = i18nOptions?.routesNameSeparator ?? "___";
    const i18LocalesRecognizer = i18nLocales?.map((m) => m.replace(specialCharacterRegxp, "\\$&")).join("|");
    if (i18nOptions?.strategy === "prefix_and_default") {
      const routeDefaultRegXp = new RegExp(
        `([a-zA-Z0-9-]+)${separator}(${i18LocalesRecognizer})${separator}default`,
        "g"
      );
      const match = routeDefaultRegXp.exec(route.name);
      if (match) {
        const [_, routeName] = match;
        route.name = routeName;
        return {
          ...route,
          name: routeName
        };
      }
    } else if (i18nOptions?.strategy === "prefix_except_default") {
      let defaultLocale = i18nLocales.find((f) => f === i18nOptions.defaultLocale) ? i18nOptions.defaultLocale?.replace(specialCharacterRegxp, "\\$&") : void 0;
      const routeDefaultNameRegXp = new RegExp(`^([a-zA-Z0-9-]+)${separator}${defaultLocale}`, "g");
      const match = routeDefaultNameRegXp.exec(route.name);
      if (match) {
        const [_, routeName] = match;
        return {
          ...route,
          name: routeName
        };
      }
    }
  }
  return route;
}

function createKeyedName(route, parent) {
  const splittedPaths = route.path.split("/");
  const parentPath = splittedPaths[splittedPaths.length - 1];
  if (parent) {
    return camelCase(parentPath || "index");
  } else {
    return camelCase(route.path.split("/").join("-")) || "index";
  }
}
function createNameKeyFromFullName(route, level, parentName) {
  let splitted = [];
  splitted = route.name?.split("-") ?? [];
  splitted = splitted.slice(level, splitted.length);
  if (splitted[0] === parentName) {
    splitted.splice(0, 1);
  }
  const keyName = route.path === "" ? "index" : camelCase(splitted.join("-")) || "index";
  return keyName;
}
function walkThoughRoutes({
  route: _route,
  level,
  siblings,
  parent,
  previousParams,
  output,
  isLast,
  isLocale
}) {
  const route = modifyRoutePrefixDefaultIfI18n(_route);
  const isLocaleRoute = isLocale || is18Sibling(output.routesPaths, route);
  if (route.file && moduleOptionStore.resolvedIgnoredRoutes.includes(route.file)) {
    return;
  }
  const newPath = `${parent?.path ?? ""}${route.path.startsWith("/") || parent?.path === "/" ? route.path : `/${route.path}`}`;
  if (parent?.path !== "/" || newPath !== parent?.path) {
    output.routesPaths.push({
      name: route.name,
      path: newPath,
      isLocale: isLocaleRoute
    });
  }
  if (route.children?.length) {
    let childrenChunks = route.children;
    let nameKey = createKeyedName(route, parent);
    const allRouteParams = extractRouteParamsFromPath(route.path, false, previousParams);
    const newRoute = { ...route, name: nameKey, path: newPath };
    if (!isLocaleRoute) {
      output.routesObjectTemplate += `${nameKey}:{`;
      output.routesDeclTemplate += `"${nameKey}":{`;
    }
    childrenChunks?.map(
      (routeConfig, index) => walkThoughRoutes({
        route: routeConfig,
        level: level + 1,
        siblings: extractUnMatchingSiblings(route, siblings),
        parent: newRoute,
        previousParams: allRouteParams,
        output,
        isLast: isItemLast(childrenChunks, index),
        isLocale: isLocaleRoute
      })
    );
    if (!isLocaleRoute) {
      output.routesObjectTemplate += "},";
      output.routesDeclTemplate += `}${isLast ? "" : ","}`;
    }
  } else if (route.name && !isLocaleRoute) {
    let keyName = createNameKeyFromFullName(route, level, parent?.name);
    output.routesObjectTemplate += `'${keyName}': '${route.name}' as const,`;
    output.routesDeclTemplate += `"${keyName}": "${route.name}"${isLast ? "" : ","}`;
    output.routesList.push(route.name);
    const isIndexFileForRouting = route.path === "";
    const allRouteParams = extractRouteParamsFromPath(
      route.path,
      isIndexFileForRouting,
      previousParams
    );
    output.routesParams.push({
      name: route.name,
      params: allRouteParams
    });
  }
}

function constructRouteMap(routesConfig) {
  try {
    let routesObjectTemplate = "{";
    let routesDeclTemplate = "{";
    let routesList = [];
    let routesParams = [];
    let routesPaths = [];
    const output = {
      routesObjectTemplate,
      routesDeclTemplate,
      routesList,
      routesParams,
      routesPaths
    };
    startGenerator({
      output,
      routesConfig
    });
    return output;
  } catch (e) {
    throw new Error(`Generation failed: ${e}`);
  }
}
function startGenerator({ output, routesConfig }) {
  routesConfig.forEach((route, index) => {
    const rootSiblingsRoutes = routesConfig.filter((rt) => rt.path !== route.path);
    walkThoughRoutes({
      route,
      level: 0,
      output,
      siblings: rootSiblingsRoutes,
      isLast: isItemLast(routesConfig, index),
      isLocale: false
    });
  });
  output.routesObjectTemplate += "}";
  output.routesDeclTemplate += "}";
}

let hasLoggedNoPages = false;
let hasRoutesDefined = false;
async function createTypedRouter({
  nuxt,
  routesConfig,
  isHookCall = false
}) {
  try {
    const rootDir = nuxt.options.rootDir;
    const srcDir = nuxt.options.srcDir;
    const autoImport = nuxt.options.imports.autoImport ?? true;
    moduleOptionStore.updateOptions({ rootDir, autoImport, srcDir });
    if (!isHookCall) {
      if (routesConfig) {
        await nuxt.callHook("pages:extend", routesConfig);
        return;
      }
      nuxt.hook("pages:extend", (routesConfig2) => {
        createTypedRouter({ nuxt, routesConfig: routesConfig2, isHookCall: true });
      });
      nuxt.hook("modules:done", () => {
        createTypedRouter({ nuxt, isHookCall: true });
      });
      if (moduleOptionStore.plugin) {
        await handleAddPlugin();
      }
      return;
    }
    extendPages(async (routes) => {
      hasRoutesDefined = true;
      const outputData = constructRouteMap(routes);
      await saveGeneratedFiles({
        outputData
      });
    });
    setTimeout(() => {
      if (!hasRoutesDefined && !hasLoggedNoPages) {
        hasLoggedNoPages = true;
        console.log(
          logSymbols.warning,
          chalk.yellow(
            `\u{1F6A6} No routes defined. Check if your ${chalk.underline(
              chalk.bold("pages")
            )} folder exists`
          )
        );
      }
    }, 3e3);
  } catch (e) {
    console.error(chalk.red("Error while generating routes definitions model"), "\n" + e);
  }
}

async function removeNuxtDefinitions({
  buildDir,
  autoImport
}) {
  const { resolve } = createResolver(import.meta.url);
  const componentFilePath = resolve(buildDir, "components.d.ts");
  if (existsSync(componentFilePath)) {
    const componentDefinitions = await readFile(componentFilePath, {
      encoding: "utf8"
    });
    const replacedNuxtLink = componentDefinitions.replace(
      /'NuxtLink': typeof import\(".*"\)\['default'\]|'NuxtLinkLocale': typeof import\(".*"\)\['default'\]/gm,
      ""
    );
    processPathAndWriteFile({
      content: replacedNuxtLink,
      fileName: "components.d.ts",
      outDir: ".nuxt"
    });
  }
  if (autoImport) {
    const importsFilePath = resolve(buildDir, "types/imports.d.ts");
    if (existsSync(importsFilePath)) {
      let globalDefinitions = await readFile(importsFilePath, {
        encoding: "utf8"
      });
      const importsToRemove = [
        "useRouter",
        "useRoute",
        "useLocalePath",
        "useLocaleRoute",
        "definePageMeta",
        "navigateTo"
      ].map((m) => new RegExp(`const ${m}: typeof import\\('.*'\\)\\['${m}'\\]`, "gm"));
      importsToRemove.forEach((imp) => {
        globalDefinitions = globalDefinitions.replace(imp, "");
      });
      processPathAndWriteFile({
        content: globalDefinitions,
        fileName: "types/imports.d.ts",
        outDir: ".nuxt"
      });
    }
  }
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-typed-router",
    configKey: "nuxtTypedRouter",
    compatibility: { nuxt: "^3.0.0", bridge: false }
  },
  defaults: {
    plugin: false,
    strict: false,
    pathCheck: true,
    removeNuxtDefs: true,
    ignoreRoutes: []
  },
  setup(moduleOptions, nuxt) {
    const { resolve } = createResolver(import.meta.url);
    const rootDir = nuxt.options.rootDir;
    let i18nOptions = null;
    const hasi18nModuleRegistered = nuxt.options.modules.some((mod) => {
      if (Array.isArray(mod)) {
        const [moduleName, options] = mod;
        const isRegistered = moduleName === "@nuxtjs/i18n";
        if (isRegistered) {
          i18nOptions = options;
        }
        return isRegistered;
      } else {
        const isRegistered = mod === "@nuxtjs/i18n";
        if (isRegistered) {
          i18nOptions = nuxt.options.i18n;
        }
        return isRegistered;
      }
    });
    const isDocumentDriven = !!nuxt.options.modules.find((mod) => {
      if (Array.isArray(mod)) {
        return mod[0] === "@nuxt/content";
      } else {
        return mod === "@nuxt/content";
      }
    }) && "content" in nuxt.options && "documentDriven" in nuxt.options.content;
    moduleOptionStore.updateOptions({
      ...moduleOptions,
      i18n: hasi18nModuleRegistered,
      i18nOptions,
      isDocumentDriven
    });
    nuxt.options.alias = {
      ...nuxt.options.alias,
      "@typed-router": resolve(`${rootDir}/.nuxt/typed-router`)
    };
    nuxt.hook("prepare:types", (options) => {
      options.tsConfig.include?.unshift("./typed-router/typed-router.d.ts");
      if (moduleOptions.pathCheck) {
        options.tsConfig.vueCompilerOptions = {
          jsxTemplates: true,
          experimentalRfc436: true
        };
      }
      if (moduleOptions.removeNuxtDefs) {
        removeNuxtDefinitions({
          autoImport: nuxt.options.imports.autoImport ?? true,
          buildDir: nuxt.options.buildDir
        });
      }
    });
    nuxt.hook("build:done", () => {
      if (moduleOptions.removeNuxtDefs) {
        removeNuxtDefinitions({
          autoImport: nuxt.options.imports.autoImport ?? true,
          buildDir: nuxt.options.buildDir
        });
      }
    });
    if (nuxt.options.dev) {
      nuxt.hook("devtools:customTabs", (tabs) => {
        tabs.push({
          name: "nuxt-typed-router",
          title: "Nuxt Typed Router",
          icon: "https://github.com/victorgarciaesgi/nuxt-typed-router/blob/master/.github/images/logo.png?raw=true",
          view: {
            type: "iframe",
            src: "https://nuxt-typed-router.vercel.app/"
          }
        });
      });
    }
    createTypedRouter({ nuxt });
  }
});

export { module as default };
