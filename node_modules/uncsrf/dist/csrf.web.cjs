'use strict';

const webCrypto = globalThis.crypto;
const subtle = webCrypto.subtle;
const getRandomValues = (array) => webCrypto.getRandomValues(array);
const defaultEncryptAlgorithm = "AES-CBC";
const importEncryptSecret = async (secret, encryptAlgorithm) => {
  const encryptKey = await subtle.generateKey(
    {
      name: encryptAlgorithm || defaultEncryptAlgorithm,
      length: 256
    },
    true,
    ["encrypt", "decrypt"]
  );
  return await subtle.exportKey("jwk", encryptKey);
};
const importKey = (key, encryptAlgorithm) => {
  return subtle.importKey(
    "jwk",
    key,
    {
      name: encryptAlgorithm || defaultEncryptAlgorithm,
      length: 256
    },
    true,
    ["encrypt", "decrypt"]
  );
};
const create = async (secret, encryptSecret, encryptAlgorithm) => {
  const iv = getRandomValues(new Uint8Array(16));
  const encrypted = await subtle.encrypt(
    { name: encryptAlgorithm || defaultEncryptAlgorithm, iv },
    await importKey(encryptSecret, encryptAlgorithm),
    new TextEncoder().encode(secret)
  );
  const encryptedBuffer = Buffer.from(new Uint8Array(encrypted));
  return `${Buffer.from(iv).toString("base64")}:${encryptedBuffer.toString(
    "base64"
  )}`;
};
const verify = async (secret, token, encryptSecret, encryptAlgorithm) => {
  const [iv, encrypted] = token.split(":");
  if (!iv || !encrypted) {
    return false;
  }
  let decrypted;
  try {
    const encodedDecrypted = await subtle.decrypt(
      {
        name: encryptAlgorithm || defaultEncryptAlgorithm,
        iv: Buffer.from(iv, "base64")
      },
      await importKey(encryptSecret, encryptAlgorithm),
      Buffer.from(encrypted, "base64")
    );
    decrypted = new TextDecoder().decode(encodedDecrypted);
  } catch {
    return false;
  }
  return decrypted === secret;
};
const randomSecret = () => webCrypto.randomUUID();

exports.create = create;
exports.defaultEncryptAlgorithm = defaultEncryptAlgorithm;
exports.importEncryptSecret = importEncryptSecret;
exports.randomSecret = randomSecret;
exports.verify = verify;
